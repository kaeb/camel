var _apacheCamelModelVersion = '2.18.1';

var _apacheCamelModel ={
  "definitions": {
    "expression": {
      "type": "object",
      "title": "expression",
      "group": "language",
      "icon": "generic24.png",
      "description": "Expression in the choose language",
      "properties": {
        "expression": {
          "kind": "element",
          "type": "string",
          "title": "Expression",
          "description": "The expression",
          "required": true
        },
        "language": {
          "kind": "element",
          "type": "string",
          "title": "Expression",
          "description": "The chosen language",
          "required": true,
          "enum": [ "constant", "el", "exchangeProperty", "groovy", "header", "javaScript", "jsonpath", "jxpath", "language", "method", "mvel", "ognl", "php", "python", "ref", "ruby", "simple", "spel", "sql", "terser", "tokenize", "xpath", "xquery", "xtokenize" ]
        }
      }
    },
    "aggregate": {
      "type": "object",
      "title": "Aggregate",
      "group": "eip,routing",
      "icon": "aggregate24.png",
      "description": "Aggregates many messages into a single message",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "correlationExpression": {
          "kind": "expression",
          "type": "object",
          "description": "The expression used to calculate the correlation key to use for aggregation. The Exchange which has the same correlation key is aggregated together. If the correlation key could not be evaluated an Exception is thrown. You can disable this by using the ignoreBadCorrelationKeys option.",
          "title": "Correlation Expression",
          "required": true,
          "deprecated": false
        },
        "completionPredicate": {
          "kind": "expression",
          "type": "object",
          "description": "TODO: document Note: this is experimental and subject to changes in future releases.",
          "title": "Completion Predicate",
          "required": false,
          "deprecated": false
        },
        "completionTimeoutExpression": {
          "kind": "expression",
          "type": "object",
          "description": "Sets the completion timeout which would cause the aggregate to consider the group as complete and send out the aggregated exchange.",
          "title": "Completion Timeout",
          "required": false,
          "deprecated": false
        },
        "completionSizeExpression": {
          "kind": "expression",
          "type": "object",
          "description": "Sets the completion size which is the number of aggregated exchanges which would cause the aggregate to consider the group as complete and send out the aggregated exchange.",
          "title": "Completion Size",
          "required": false,
          "deprecated": false
        },
        "optimisticLockRetryPolicy": {
          "kind": "element",
          "type": "object",
          "description": "Allows to configure retry settings when using optimistic locking.",
          "title": "Optimistic Lock Retry Policy",
          "required": false,
          "deprecated": false
        },
        "parallelProcessing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "When aggregated are completed they are being send out of the aggregator. This option indicates whether or not Camel should use a thread pool with multiple threads for concurrency. If no custom thread pool has been specified then Camel creates a default pool with 10 concurrent threads.",
          "title": "Parallel Processing",
          "required": false,
          "deprecated": false
        },
        "optimisticLocking": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Turns on using optimistic locking which requires the aggregationRepository being used is supporting this by implementing org.apache.camel.spi.OptimisticLockingAggregationRepository.",
          "title": "Optimistic Locking",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "If using parallelProcessing you can specify a custom thread pool to be used. In fact also if you are not using parallelProcessing this custom thread pool is used to send out aggregated exchanges as well.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "timeoutCheckerExecutorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "If using either of the completionTimeout completionTimeoutExpression or completionInterval options a background thread is created to check for the completion for every aggregator. Set this option to provide a custom thread pool to be used rather than creating a new thread for every aggregator.",
          "title": "Timeout Checker Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "aggregationRepositoryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the custom aggregate repository to use Will by default use org.apache.camel.processor.aggregate.MemoryAggregationRepository",
          "title": "Aggregation Repository Ref",
          "required": false,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "A reference to lookup the AggregationStrategy in the Registry. Configuring an AggregationStrategy is required and is used to merge the incoming Exchange with the existing already merged exchanges. At first call the oldExchange parameter is null. On subsequent invocations the oldExchange contains the merged exchanges and newExchange is of course the new incoming Exchange.",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used for the very first aggregation. If this option is true then null values is used as the oldExchange (at the very first aggregation) when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "completionSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the completion size which is the number of aggregated exchanges which would cause the aggregate to consider the group as complete and send out the aggregated exchange.",
          "title": "Completion Size",
          "required": false,
          "deprecated": false
        },
        "completionInterval": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the completion interval which would cause the aggregate to consider the group as complete and send out the aggregated exchange.",
          "title": "Completion Interval",
          "required": false,
          "deprecated": false
        },
        "completionTimeout": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the completion timeout which would cause the aggregate to consider the group as complete and send out the aggregated exchange.",
          "title": "Completion Timeout",
          "required": false,
          "deprecated": false
        },
        "completionFromBatchConsumer": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables the batch completion mode where we aggregate from a org.apache.camel.BatchConsumer and aggregate the total number of exchanges the org.apache.camel.BatchConsumer has reported as total by checking the exchange property link org.apache.camel.ExchangeBATCH_COMPLETE when its complete.",
          "title": "Completion From Batch Consumer",
          "required": false,
          "deprecated": false
        },
        "groupExchanges": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables grouped exchanges so the aggregator will group all aggregated exchanges into a single combined Exchange holding all the aggregated exchanges in a java.util.List.",
          "title": "Group Exchanges",
          "required": false,
          "deprecated": true
        },
        "eagerCheckCompletion": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Use eager completion checking which means that the completionPredicate will use the incoming Exchange. As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.",
          "title": "Eager Check Completion",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidCorrelationKeys": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If a correlation key cannot be successfully evaluated it will be ignored by logging a DEBUG and then just ignore the incoming Exchange.",
          "title": "Ignore Invalid Correlation Keys",
          "required": false,
          "deprecated": false
        },
        "closeCorrelationKeyOnCompletion": {
          "kind": "attribute",
          "type": "integer",
          "description": "Closes a correlation key when its complete. Any late received exchanges which has a correlation key that has been closed it will be defined and a ClosedCorrelationKeyException is thrown.",
          "title": "Close Correlation Key On Completion",
          "required": false,
          "deprecated": false
        },
        "discardOnCompletionTimeout": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Discards the aggregated message on completion timeout. This means on timeout the aggregated message is dropped and not sent out of the aggregator.",
          "title": "Discard On Completion Timeout",
          "required": false,
          "deprecated": false
        },
        "forceCompletionOnStop": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Indicates to complete all current aggregated exchanges when the context is stopped",
          "title": "Force Completion On Stop",
          "required": false,
          "deprecated": false
        },
        "completeAllOnStop": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Indicates to wait to complete all current and partial (pending) aggregated exchanges when the context is stopped. This also means that we will wait for all pending exchanges which are stored in the aggregation repository to complete so the repository is empty before we can stop. You may want to enable this when using the memory based aggregation repository that is memory based only and do not store data on disk. When this option is enabled then the aggregator is waiting to complete all those exchanges before its stopped when stopping CamelContext or the route using it.",
          "title": "Complete All On Stop",
          "required": false,
          "deprecated": false
        },
        "aggregateControllerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a org.apache.camel.processor.aggregate.AggregateController to allow external sources to control this aggregator.",
          "title": "Aggregate Controller Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "aop": {
      "type": "object",
      "title": "Aop",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Does processing before and/or after the route is completed",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "beforeUri": {
          "kind": "attribute",
          "type": "string",
          "description": "Endpoint to call in AOP before.",
          "title": "Before Uri",
          "required": false,
          "deprecated": false
        },
        "afterUri": {
          "kind": "attribute",
          "type": "string",
          "description": "Endpoint to call in AOP after. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.",
          "title": "After Uri",
          "required": false,
          "deprecated": false
        },
        "afterFinallyUri": {
          "kind": "attribute",
          "type": "string",
          "description": "Endpoint to call in AOP after finally. The difference between after and afterFinally is that afterFinally is invoked from a finally block so it will always be invoked no matter what eg also in case of an exception occur.",
          "title": "After Finally Uri",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "batch-config": {
      "type": "object",
      "title": "Batch-config",
      "group": "eip,routing,resequence",
      "icon": "generic24.png",
      "description": "Configures batch-processing resequence eip.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "batchSize": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "100",
          "description": "Sets the size of the batch to be re-ordered. The default size is 100.",
          "title": "Batch Size",
          "required": false,
          "deprecated": false
        },
        "batchTimeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1000",
          "description": "Sets the timeout for collecting elements to be re-ordered. The default timeout is 1000 msec.",
          "title": "Batch Timeout",
          "required": false,
          "deprecated": false
        },
        "allowDuplicates": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to allow duplicates.",
          "title": "Allow Duplicates",
          "required": false,
          "deprecated": false
        },
        "reverse": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to reverse the ordering.",
          "title": "Reverse",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidExchanges": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore invalid exchanges",
          "title": "Ignore Invalid Exchanges",
          "required": false,
          "deprecated": false
        }
      }
    },
    "bean": {
      "type": "object",
      "title": "Bean",
      "group": "eip,endpoint",
      "icon": "bean24.png",
      "description": "Calls a java bean",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a bean to use",
          "title": "Ref",
          "required": false,
          "deprecated": false
        },
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the method name on the bean to use",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "beanType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Class of the bean",
          "title": "Bean Type",
          "required": false,
          "deprecated": false
        },
        "cache": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Caches the bean lookup to avoid lookup up bean on every usage.",
          "title": "Cache",
          "required": false,
          "deprecated": false
        },
        "multiParameterArray": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the message body is an array type.",
          "title": "Multi Parameter Array",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "beanPostProcessor": {
      "type": "object",
      "title": "Bean Post Processor",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Spring specific DefaultCamelBeanPostProcessor which uses Spring BeanPostProcessor to post process beans.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
      }
    },
    "camelContext": {
      "type": "object",
      "title": "Camel Context",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "CamelContext using XML configuration.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "depends-on": {
          "kind": "attribute",
          "type": "string",
          "description": "List of other bean id's this CamelContext depends up. Multiple bean id's can be separated by comma.",
          "title": "Depends-on",
          "required": false,
          "deprecated": false
        },
        "trace": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether tracing is enabled or not.",
          "title": "Trace",
          "required": false,
          "deprecated": false
        },
        "messageHistory": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Sets whether message history is enabled or not.",
          "title": "Message History",
          "required": false,
          "deprecated": false
        },
        "logExhaustedMessageBody": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether to log exhausted message body with message history.",
          "title": "Log Exhausted Message Body",
          "required": false,
          "deprecated": false
        },
        "streamCache": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether stream caching is enabled or not.",
          "title": "Stream Cache",
          "required": false,
          "deprecated": false
        },
        "delayer": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a delay value in millis that a message is delayed at every step it takes in the route path slowing the process down to better observe what is occurring",
          "title": "Delayer",
          "required": false,
          "deprecated": false
        },
        "handleFault": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether fault handling is enabled or not (default is disabled).",
          "title": "Handle Fault",
          "required": false,
          "deprecated": false
        },
        "errorHandlerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the name of the error handler object used to default the error handling strategy",
          "title": "Error Handler Ref",
          "required": false,
          "deprecated": false
        },
        "autoStartup": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Sets whether the object should automatically start when Camel starts. Important: Currently only routes can be disabled as CamelContexts are always started. Note: When setting auto startup false on CamelContext then that takes precedence and no routes is started. You would need to start CamelContext explicit using the link org.apache.camel.CamelContextstart() method to start the context and then you would need to start the routes manually using link CamelContextstartRoute(String).",
          "title": "Auto Startup",
          "required": false,
          "deprecated": false
        },
        "shutdownEager": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Whether to shutdown CamelContext eager when Spring is shutting down. This ensure a cleaner shutdown of Camel as dependent bean's are not shutdown at this moment. The bean's will then be shutdown after camelContext.",
          "title": "Shutdown Eager",
          "required": false,
          "deprecated": false
        },
        "useMDCLogging": {
          "kind": "attribute",
          "type": "string",
          "description": "Set whether MDC is enabled.",
          "title": "Use M D C Logging",
          "required": false,
          "deprecated": false
        },
        "useBreadcrumb": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Set whether breadcrumb is enabled.",
          "title": "Use Breadcrumb",
          "required": false,
          "deprecated": false
        },
        "allowUseOriginalMessage": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether to allow access to the original message from Camel's error handler or from link org.apache.camel.spi.UnitOfWorkgetOriginalInMessage(). Turning this off can optimize performance as defensive copy of the original message is not needed.",
          "title": "Allow Use Original Message",
          "required": false,
          "deprecated": false
        },
        "runtimeEndpointRegistryEnabled": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether org.apache.camel.spi.RuntimeEndpointRegistry is enabled.",
          "title": "Runtime Endpoint Registry Enabled",
          "required": false,
          "deprecated": false
        },
        "managementNamePattern": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "#name#",
          "description": "The naming pattern for creating the CamelContext management name.",
          "title": "Management Name Pattern",
          "required": false,
          "deprecated": false
        },
        "threadNamePattern": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "Camel (#camelId#) thread ##counter# - #name#",
          "description": "Sets the thread name pattern used for creating the full thread name. The default pattern is: Camel (camelId) thread counter - name Where camelId is the name of the org.apache.camel.CamelContext and counter is a unique incrementing counter. and name is the regular thread name. You can also use longName is the long thread name which can includes endpoint parameters etc.",
          "title": "Thread Name Pattern",
          "required": false,
          "deprecated": false
        },
        "shutdownRoute": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "Default",
          "enum": [ "Default", "Defer" ],
          "description": "Sets the ShutdownRoute option for routes.",
          "title": "Shutdown Route",
          "required": false,
          "deprecated": false
        },
        "shutdownRunningTask": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "CompleteCurrentTaskOnly",
          "enum": [ "CompleteAllTasks", "CompleteCurrentTaskOnly" ],
          "description": "Sets the ShutdownRunningTask option to use when shutting down a route.",
          "title": "Shutdown Running Task",
          "required": false,
          "deprecated": false
        },
        "lazyLoadTypeConverters": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether type converters should be loaded lazy",
          "title": "Lazy Load Type Converters",
          "required": false,
          "deprecated": true
        },
        "typeConverterStatisticsEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether or not type converter statistics is enabled. By default the type converter utilization statistics is disabled. Notice: If enabled then there is a slight performance impact under very heavy load. You can enable/disable the statistics at runtime using the link org.apache.camel.spi.TypeConverterRegistrygetStatistics()setTypeConverterStatisticsEnabled(Boolean) method or from JMX on the org.apache.camel.api.management.mbean.ManagedTypeConverterRegistryMBean mbean.",
          "title": "Type Converter Statistics Enabled",
          "required": false,
          "deprecated": false
        },
        "typeConverterExists": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "Override",
          "enum": [ "Fail", "Ignore", "Override" ],
          "description": "What should happen when attempting to add a duplicate type converter. The default behavior is to override the existing.",
          "title": "Type Converter Exists",
          "required": false,
          "deprecated": false
        },
        "typeConverterExistsLoggingLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "WARN",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "The logging level to use when logging that a type converter already exists when attempting to add a duplicate type converter. The default logging level is WARN",
          "title": "Type Converter Exists Logging Level",
          "required": false,
          "deprecated": false
        },
        "properties": {
          "kind": "element",
          "type": "object",
          "description": "Configuration of CamelContext properties such as limit of debug logging and other general options.",
          "title": "Properties",
          "required": false,
          "deprecated": false
        },
        "propertyPlaceholder": {
          "kind": "element",
          "type": "object",
          "description": "Configuration of property placeholder",
          "title": "Property Placeholder",
          "required": false,
          "deprecated": false
        },
        "package": {
          "kind": "element",
          "type": "array",
          "description": "Sets the package names to be recursively searched for Java classes which extend org.apache.camel.builder.RouteBuilder to be auto-wired up to the CamelContext as a route. Note that classes are excluded if they are specifically configured in the spring.xml A more advanced configuration can be done using link setPackageScan(org.apache.camel.model.PackageScanDefinition)",
          "title": "Package",
          "required": false,
          "deprecated": false
        },
        "packageScan": {
          "kind": "element",
          "type": "object",
          "description": "Sets the package scanning information. Package scanning allows for the automatic discovery of certain camel classes at runtime for inclusion e.g. org.apache.camel.builder.RouteBuilder implementations",
          "title": "Package Scan",
          "required": false,
          "deprecated": false
        },
        "contextScan": {
          "kind": "element",
          "type": "object",
          "description": "Sets the context scanning (eg Spring's ApplicationContext) information. Context scanning allows for the automatic discovery of Camel routes runtime for inclusion e.g. org.apache.camel.builder.RouteBuilder implementations",
          "title": "Context Scan",
          "required": false,
          "deprecated": false
        },
        "streamCaching": {
          "kind": "element",
          "type": "object",
          "description": "Configuration of stream caching.",
          "title": "Stream Caching",
          "required": false,
          "deprecated": false
        },
        "jmxAgent": {
          "kind": "element",
          "type": "object",
          "description": "Configuration of JMX.",
          "title": "Jmx Agent",
          "required": false,
          "deprecated": false
        },
        "beans": {
          "kind": "element",
          "type": "array",
          "description": "Miscellaneous configurations",
          "title": "Beans",
          "required": false,
          "deprecated": false
        },
        "routeBuilder": {
          "kind": "element",
          "type": "array",
          "description": "Refers to Java RouteBuilder instances to include as routes in this CamelContext.",
          "title": "Route Builder",
          "required": false,
          "deprecated": false
        },
        "routeContextRef": {
          "kind": "element",
          "type": "array",
          "description": "Refers to XML routes to include as routes in this CamelContext.",
          "title": "Route Context Ref",
          "required": false,
          "deprecated": false
        },
        "restContextRef": {
          "kind": "element",
          "type": "array",
          "description": "Refers to XML rest-dsl to include as REST services in this CamelContext.",
          "title": "Rest Context Ref",
          "required": false,
          "deprecated": false
        },
        "threadPoolProfile": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of thread pool profiles.",
          "title": "Thread Pool Profile",
          "required": false,
          "deprecated": false
        },
        "threadPool": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of thread pool",
          "title": "Thread Pool",
          "required": false,
          "deprecated": false
        },
        "endpoint": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of endpoints",
          "title": "Endpoint",
          "required": false,
          "deprecated": false
        },
        "dataFormats": {
          "kind": "element",
          "type": "object",
          "description": "Configuration of data formats.",
          "title": "Data Formats",
          "required": false,
          "deprecated": false
        },
        "redeliveryPolicyProfile": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of redelivery settings.",
          "title": "Redelivery Policy Profile",
          "required": false,
          "deprecated": false
        },
        "onException": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of error handlers that triggers on exceptions thrown.",
          "title": "On Exception",
          "required": false,
          "deprecated": false
        },
        "onCompletion": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of sub routes to run at the completion of routing.",
          "title": "On Completion",
          "required": false,
          "deprecated": false
        },
        "intercept": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of interceptors.",
          "title": "Intercept",
          "required": false,
          "deprecated": false
        },
        "interceptFrom": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of interceptors that triggers from the beginning of routes.",
          "title": "Intercept From",
          "required": false,
          "deprecated": false
        },
        "interceptSendToEndpoint": {
          "kind": "element",
          "type": "array",
          "description": "Configuration of interceptors that triggers sending messages to endpoints.",
          "title": "Intercept Send To Endpoint",
          "required": false,
          "deprecated": false
        },
        "restConfiguration": {
          "kind": "element",
          "type": "object",
          "description": "Configuration for rest-dsl",
          "title": "Rest Configuration",
          "required": false,
          "deprecated": false
        },
        "rest": {
          "kind": "element",
          "type": "array",
          "description": "Contains the rest services defined using the rest-dsl",
          "title": "Rest",
          "required": false,
          "deprecated": false
        },
        "route": {
          "kind": "element",
          "type": "array",
          "description": "Contains the Camel routes",
          "title": "Route",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id (name) of this CamelContext",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "choice": {
      "type": "object",
      "title": "Choice",
      "group": "eip,routing",
      "icon": "choice24.png",
      "description": "Routes messages based on a series of predicates",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "whenClauses": {
          "kind": "element",
          "type": "array",
          "description": "Sets the when clauses",
          "title": "When Clauses",
          "required": false,
          "deprecated": false
        },
        "otherwise": {
          "kind": "element",
          "type": "object",
          "description": "Sets the otherwise node",
          "title": "Otherwise",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "circuitBreaker": {
      "type": "object",
      "title": "Circuit Breaker",
      "group": "eip,routing,loadbalance,circuitbreaker",
      "icon": "generic24.png",
      "description": "Circuit break load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "exception": {
          "kind": "element",
          "type": "array",
          "description": "A list of class names for specific exceptions to monitor. If no exceptions is configured then all exceptions is monitored",
          "title": "Exception",
          "required": false,
          "deprecated": false
        },
        "halfOpenAfter": {
          "kind": "attribute",
          "type": "integer",
          "description": "The timeout in millis to use as threshold to move state from closed to half-open or open state",
          "title": "Half Open After",
          "required": false,
          "deprecated": false
        },
        "threshold": {
          "kind": "attribute",
          "type": "integer",
          "description": "Number of previous failed messages to use as threshold to move state from closed to half-open or open state",
          "title": "Threshold",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "consulConfiguration": {
      "type": "object",
      "title": "Consul Configuration",
      "group": "eip,routing,remote",
      "icon": "generic24.png",
      "description": "Consul remote service call configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "url": {
          "kind": "attribute",
          "type": "string",
          "description": "The Consul agent URL",
          "title": "Url",
          "required": false,
          "deprecated": false
        },
        "dc": {
          "kind": "attribute",
          "type": "string",
          "description": "The data center",
          "title": "Dc",
          "required": false,
          "deprecated": false
        },
        "aclToken": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the ACL token to be used with Consul",
          "title": "Acl Token",
          "required": false,
          "deprecated": false
        },
        "userName": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the username to be used for basic authentication",
          "title": "User Name",
          "required": false,
          "deprecated": false
        },
        "password": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the password to be used for basic authentication",
          "title": "Password",
          "required": false,
          "deprecated": false
        },
        "connectTimeoutMillis": {
          "kind": "attribute",
          "type": "integer",
          "description": "Connect timeout for OkHttpClient",
          "title": "Connect Timeout Millis",
          "required": false,
          "deprecated": false
        },
        "readTimeoutMillis": {
          "kind": "attribute",
          "type": "integer",
          "description": "Read timeout for OkHttpClient",
          "title": "Read Timeout Millis",
          "required": false,
          "deprecated": false
        },
        "writeTimeoutMillis": {
          "kind": "attribute",
          "type": "integer",
          "description": "Write timeout for OkHttpClient",
          "title": "Write Timeout Millis",
          "required": false,
          "deprecated": false
        },
        "blockSeconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "The second to wait for a watch event default 10 seconds",
          "title": "Block Seconds",
          "required": false,
          "deprecated": false
        },
        "component": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "http",
          "description": "Sets the default Camel component to use for calling the remote service. By default the http component is used. You can configure this to use netty4-http jetty restlet or some other components of choice. If the service is not HTTP protocol you can use other components such as mqtt jms amqp etc. If the service call has been configured using an uri then the component from the uri is used instead of this default component.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "clientProperty": {
          "kind": "element",
          "type": "array",
          "description": "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using ribbon then the client properties are define in com.netflix.client.config.CommonClientConfigKey.",
          "title": "Client Property",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "consumerTemplate": {
      "type": "object",
      "title": "Consumer Template",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Configures a ConsumerTemplate",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "maximumCacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets a custom maximum cache size to use in the backing cache pools.",
          "title": "Maximum Cache Size",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "contextScan": {
      "type": "object",
      "title": "Context Scan",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Scans for Java org.apache.camel.builder.RouteBuilder instances in the context org.apache.camel.spi.Registry.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "includeNonSingletons": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include non-singleton beans (prototypes) By default only singleton beans is included in the context scan",
          "title": "Include Non Singletons",
          "required": false,
          "deprecated": false
        },
        "excludes": {
          "kind": "element",
          "type": "array",
          "description": "Exclude finding route builder from these java package names.",
          "title": "Excludes",
          "required": false,
          "deprecated": false
        },
        "includes": {
          "kind": "element",
          "type": "array",
          "description": "Include finding route builder from these java package names.",
          "title": "Includes",
          "required": false,
          "deprecated": false
        }
      }
    },
    "convertBodyTo": {
      "type": "object",
      "title": "Convert Body To",
      "group": "eip,transformation",
      "icon": "convertBodyTo24.png",
      "description": "Converts the message body to another type",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "The java type to convert to",
          "title": "Type",
          "required": true,
          "deprecated": false
        },
        "charset": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a specific charset when converting",
          "title": "Charset",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "customLoadBalancer": {
      "type": "object",
      "title": "Custom Load Balancer",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Custom load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to the custom load balancer to lookup from the registry",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "delay": {
      "type": "object",
      "title": "Delay",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Delays processing for a specified length of time",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to define how long time to wait (in millis)",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom Thread Pool if asyncDelay has been enabled.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "asyncDelayed": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables asynchronous delay which means the thread will noy block while delaying.",
          "title": "Async Delayed",
          "required": false,
          "deprecated": false
        },
        "callerRunsWhenRejected": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true",
          "title": "Caller Runs When Rejected",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "description": {
      "type": "object",
      "title": "Description",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To provide comments about the node.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "lang": {
          "kind": "attribute",
          "type": "string",
          "description": "Language such as en for english.",
          "title": "Lang",
          "required": false,
          "deprecated": false
        },
        "layoutX": {
          "kind": "attribute",
          "type": "number",
          "description": "Layout position X",
          "title": "Layout X",
          "required": false,
          "deprecated": true
        },
        "layoutY": {
          "kind": "attribute",
          "type": "number",
          "description": "Layout position Y",
          "title": "Layout Y",
          "required": false,
          "deprecated": true
        },
        "layoutWidth": {
          "kind": "attribute",
          "type": "number",
          "description": "Layout width",
          "title": "Layout Width",
          "required": false,
          "deprecated": true
        },
        "layoutHeight": {
          "kind": "attribute",
          "type": "number",
          "description": "Layout height",
          "title": "Layout Height",
          "required": false,
          "deprecated": true
        },
        "text": {
          "kind": "value",
          "type": "string",
          "description": "The description as human readable text",
          "title": "Text",
          "required": true,
          "deprecated": false
        }
      }
    },
    "dnsConfiguration": {
      "type": "object",
      "title": "Dns Configuration",
      "group": "eip,routing,remote",
      "icon": "generic24.png",
      "description": "DNS remote service call configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "proto": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "_tcp",
          "description": "The transport protocol of the desired service.",
          "title": "Proto",
          "required": false,
          "deprecated": false
        },
        "domain": {
          "kind": "attribute",
          "type": "string",
          "description": "The domain name;",
          "title": "Domain",
          "required": false,
          "deprecated": false
        },
        "component": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "http",
          "description": "Sets the default Camel component to use for calling the remote service. By default the http component is used. You can configure this to use netty4-http jetty restlet or some other components of choice. If the service is not HTTP protocol you can use other components such as mqtt jms amqp etc. If the service call has been configured using an uri then the component from the uri is used instead of this default component.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "clientProperty": {
          "kind": "element",
          "type": "array",
          "description": "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using ribbon then the client properties are define in com.netflix.client.config.CommonClientConfigKey.",
          "title": "Client Property",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "doCatch": {
      "type": "object",
      "title": "Do Catch",
      "group": "error",
      "icon": "generic24.png",
      "description": "Catches exceptions as part of a try catch finally block",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "exception": {
          "kind": "element",
          "type": "array",
          "description": "The exception(s) to catch.",
          "title": "Exception",
          "required": false,
          "deprecated": false
        },
        "onWhen": {
          "kind": "element",
          "type": "object",
          "description": "Sets an additional predicate that should be true before the onCatch is triggered. To be used for fine grained controlling whether a thrown exception should be intercepted by this exception type or not.",
          "title": "On When",
          "required": false,
          "deprecated": false
        },
        "handled": {
          "kind": "expression",
          "type": "object",
          "description": "Sets whether the exchange should be marked as handled or not.",
          "title": "Handled",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "doFinally": {
      "type": "object",
      "title": "Do Finally",
      "group": "error",
      "icon": "generic24.png",
      "description": "Path traversed when a try catch finally block exits",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "doTry": {
      "type": "object",
      "title": "Do Try",
      "group": "error",
      "icon": "generic24.png",
      "description": "Marks the beginning of a try catch finally block",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "dynamicRouter": {
      "type": "object",
      "title": "Dynamic Router",
      "group": "eip,endpoint,routing",
      "icon": "dynamicRouter24.png",
      "description": "Routes messages based on dynamic rules",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to call that returns the endpoint(s) to route to in the dynamic routing. Important: The expression will be called in a while loop fashion until the expression returns null which means the dynamic router is finished.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "uriDelimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "Sets the uri delimiter to use",
          "title": "Uri Delimiter",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoints": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoints",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "endpoint": {
      "type": "object",
      "title": "Endpoint",
      "group": "spring,configuration,endpoint",
      "icon": "generic24.png",
      "description": "Camel endpoint configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "singleton": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Not in use",
          "title": "Singleton",
          "required": false,
          "deprecated": true
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the URI to use to resolve the endpoint. Notice that additional options can be configured using a series of property.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the exchange pattern of the endpoint",
          "title": "Pattern",
          "required": false,
          "deprecated": true
        },
        "properties": {
          "kind": "element",
          "type": "array",
          "description": "To configure additional endpoint options using a XML style which is similar as configuring Spring or Blueprint beans.",
          "title": "Properties",
          "required": true,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "enrich": {
      "type": "object",
      "title": "Enrich",
      "group": "eip,transformation",
      "icon": "enrich24.png",
      "description": "Enriches a message with data from a secondary resource",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression that computes the endpoint uri to use as the resource endpoint to enrich from",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "aggregateOnException": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.",
          "title": "Aggregate On Exception",
          "required": false,
          "deprecated": false
        },
        "shareUnitOfWork": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Shares the org.apache.camel.spi.UnitOfWork with the parent and the resource exchange. Enrich will by default not share unit of work between the parent exchange and the resource exchange. This means the resource exchange has its own individual unit of work.",
          "title": "Share Unit Of Work",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producer when uris are reused.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoint",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "errorHandler": {
      "type": "object",
      "title": "Error Handler",
      "group": "spring,configuration,error",
      "icon": "generic24.png",
      "description": "Error handler settings",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "type": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "DefaultErrorHandler",
          "enum": [ "DeadLetterChannel", "DefaultErrorHandler", "LoggingErrorHandler", "NoErrorHandler", "TransactionErrorHandler" ],
          "description": "The type of the error handler",
          "title": "Type",
          "required": true,
          "deprecated": false
        },
        "deadLetterUri": {
          "kind": "attribute",
          "type": "string",
          "description": "The dead letter endpoint uri for the Dead Letter error handler.",
          "title": "Dead Letter Uri",
          "required": false,
          "deprecated": false
        },
        "deadLetterHandleNewException": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the message to the dead letter endpoint. The default value is true which means any such kind of exception is handled and ignored. Set this to false to let the exception be propagated back on the org.apache.camel.Exchange. This can be used in situations where you use transactions and want to use Camel's dead letter channel to deal with exceptions during routing but if the dead letter channel itself fails because of a new exception being thrown then by setting this to false the new exceptions is propagated back and set on the org.apache.camel.Exchange which allows the transaction to detect the exception and rollback.",
          "title": "Dead Letter Handle New Exception",
          "required": false,
          "deprecated": false
        },
        "level": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "ERROR",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Logging level to use when using the logging error handler type.",
          "title": "Level",
          "required": false,
          "deprecated": false
        },
        "rollbackLoggingLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "WARN",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level to use for logging transactional rollback. This option is default WARN.",
          "title": "Rollback Logging Level",
          "required": false,
          "deprecated": false
        },
        "logName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of the logger to use for the logging error handler",
          "title": "Log Name",
          "required": false,
          "deprecated": false
        },
        "useOriginalMessage": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will use the original input message when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN body we use the original IN body instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN body is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. By default this feature is off.",
          "title": "Use Original Message",
          "required": false,
          "deprecated": false
        },
        "transactionTemplateRef": {
          "kind": "attribute",
          "type": "string",
          "description": "References to the org.springframework.transaction.support.TransactionTemplate to use with the transaction error handler.",
          "title": "Transaction Template Ref",
          "required": false,
          "deprecated": false
        },
        "transactionManagerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "References to the org.springframework.transaction.PlatformTransactionManager to use with the transaction error handler.",
          "title": "Transaction Manager Ref",
          "required": false,
          "deprecated": false
        },
        "onRedeliveryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "title": "On Redelivery Ref",
          "required": false,
          "deprecated": false
        },
        "onExceptionOccurredRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "title": "On Exception Occurred Ref",
          "required": false,
          "deprecated": false
        },
        "onPrepareFailureRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.",
          "title": "On Prepare Failure Ref",
          "required": false,
          "deprecated": false
        },
        "retryWhileRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to an retry while expression. Will continue retrying until expression evaluates to false.",
          "title": "Retry While Ref",
          "required": false,
          "deprecated": false
        },
        "redeliveryPolicyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.",
          "title": "Redelivery Policy Ref",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a thread pool to be used by the error handler",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "redeliveryPolicy": {
          "kind": "element",
          "type": "object",
          "description": "Sets the redelivery settings",
          "title": "Redelivery Policy",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "etcdConfiguration": {
      "type": "object",
      "title": "Etcd Configuration",
      "group": "eip,routing,remote",
      "icon": "generic24.png",
      "description": "Etcd remote service call configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "uris": {
          "kind": "attribute",
          "type": "string",
          "description": "The URIs the client can connect to.",
          "title": "Uris",
          "required": false,
          "deprecated": false
        },
        "userName": {
          "kind": "attribute",
          "type": "string",
          "description": "The user name to use for basic authentication.",
          "title": "User Name",
          "required": false,
          "deprecated": false
        },
        "password": {
          "kind": "attribute",
          "type": "string",
          "description": "The password to use for basic authentication.",
          "title": "Password",
          "required": false,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "description": "To set the maximum time an action could take to complete.",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "servicePath": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "/services/",
          "description": "The path to look for for service discovery",
          "title": "Service Path",
          "required": false,
          "deprecated": false
        },
        "component": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "http",
          "description": "Sets the default Camel component to use for calling the remote service. By default the http component is used. You can configure this to use netty4-http jetty restlet or some other components of choice. If the service is not HTTP protocol you can use other components such as mqtt jms amqp etc. If the service call has been configured using an uri then the component from the uri is used instead of this default component.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "clientProperty": {
          "kind": "element",
          "type": "array",
          "description": "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using ribbon then the client properties are define in com.netflix.client.config.CommonClientConfigKey.",
          "title": "Client Property",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "export": {
      "type": "object",
      "title": "Export",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Used for export a service using Spring Remoting to hide the network call using an interface.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Camel endpoint uri to use a remote transport when calling the service",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "serviceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the service name to lookup in the registry.",
          "title": "Service Ref",
          "required": false,
          "deprecated": false
        },
        "serviceInterface": {
          "kind": "attribute",
          "type": "string",
          "description": "Java interfaces to use as facade for the service to be exported",
          "title": "Service Interface",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "The id of the CamelContext to use if there is multiple CamelContext in the same JVM.",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "failover": {
      "type": "object",
      "title": "Failover",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Failover load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "exception": {
          "kind": "element",
          "type": "array",
          "description": "A list of class names for specific exceptions to monitor. If no exceptions is configured then all exceptions is monitored",
          "title": "Exception",
          "required": false,
          "deprecated": false
        },
        "roundRobin": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the failover load balancer should operate in round robin mode or not. If not then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If round robin is enabled then it keeps state and will continue with the next endpoint in a round robin fashion. You can also enable sticky mode together with round robin if so then it will pick the last known good endpoint to use when starting the load balancing (instead of using the next when starting).",
          "title": "Round Robin",
          "required": false,
          "deprecated": false
        },
        "sticky": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the failover load balancer should operate in sticky mode or not. If not then it will always start from the first endpoint when a new message is to be processed. In other words it restart from the top for every message. If sticky is enabled then it keeps state and will continue with the last known good endpoint. You can also enable sticky mode together with round robin if so then it will pick the last known good endpoint to use when starting the load balancing (instead of using the next when starting).",
          "title": "Sticky",
          "required": false,
          "deprecated": false
        },
        "maximumFailoverAttempts": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "-1",
          "description": "A value to indicate after X failover attempts we should exhaust (give up). Use -1 to indicate never give up and continuously try to failover. Use 0 to never failover. And use e.g. 3 to failover at most 3 times before giving up. his option can be used whether or not roundRobin is enabled or not.",
          "title": "Maximum Failover Attempts",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "filter": {
      "type": "object",
      "title": "Filter",
      "group": "eip,routing",
      "icon": "filter24.png",
      "description": "Filter out messages based using a predicate",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to determine if the message should be filtered or not. If the expression returns an empty value or false then the message is filtered (dropped) otherwise the message is continued being routed.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "fluentTemplate": {
      "type": "object",
      "title": "Fluent Template",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Configures a org.apache.camel.FluentProducerTemplate",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "defaultEndpoint": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the default endpoint URI used by default for sending message exchanges",
          "title": "Default Endpoint",
          "required": false,
          "deprecated": false
        },
        "maximumCacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets a custom maximum cache size to use in the backing cache pools.",
          "title": "Maximum Cache Size",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "from": {
      "type": "object",
      "title": "From",
      "group": "eip,endpoint,routing",
      "icon": "endpoint24.png",
      "description": "Act as a message source as input to a route",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the URI of the endpoint to use",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the name of the endpoint within the registry (such as the Spring ApplicationContext or JNDI) to use",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "hystrix": {
      "type": "object",
      "title": "Hystrix",
      "group": "eip,routing,circuitbreaker",
      "icon": "generic24.png",
      "description": "Hystrix Circuit Breaker EIP",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "hystrixConfiguration": {
          "kind": "element",
          "type": "object",
          "description": "Configures the Hystrix EIP Use end when configuration is complete to return back to the Hystrix EIP.",
          "title": "Hystrix Configuration",
          "required": false,
          "deprecated": false
        },
        "hystrixConfigurationRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a Hystrix configuration to use for configuring the Hystrix EIP.",
          "title": "Hystrix Configuration Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "hystrixConfiguration": {
      "type": "object",
      "title": "Hystrix Configuration",
      "group": "eip,routing,circuitbreaker",
      "icon": "generic24.png",
      "description": "Hystrix Circuit Breaker EIP configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "groupKey": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "CamelHystrix",
          "description": "Sets the group key to use. The default value is CamelHystrix.",
          "title": "Group Key",
          "required": false,
          "deprecated": false
        },
        "threadPoolKey": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "CamelHystrix",
          "description": "Sets the thread pool key to use. Will by default use the same value as groupKey has been configured to use.",
          "title": "Thread Pool Key",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to use a HystrixCircuitBreaker or not. If false no circuit-breaker logic will be used and all requests permitted. This is similar in effect to circuitBreakerForceClosed() except that continues tracking metrics and knowing whether it should be open/closed this property results in not even instantiating a circuit-breaker.",
          "title": "Circuit Breaker Enabled",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerErrorThresholdPercentage": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "50",
          "description": "Error percentage threshold (as whole number such as 50) at which point the circuit breaker will trip open and reject requests. It will stay tripped for the duration defined in circuitBreakerSleepWindowInMilliseconds; The error percentage this is compared against comes from HystrixCommandMetrics.getHealthCounts().",
          "title": "Circuit Breaker Error Threshold Percentage",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerForceClosed": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "If true the HystrixCircuitBreakerallowRequest() will always return true to allow requests regardless of the error percentage from HystrixCommandMetrics.getHealthCounts(). The circuitBreakerForceOpen() property takes precedence so if it set to true this property does nothing.",
          "title": "Circuit Breaker Force Closed",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerForceOpen": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If true the HystrixCircuitBreaker.allowRequest() will always return false causing the circuit to be open (tripped) and reject all requests. This property takes precedence over circuitBreakerForceClosed();",
          "title": "Circuit Breaker Force Open",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerRequestVolumeThreshold": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "20",
          "description": "Minimum number of requests in the metricsRollingStatisticalWindowInMilliseconds() that must exist before the HystrixCircuitBreaker will trip. If below this number the circuit will not trip regardless of error percentage.",
          "title": "Circuit Breaker Request Volume Threshold",
          "required": false,
          "deprecated": false
        },
        "circuitBreakerSleepWindowInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "5000",
          "description": "The time in milliseconds after a HystrixCircuitBreaker trips open that it should wait before trying requests again.",
          "title": "Circuit Breaker Sleep Window In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "executionIsolationSemaphoreMaxConcurrentRequests": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "20",
          "description": "Number of concurrent requests permitted to HystrixCommand.run(). Requests beyond the concurrent limit will be rejected. Applicable only when executionIsolationStrategy == SEMAPHORE.",
          "title": "Execution Isolation Semaphore Max Concurrent Requests",
          "required": false,
          "deprecated": false
        },
        "executionIsolationStrategy": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "THREAD",
          "description": "What isolation strategy HystrixCommand.run() will be executed with. If THREAD then it will be executed on a separate thread and concurrent requests limited by the number of threads in the thread-pool. If SEMAPHORE then it will be executed on the calling thread and concurrent requests limited by the semaphore count.",
          "title": "Execution Isolation Strategy",
          "required": false,
          "deprecated": false
        },
        "executionIsolationThreadInterruptOnTimeout": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether the execution thread should attempt an interrupt (using link Futurecancel) when a thread times out. Applicable only when executionIsolationStrategy() == THREAD.",
          "title": "Execution Isolation Thread Interrupt On Timeout",
          "required": false,
          "deprecated": false
        },
        "executionTimeoutInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1000",
          "description": "Time in milliseconds at which point the command will timeout and halt execution. If link executionIsolationThreadInterruptOnTimeout == true and the command is thread-isolated the executing thread will be interrupted. If the command is semaphore-isolated and a HystrixObservableCommand that command will get unsubscribed.",
          "title": "Execution Timeout In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "executionTimeoutEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether the timeout mechanism is enabled for this command",
          "title": "Execution Timeout Enabled",
          "required": false,
          "deprecated": false
        },
        "fallbackIsolationSemaphoreMaxConcurrentRequests": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "Number of concurrent requests permitted to HystrixCommand.getFallback(). Requests beyond the concurrent limit will fail-fast and not attempt retrieving a fallback.",
          "title": "Fallback Isolation Semaphore Max Concurrent Requests",
          "required": false,
          "deprecated": false
        },
        "fallbackEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether HystrixCommand.getFallback() should be attempted when failure occurs.",
          "title": "Fallback Enabled",
          "required": false,
          "deprecated": false
        },
        "metricsHealthSnapshotIntervalInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "500",
          "description": "Time in milliseconds to wait between allowing health snapshots to be taken that calculate success and error percentages and affect HystrixCircuitBreaker.isOpen() status. On high-volume circuits the continual calculation of error percentage can become CPU intensive thus this controls how often it is calculated.",
          "title": "Metrics Health Snapshot Interval In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "metricsRollingPercentileBucketSize": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "Maximum number of values stored in each bucket of the rolling percentile. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Percentile Bucket Size",
          "required": false,
          "deprecated": false
        },
        "metricsRollingPercentileEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether percentile metrics should be captured using HystrixRollingPercentile inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Percentile Enabled",
          "required": false,
          "deprecated": false
        },
        "metricsRollingPercentileWindowInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "false",
          "description": "Duration of percentile rolling window in milliseconds. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Percentile Window In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "metricsRollingPercentileWindowBuckets": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "6",
          "description": "Number of buckets the rolling percentile window is broken into. This is passed into HystrixRollingPercentile inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Percentile Window Buckets",
          "required": false,
          "deprecated": false
        },
        "metricsRollingStatisticalWindowInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10000",
          "description": "Duration of statistical rolling window in milliseconds. This is passed into HystrixRollingNumber inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Statistical Window In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "metricsRollingStatisticalWindowBuckets": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "Number of buckets the rolling statistical window is broken into. This is passed into HystrixRollingNumber inside HystrixCommandMetrics.",
          "title": "Metrics Rolling Statistical Window Buckets",
          "required": false,
          "deprecated": false
        },
        "requestLogEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether HystrixCommand execution and events should be logged to HystrixRequestLog.",
          "title": "Request Log Enabled",
          "required": false,
          "deprecated": false
        },
        "corePoolSize": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "Core thread-pool size that gets passed to link java.util.concurrent.ThreadPoolExecutorsetCorePoolSize(int)",
          "title": "Core Pool Size",
          "required": false,
          "deprecated": false
        },
        "keepAliveTime": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1",
          "description": "Keep-alive time in minutes that gets passed to link ThreadPoolExecutorsetKeepAliveTime(long TimeUnit)",
          "title": "Keep Alive Time",
          "required": false,
          "deprecated": false
        },
        "maxQueueSize": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "-1",
          "description": "Max queue size that gets passed to BlockingQueue in HystrixConcurrencyStrategy.getBlockingQueue(int) This should only affect the instantiation of a threadpool - it is not eliglible to change a queue size on the fly. For that use queueSizeRejectionThreshold().",
          "title": "Max Queue Size",
          "required": false,
          "deprecated": false
        },
        "queueSizeRejectionThreshold": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "5",
          "description": "Queue size rejection threshold is an artificial max size at which rejections will occur even if link maxQueueSize has not been reached. This is done because the link maxQueueSize of a BlockingQueue can not be dynamically changed and we want to support dynamically changing the queue size that affects rejections. This is used by HystrixCommand when queuing a thread for execution.",
          "title": "Queue Size Rejection Threshold",
          "required": false,
          "deprecated": false
        },
        "threadPoolRollingNumberStatisticalWindowInMilliseconds": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10000",
          "description": "Duration of statistical rolling window in milliseconds. This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.",
          "title": "Thread Pool Rolling Number Statistical Window In Milliseconds",
          "required": false,
          "deprecated": false
        },
        "threadPoolRollingNumberStatisticalWindowBuckets": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "10",
          "description": "Number of buckets the rolling statistical window is broken into. This is passed into HystrixRollingNumber inside each HystrixThreadPoolMetrics instance.",
          "title": "Thread Pool Rolling Number Statistical Window Buckets",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "idempotentConsumer": {
      "type": "object",
      "title": "Idempotent Consumer",
      "group": "eip,routing",
      "icon": "idempotentConsumer24.png",
      "description": "Filters out duplicate messages",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression used to calculate the correlation key to use for duplicate check. The Exchange which has the same correlation key is regarded as a duplicate and will be rejected.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "messageIdRepositoryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference name of the message id repository",
          "title": "Message Id Repository Ref",
          "required": true,
          "deprecated": false
        },
        "eager": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Sets whether to eagerly add the key to the idempotent repository or wait until the exchange is complete. Eager is default enabled.",
          "title": "Eager",
          "required": false,
          "deprecated": false
        },
        "completionEager": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether to complete the idempotent consumer eager or when the exchange is done. If this option is true to complete eager then the idempotent consumer will trigger its completion when the exchange reached the end of the block of the idempotent consumer pattern. So if the exchange is continued routed after the block ends then whatever happens there does not affect the state. If this option is false (default) to not complete eager then the idempotent consumer will complete when the exchange is done being routed. So if the exchange is continued routed after the block ends then whatever happens there also affect the state. For example if the exchange failed due to an exception then the state of the idempotent consumer will be a rollback.",
          "title": "Completion Eager",
          "required": false,
          "deprecated": false
        },
        "skipDuplicate": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Sets whether to skip duplicates or not. The default behavior is to skip duplicates. A duplicate message would have the Exchange property link org.apache.camel.ExchangeDUPLICATE_MESSAGE set to a link BooleanTRUE value. A none duplicate message will not have this property set.",
          "title": "Skip Duplicate",
          "required": false,
          "deprecated": false
        },
        "removeOnFailure": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Sets whether to remove or keep the key on failure. The default behavior is to remove the key on failure.",
          "title": "Remove On Failure",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "inOnly": {
      "type": "object",
      "title": "In Only",
      "group": "eip,endpoint,routing",
      "icon": "eventMessage24.png",
      "description": "Marks the exchange pattern for the route to one way",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the uri of the endpoint to send to.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference of the endpoint to send to.",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "inOut": {
      "type": "object",
      "title": "In Out",
      "group": "eip,endpoint,routing",
      "icon": "requestReply24.png",
      "description": "Marks the exchange pattern for the route to request/reply",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the uri of the endpoint to send to.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference of the endpoint to send to.",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "intercept": {
      "type": "object",
      "title": "Intercept",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Intercepts a message at each step in the route",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "interceptFrom": {
      "type": "object",
      "title": "Intercept From",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Intercepts incoming messages",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Intercept incoming messages from the uri or uri pattern. If this option is not configured then all incoming messages is intercepted.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "interceptSendToEndpoint": {
      "type": "object",
      "title": "Intercept Send To Endpoint",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Intercepts messages being sent to an endpoint",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Intercept sending to the uri or uri pattern.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "skipSendToOriginalEndpoint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If set to true then the message is not sent to the original endpoint. By default (false) the message is both intercepted and then sent to the original endpoint.",
          "title": "Skip Send To Original Endpoint",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jmxAgent": {
      "type": "object",
      "title": "Jmx Agent",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "JMX configuration.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "disabled": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Disable JMI (default false)",
          "title": "Disabled",
          "required": false,
          "deprecated": false
        },
        "onlyRegisterProcessorWithCustomId": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Only register processor if a custom id was defined for it.",
          "title": "Only Register Processor With Custom Id",
          "required": false,
          "deprecated": false
        },
        "registryPort": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "1099",
          "description": "RMI connector registry port (default 1099)",
          "title": "Registry Port",
          "required": false,
          "deprecated": false
        },
        "connectorPort": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "-1",
          "description": "RMI connector server port (default -1 not used)",
          "title": "Connector Port",
          "required": false,
          "deprecated": false
        },
        "mbeanServerDefaultDomain": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "org.apache.camel",
          "description": "MBean server default domain name (default org.apache.camel)",
          "title": "Mbean Server Default Domain",
          "required": false,
          "deprecated": false
        },
        "mbeanObjectDomainName": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "org.apache.camel",
          "description": "MBean object domain name (default org.apache.camel)",
          "title": "Mbean Object Domain Name",
          "required": false,
          "deprecated": false
        },
        "serviceUrlPath": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "/jmxrmi",
          "description": "JMX Service URL path (default /jmxrmi)",
          "title": "Service Url Path",
          "required": false,
          "deprecated": false
        },
        "createConnector": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether the agent should be created",
          "title": "Create Connector",
          "required": false,
          "deprecated": false
        },
        "usePlatformMBeanServer": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "A flag that indicates whether the platform mbean server should be used",
          "title": "Use Platform M Bean Server",
          "required": false,
          "deprecated": false
        },
        "registerAlways": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether to register mbeans always",
          "title": "Register Always",
          "required": false,
          "deprecated": false
        },
        "registerNewRoutes": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether to register mbeans when starting new routes",
          "title": "Register New Routes",
          "required": false,
          "deprecated": false
        },
        "statisticsLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "Default",
          "description": "Level of granularity for performance statistics enabled",
          "title": "Statistics Level",
          "required": false,
          "deprecated": false
        },
        "loadStatisticsEnabled": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether Load statistics is enabled",
          "title": "Load Statistics Enabled",
          "required": false,
          "deprecated": false
        },
        "endpointRuntimeStatisticsEnabled": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "A flag that indicates whether endpoint runtime statistics is enabled",
          "title": "Endpoint Runtime Statistics Enabled",
          "required": false,
          "deprecated": false
        },
        "includeHostName": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether to include hostname in JMX MBean names.",
          "title": "Include Host Name",
          "required": false,
          "deprecated": false
        },
        "useHostIPAddress": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "A flag that indicates whether to use hostname or IP Address in the service url.",
          "title": "Use Host I P Address",
          "required": false,
          "deprecated": false
        },
        "mask": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "A flag that indicates whether to remove detected sensitive information (such as passwords) from MBean names and attributes.",
          "title": "Mask",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "kubernetesConfiguration": {
      "type": "object",
      "title": "Kubernetes Configuration",
      "group": "eip,routing,remote",
      "icon": "generic24.png",
      "description": "Kubernetes remote service call configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "lookup": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "environment",
          "description": "How to perform service lookup. Possible values: client dns environment. When using client then the client queries the kubernetes master to obtain a list of active pods that provides the service and then random (or round robin) select a pod. When using dns the service name is resolved as name.namespace.service.dnsDomain. When using environment then environment variables are used to lookup the service. By default environment is used.",
          "title": "Lookup",
          "required": false,
          "deprecated": false
        },
        "dnsDomain": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the DNS domain to use for DNS lookup.",
          "title": "Dns Domain",
          "required": false,
          "deprecated": false
        },
        "namespace": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the namespace to use. Will by default use namespace from the ENV variable KUBERNETES_MASTER.",
          "title": "Namespace",
          "required": false,
          "deprecated": false
        },
        "apiVersion": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the API version when using client lookup",
          "title": "Api Version",
          "required": false,
          "deprecated": false
        },
        "masterUrl": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the URL to the master when using client lookup",
          "title": "Master Url",
          "required": false,
          "deprecated": false
        },
        "username": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the username for authentication when using client lookup",
          "title": "Username",
          "required": false,
          "deprecated": false
        },
        "password": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the password for authentication when using client lookup",
          "title": "Password",
          "required": false,
          "deprecated": false
        },
        "oauthToken": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the OAUTH token for authentication (instead of username/password) when using client lookup",
          "title": "Oauth Token",
          "required": false,
          "deprecated": false
        },
        "caCertData": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Certificate Authority data when using client lookup",
          "title": "Ca Cert Data",
          "required": false,
          "deprecated": false
        },
        "caCertFile": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Certificate Authority data that are loaded from the file when using client lookup",
          "title": "Ca Cert File",
          "required": false,
          "deprecated": false
        },
        "clientCertData": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Certificate data when using client lookup",
          "title": "Client Cert Data",
          "required": false,
          "deprecated": false
        },
        "clientCertFile": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Certificate data that are loaded from the file when using client lookup",
          "title": "Client Cert File",
          "required": false,
          "deprecated": false
        },
        "clientKeyAlgo": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Keystore algorithm such as RSA when using client lookup",
          "title": "Client Key Algo",
          "required": false,
          "deprecated": false
        },
        "clientKeyData": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Keystore data when using client lookup",
          "title": "Client Key Data",
          "required": false,
          "deprecated": false
        },
        "clientKeyFile": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Keystore data that are loaded from the file when using client lookup",
          "title": "Client Key File",
          "required": false,
          "deprecated": false
        },
        "clientKeyPassphrase": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Client Keystore passphrase when using client lookup",
          "title": "Client Key Passphrase",
          "required": false,
          "deprecated": false
        },
        "trustCerts": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether to turn on trust certificate check when using client lookup",
          "title": "Trust Certs",
          "required": false,
          "deprecated": false
        },
        "component": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "http",
          "description": "Sets the default Camel component to use for calling the remote service. By default the http component is used. You can configure this to use netty4-http jetty restlet or some other components of choice. If the service is not HTTP protocol you can use other components such as mqtt jms amqp etc. If the service call has been configured using an uri then the component from the uri is used instead of this default component.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "clientProperty": {
          "kind": "element",
          "type": "array",
          "description": "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using ribbon then the client properties are define in com.netflix.client.config.CommonClientConfigKey.",
          "title": "Client Property",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "loadBalance": {
      "type": "object",
      "title": "Load Balance",
      "group": "eip,routing",
      "icon": "loadBalance24.png",
      "description": "Balances message processing among a number of nodes",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "loadBalancerType": {
          "kind": "element",
          "type": "object",
          "description": "The load balancer to be used",
          "title": "Load Balancer Type",
          "required": true,
          "deprecated": false
        },
        "inheritErrorHandler": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether or not to inherit the configured error handler. The default value is true. You can use this to disable using the inherited error handler for a given DSL such as a load balancer where you want to use a custom error handler strategy.",
          "title": "Inherit Error Handler",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "log": {
      "type": "object",
      "title": "Log",
      "group": "configuration",
      "icon": "log24.png",
      "description": "Logs the defined message to the logger",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "message": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the log message (uses simple language)",
          "title": "Message",
          "required": true,
          "deprecated": false
        },
        "loggingLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "INFO",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level. The default value is INFO",
          "title": "Logging Level",
          "required": false,
          "deprecated": false
        },
        "logName": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the name of the logger",
          "title": "Log Name",
          "required": false,
          "deprecated": false
        },
        "marker": {
          "kind": "attribute",
          "type": "string",
          "description": "To use slf4j marker",
          "title": "Marker",
          "required": false,
          "deprecated": false
        },
        "loggerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "To refer to a custom logger instance to lookup from the registry.",
          "title": "Logger Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "loop": {
      "type": "object",
      "title": "Loop",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Processes a message multiple times",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to define how many times we should loop. Notice the expression is only evaluated once and should return a number as how many times to loop. A value of zero or negative means no looping. The loop is like a for-loop fashion if you want a while loop then the dynamic router may be a better choice.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "copy": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If the copy attribute is true a copy of the input Exchange is used for each iteration. That means each iteration will start from a copy of the same message. By default loop will loop the same exchange all over so each iteration may have different message content.",
          "title": "Copy",
          "required": false,
          "deprecated": false
        },
        "doWhile": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables the while loop that loops until the predicate evaluates to false or null.",
          "title": "Do While",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "marshal": {
      "type": "object",
      "title": "Marshal",
      "group": "eip,transformation",
      "icon": "marshal24.png",
      "description": "Marshals data into a specified format for transmission over a transport or component",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "dataFormatType": {
          "kind": "element",
          "type": "object",
          "description": "The data format to be used",
          "title": "Data Format Type",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "To refer to a custom data format to use as marshaller",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "multicast": {
      "type": "object",
      "title": "Multicast",
      "group": "eip,routing",
      "icon": "multicast24.png",
      "description": "Routes the same message to multiple paths either sequentially or in parallel.",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "parallelProcessing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then sending messages to the multicasts occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the multicasts which happens concurrently.",
          "title": "Parallel Processing",
          "required": false,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to an AggregationStrategy to be used to assemble the replies from the multicasts into a single outgoing message from the Multicast. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "streaming": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the multicast.",
          "title": "Streaming",
          "required": false,
          "deprecated": false
        },
        "stopOnException": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the multicast will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end",
          "title": "Stop On Exception",
          "required": false,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "0",
          "description": "Sets a total timeout specified in millis when using parallel processing. If the Multicast hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Multicast breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "onPrepareRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.",
          "title": "On Prepare Ref",
          "required": false,
          "deprecated": false
        },
        "shareUnitOfWork": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Multicast will by default not share unit of work between the parent exchange and each multicasted exchange. This means each sub exchange has its own individual unit of work.",
          "title": "Share Unit Of Work",
          "required": false,
          "deprecated": false
        },
        "parallelAggregate": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.",
          "title": "Parallel Aggregate",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "onCompletion": {
      "type": "object",
      "title": "On Completion",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Route to be executed when normal route processing completes",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "mode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "AfterConsumer",
          "enum": [ "AfterConsumer", "BeforeConsumer" ],
          "description": "Sets the on completion mode. The default value is AfterConsumer",
          "title": "Mode",
          "required": false,
          "deprecated": false
        },
        "onCompleteOnly": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will only synchronize when the org.apache.camel.Exchange completed successfully (no errors).",
          "title": "On Complete Only",
          "required": false,
          "deprecated": false
        },
        "onFailureOnly": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will only synchronize when the org.apache.camel.Exchange ended with failure (exception or FAULT message).",
          "title": "On Failure Only",
          "required": false,
          "deprecated": false
        },
        "onWhen": {
          "kind": "element",
          "type": "object",
          "description": "Sets an additional predicate that should be true before the onCompletion is triggered. To be used for fine grained controlling whether a completion callback should be invoked or not",
          "title": "On When",
          "required": false,
          "deprecated": false
        },
        "parallelProcessing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then the on completion process will run asynchronously by a separate thread from a thread pool. By default this is false meaning the on completion process will run synchronously using the same caller thread as from the route.",
          "title": "Parallel Processing",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "useOriginalMessage": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will use the original input body when an org.apache.camel.Exchange for this on completion. By default this feature is off.",
          "title": "Use Original Message",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "onException": {
      "type": "object",
      "title": "On Exception",
      "group": "error",
      "icon": "generic24.png",
      "description": "Route to be executed when an exception is thrown",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "exception": {
          "kind": "element",
          "type": "array",
          "description": "A set of exceptions to react upon.",
          "title": "Exception",
          "required": true,
          "deprecated": false
        },
        "onWhen": {
          "kind": "element",
          "type": "object",
          "description": "Sets an additional predicate that should be true before the onException is triggered. To be used for fine grained controlling whether a thrown exception should be intercepted by this exception type or not.",
          "title": "On When",
          "required": false,
          "deprecated": false
        },
        "retryWhile": {
          "kind": "expression",
          "type": "object",
          "description": "Sets the retry while predicate. Will continue retrying until predicate returns false.",
          "title": "Retry While",
          "required": false,
          "deprecated": false
        },
        "redeliveryPolicy": {
          "kind": "element",
          "type": "object",
          "description": "Set the RedeliveryPolicy to be used.",
          "title": "Redelivery Policy",
          "required": false,
          "deprecated": false
        },
        "redeliveryPolicyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a RedeliveryPolicy to lookup in the org.apache.camel.spi.Registry to be used.",
          "title": "Redelivery Policy Ref",
          "required": false,
          "deprecated": false
        },
        "handled": {
          "kind": "expression",
          "type": "object",
          "description": "Sets whether the exchange should be marked as handled or not.",
          "title": "Handled",
          "required": false,
          "deprecated": false
        },
        "continued": {
          "kind": "expression",
          "type": "object",
          "description": "Sets whether the exchange should handle and continue routing from the point of failure. If this option is enabled then its considered handled as well.",
          "title": "Continued",
          "required": false,
          "deprecated": false
        },
        "onRedeliveryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "title": "On Redelivery Ref",
          "required": false,
          "deprecated": false
        },
        "onExceptionOccurredRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "title": "On Exception Occurred Ref",
          "required": false,
          "deprecated": false
        },
        "useOriginalMessage": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will use the original input message when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN body we use the original IN body instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN body. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN body is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. By default this feature is off.",
          "title": "Use Original Message",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "onFallback": {
      "type": "object",
      "title": "On Fallback",
      "group": "eip,routing,circuitbreaker",
      "icon": "generic24.png",
      "description": "Route to be executed when Hystrix EIP executes fallback",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "fallbackViaNetwork": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the fallback goes over the network. If the fallback will go over the network it is another possible point of failure and so it also needs to be wrapped by a HystrixCommand. It is important to execute the fallback command on a separate thread-pool otherwise if the main command were to become latent and fill the thread-pool this would prevent the fallback from running if the two commands share the same pool.",
          "title": "Fallback Via Network",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "optimisticLockRetryPolicy": {
      "type": "object",
      "title": "Optimistic Lock Retry Policy",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To configure optimistic locking",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "maximumRetries": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum number of retries",
          "title": "Maximum Retries",
          "required": false,
          "deprecated": false
        },
        "retryDelay": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "50",
          "description": "Sets the delay in millis between retries",
          "title": "Retry Delay",
          "required": false,
          "deprecated": false
        },
        "maximumRetryDelay": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1000",
          "description": "Sets the upper value of retry in millis between retries when using exponential or random backoff",
          "title": "Maximum Retry Delay",
          "required": false,
          "deprecated": false
        },
        "exponentialBackOff": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Enable exponential backoff",
          "title": "Exponential Back Off",
          "required": false,
          "deprecated": false
        },
        "randomBackOff": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables random backoff",
          "title": "Random Back Off",
          "required": false,
          "deprecated": false
        }
      }
    },
    "otherwise": {
      "type": "object",
      "title": "Otherwise",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Route to be executed when all other choices evaluate to false",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "packageScan": {
      "type": "object",
      "title": "Package Scan",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Scans for Java org.apache.camel.builder.RouteBuilder classes in java packages",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "package": {
          "kind": "element",
          "type": "array",
          "description": "Sets the java package names to use for scanning for route builder classes",
          "title": "Package",
          "required": true,
          "deprecated": false
        },
        "excludes": {
          "kind": "element",
          "type": "array",
          "description": "Exclude finding route builder from these java package names.",
          "title": "Excludes",
          "required": false,
          "deprecated": false
        },
        "includes": {
          "kind": "element",
          "type": "array",
          "description": "Include finding route builder from these java package names.",
          "title": "Includes",
          "required": false,
          "deprecated": false
        }
      }
    },
    "pipeline": {
      "type": "object",
      "title": "Pipeline",
      "group": "eip,routing",
      "icon": "pipeline24.png",
      "description": "Routes the message to a sequence of processors.",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "policy": {
      "type": "object",
      "title": "Policy",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Defines a policy the route will use",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to use for lookup the policy in the registry.",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "pollEnrich": {
      "type": "object",
      "title": "Poll Enrich",
      "group": "eip,transformation",
      "icon": "pollEnrich24.png",
      "description": "Enriches messages with data polled from a secondary resource",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression that computes the endpoint uri to use as the resource endpoint to enrich from",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "-1",
          "description": "Timeout in millis when polling from the external service. The timeout has influence about the poll enrich behavior. It basically operations in three different modes: negative value - Waits until a message is available and then returns it. Warning that this method could block indefinitely if no messages are available. 0 - Attempts to receive a message exchange immediately without waiting and returning null if a message exchange is not available yet. positive value - Attempts to receive a message exchange waiting up to the given timeout to expire if a message is not yet available. Returns null if timed out The default value is -1 and therefore the method could block indefinitely and therefore its recommended to use a timeout value",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to an AggregationStrategy to be used to merge the reply from the external service into a single outgoing message. By default Camel will use the reply from the external service as outgoing message.",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "aggregateOnException": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was an exception thrown while trying to retrieve the data to enrich from the resource. Setting this option to true allows end users to control what to do if there was an exception in the aggregate method. For example to suppress the exception or set a custom message body etc.",
          "title": "Aggregate On Exception",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ConsumerCache which is used to cache and reuse consumers when uris are reused.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoint",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "process": {
      "type": "object",
      "title": "Process",
      "group": "eip,endpoint",
      "icon": "process24.png",
      "description": "Calls a Camel processor.",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the Processor to lookup in the registry to use.",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "properties": {
      "type": "object",
      "title": "Properties",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "A series of key value pair",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "property": {
          "kind": "element",
          "type": "array",
          "description": "A series of properties as key value pairs",
          "title": "Property",
          "required": false,
          "deprecated": false
        }
      }
    },
    "propertiesFunction": {
      "type": "object",
      "title": "Properties Function",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Function to use with properties placeholder",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the custom properties function to lookup in the registry",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "property": {
      "type": "object",
      "title": "Property",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "A key value pair",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "key": {
          "kind": "attribute",
          "type": "string",
          "description": "Property key",
          "title": "Key",
          "required": true,
          "deprecated": false
        },
        "value": {
          "kind": "attribute",
          "type": "string",
          "description": "Property value",
          "title": "Value",
          "required": true,
          "deprecated": false
        }
      }
    },
    "propertyPlaceholder": {
      "type": "object",
      "title": "Property Placeholder",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Properties placeholder",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "location": {
          "kind": "attribute",
          "type": "string",
          "description": "A list of locations to load properties. You can use comma to separate multiple locations. This option will override any default locations and only use the locations from this option.",
          "title": "Location",
          "required": true,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "Encoding to use when loading properties file from the file system or classpath. If no encoding has been set then the properties files is loaded using ISO-8859-1 encoding (latin-1) as documented by link java.util.Propertiesload(java.io.InputStream)",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "cache": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not to cache loaded properties. The default value is true.",
          "title": "Cache",
          "required": false,
          "deprecated": false
        },
        "ignoreMissingLocation": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to silently ignore if a location cannot be located such as a properties file not found.",
          "title": "Ignore Missing Location",
          "required": false,
          "deprecated": false
        },
        "propertiesResolverRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to a custom PropertiesResolver to be used",
          "title": "Properties Resolver Ref",
          "required": false,
          "deprecated": false
        },
        "propertiesParserRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to a custom PropertiesParser to be used",
          "title": "Properties Parser Ref",
          "required": false,
          "deprecated": false
        },
        "propertyPrefix": {
          "kind": "attribute",
          "type": "string",
          "description": "Optional prefix prepended to property names before resolution.",
          "title": "Property Prefix",
          "required": false,
          "deprecated": false
        },
        "propertySuffix": {
          "kind": "attribute",
          "type": "string",
          "description": "Optional suffix appended to property names before resolution.",
          "title": "Property Suffix",
          "required": false,
          "deprecated": false
        },
        "fallbackToUnaugmentedProperty": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "If true first attempt resolution of property name augmented with propertyPrefix and propertySuffix before falling back the plain property name specified. If false only the augmented property name is searched.",
          "title": "Fallback To Unaugmented Property",
          "required": false,
          "deprecated": false
        },
        "prefixToken": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "{{",
          "description": "Sets the value of the prefix token used to identify properties to replace. Setting a value of null restores the default token",
          "title": "Prefix Token",
          "required": false,
          "deprecated": false
        },
        "suffixToken": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "}}",
          "description": "Sets the value of the suffix token used to identify properties to replace. Setting a value of null restores the default token",
          "title": "Suffix Token",
          "required": false,
          "deprecated": false
        },
        "propertiesFunction": {
          "kind": "element",
          "type": "array",
          "description": "List of custom properties function to use.",
          "title": "Properties Function",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "proxy": {
      "type": "object",
      "title": "Proxy",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "To proxy a service call using a interface",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "serviceUrl": {
          "kind": "attribute",
          "type": "string",
          "description": "The camel endpoint uri used to send the message to when calling the service from the interface.",
          "title": "Service Url",
          "required": false,
          "deprecated": false
        },
        "serviceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "The camel endpoint reference used to send the message to when calling the service from the interface.",
          "title": "Service Ref",
          "required": false,
          "deprecated": true
        },
        "serviceInterface": {
          "kind": "attribute",
          "type": "string",
          "description": "Java interfaces to use as facade for the service to be proxied",
          "title": "Service Interface",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "The id of the CamelContext to use if there is multiple CamelContext in the same JVM.",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "binding": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Camel parameter binding is enabled by default which will use binding information from the method signature parameters to bind to the Exchange/Message with the following annotations. If disabled then a org.apache.camel.component.bean.CamelInvocationHandler is used.",
          "title": "Binding",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "random": {
      "type": "object",
      "title": "Random",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Random load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "recipientList": {
      "type": "object",
      "title": "Recipient List",
      "group": "eip,endpoint,routing",
      "icon": "recipientList24.png",
      "description": "Routes messages to a number of dynamically specified recipients (dynamic to)",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression that returns which endpoints (url) to send the message to (the recipients). If the expression return an empty value then the message is not sent to any recipients.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "delimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "Delimiter used if the Expression returned multiple endpoints. Can be turned off using the value false. The default value is",
          "title": "Delimiter",
          "required": false,
          "deprecated": false
        },
        "parallelProcessing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then sending messages to the recipients occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only the sending and processing the replies from the recipients which happens concurrently.",
          "title": "Parallel Processing",
          "required": false,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to the AggregationStrategy to be used to assemble the replies from the recipients into a single outgoing message from the RecipientList. By default Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "stopOnException": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the recipient list will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end",
          "title": "Stop On Exception",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoints": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoints",
          "required": false,
          "deprecated": false
        },
        "streaming": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as defined by the recipient list.",
          "title": "Streaming",
          "required": false,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "0",
          "description": "Sets a total timeout specified in millis when using parallel processing. If the Recipient List hasn't been able to send and process all replies within the given timeframe then the timeout triggers and the Recipient List breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "onPrepareRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.",
          "title": "On Prepare Ref",
          "required": false,
          "deprecated": false
        },
        "shareUnitOfWork": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Recipient List will by default not share unit of work between the parent exchange and each recipient exchange. This means each sub exchange has its own individual unit of work.",
          "title": "Share Unit Of Work",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "parallelAggregate": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.",
          "title": "Parallel Aggregate",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "redeliveryPolicy": {
      "type": "object",
      "title": "Redelivery Policy",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To configure re-delivery for error handling",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "maximumRedeliveries": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever",
          "title": "Maximum Redeliveries",
          "required": false,
          "deprecated": false
        },
        "redeliveryDelay": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the initial redelivery delay",
          "title": "Redelivery Delay",
          "required": false,
          "deprecated": false
        },
        "asyncDelayedRedelivery": {
          "kind": "attribute",
          "type": "string",
          "description": "Allow synchronous delayed redelivery.",
          "title": "Async Delayed Redelivery",
          "required": false,
          "deprecated": false
        },
        "backOffMultiplier": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the back off multiplier",
          "title": "Back Off Multiplier",
          "required": false,
          "deprecated": false
        },
        "useExponentialBackOff": {
          "kind": "attribute",
          "type": "string",
          "description": "Turn on exponential backk off",
          "title": "Use Exponential Back Off",
          "required": false,
          "deprecated": false
        },
        "collisionAvoidanceFactor": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the collision avoidance factor",
          "title": "Collision Avoidance Factor",
          "required": false,
          "deprecated": false
        },
        "useCollisionAvoidance": {
          "kind": "attribute",
          "type": "string",
          "description": "Turn on collision avoidance.",
          "title": "Use Collision Avoidance",
          "required": false,
          "deprecated": false
        },
        "maximumRedeliveryDelay": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum delay between redelivery",
          "title": "Maximum Redelivery Delay",
          "required": false,
          "deprecated": false
        },
        "retriesExhaustedLogLevel": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level to use when retries has exhausted",
          "title": "Retries Exhausted Log Level",
          "required": false,
          "deprecated": false
        },
        "retryAttemptedLogLevel": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level to use for logging retry attempts",
          "title": "Retry Attempted Log Level",
          "required": false,
          "deprecated": false
        },
        "logRetryAttempted": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Retry Attempted",
          "required": false,
          "deprecated": false
        },
        "logStackTrace": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether stack traces should be logged. Can be used to include or reduce verbose.",
          "title": "Log Stack Trace",
          "required": false,
          "deprecated": false
        },
        "logRetryStackTrace": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose.",
          "title": "Log Retry Stack Trace",
          "required": false,
          "deprecated": false
        },
        "logHandled": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Handled",
          "required": false,
          "deprecated": false
        },
        "logNewException": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception.",
          "title": "Log New Exception",
          "required": false,
          "deprecated": false
        },
        "logContinued": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Continued",
          "required": false,
          "deprecated": false
        },
        "logExhausted": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Exhausted",
          "required": false,
          "deprecated": false
        },
        "logExhaustedMessageHistory": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose.",
          "title": "Log Exhausted Message History",
          "required": false,
          "deprecated": false
        },
        "logExhaustedMessageBody": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether exhausted message body should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose. Requires logExhaustedMessageHistory to be enabled.",
          "title": "Log Exhausted Message Body",
          "required": false,
          "deprecated": false
        },
        "disableRedelivery": {
          "kind": "attribute",
          "type": "string",
          "description": "Disables redelivery (same as setting maximum redeliveries to 0)",
          "title": "Disable Redelivery",
          "required": false,
          "deprecated": false
        },
        "delayPattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the delay pattern with delay intervals.",
          "title": "Delay Pattern",
          "required": false,
          "deprecated": false
        },
        "allowRedeliveryWhileStopping": {
          "kind": "attribute",
          "type": "string",
          "description": "Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.",
          "title": "Allow Redelivery While Stopping",
          "required": false,
          "deprecated": false
        },
        "exchangeFormatterRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.",
          "title": "Exchange Formatter Ref",
          "required": false,
          "deprecated": false
        }
      }
    },
    "redeliveryPolicyProfile": {
      "type": "object",
      "title": "Redelivery Policy Profile",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Configuration of redelivery policy.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "maximumRedeliveries": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum number of times a message exchange will be redelivered. Setting a negative value will retry forever.",
          "title": "Maximum Redeliveries",
          "required": false,
          "deprecated": false
        },
        "redeliveryDelay": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "1000",
          "description": "Sets the maximum redelivery delay. Use -1 if you wish to have no maximum",
          "title": "Redelivery Delay",
          "required": false,
          "deprecated": false
        },
        "asyncDelayedRedelivery": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether asynchronous delayed redelivery is allowed. This is disabled by default. When enabled it allows Camel to schedule a future task for delayed redelivery which prevents current thread from blocking while waiting. Exchange which is transacted will however always use synchronous delayed redelivery because the transaction must execute in the same thread context.",
          "title": "Async Delayed Redelivery",
          "required": false,
          "deprecated": false
        },
        "backOffMultiplier": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "2",
          "description": "Sets the multiplier used to increase the delay between redeliveries if useExponentialBackOff is enabled",
          "title": "Back Off Multiplier",
          "required": false,
          "deprecated": false
        },
        "useExponentialBackOff": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Enables/disables exponential backoff using the backOffMultiplier to increase the time between retries",
          "title": "Use Exponential Back Off",
          "required": false,
          "deprecated": false
        },
        "collisionAvoidanceFactor": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "0.15",
          "description": "Sets the factor used for collision avoidance if enabled via useCollisionAvoidance.",
          "title": "Collision Avoidance Factor",
          "required": false,
          "deprecated": false
        },
        "useCollisionAvoidance": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Enables/disables collision avoidance which adds some randomization to the backoff timings to reduce contention probability",
          "title": "Use Collision Avoidance",
          "required": false,
          "deprecated": false
        },
        "maximumRedeliveryDelay": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "60000",
          "description": "Sets the maximum redelivery delay. Use -1 if you wish to have no maximum",
          "title": "Maximum Redelivery Delay",
          "required": false,
          "deprecated": false
        },
        "retriesExhaustedLogLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "ERROR",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level to use for log messages when retries have been exhausted.",
          "title": "Retries Exhausted Log Level",
          "required": false,
          "deprecated": false
        },
        "retryAttemptedLogLevel": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "DEBUG",
          "enum": [ "DEBUG", "ERROR", "INFO", "OFF", "TRACE", "WARN" ],
          "description": "Sets the logging level to use for log messages when retries are attempted.",
          "title": "Retry Attempted Log Level",
          "required": false,
          "deprecated": false
        },
        "logRetryAttempted": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Sets whether to log retry attempts",
          "title": "Log Retry Attempted",
          "required": false,
          "deprecated": false
        },
        "logStackTrace": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Sets whether stack traces should be logged or not",
          "title": "Log Stack Trace",
          "required": false,
          "deprecated": false
        },
        "logRetryStackTrace": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether stack traces should be logged or not",
          "title": "Log Retry Stack Trace",
          "required": false,
          "deprecated": false
        },
        "logHandled": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether errors should be logged even if its handled",
          "title": "Log Handled",
          "required": false,
          "deprecated": false
        },
        "logContinued": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether errors should be logged even if its continued",
          "title": "Log Continued",
          "required": false,
          "deprecated": false
        },
        "logExhausted": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Sets whether exhausted exceptions should be logged or not",
          "title": "Log Exhausted",
          "required": false,
          "deprecated": false
        },
        "logExhaustedMessageHistory": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether to log exhausted errors including message history",
          "title": "Log Exhausted Message History",
          "required": false,
          "deprecated": false
        },
        "disableRedelivery": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Disables redelivery by setting maximum redeliveries to 0.",
          "title": "Disable Redelivery",
          "required": false,
          "deprecated": false
        },
        "delayPattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets an optional delay pattern to use instead of fixed delay.",
          "title": "Delay Pattern",
          "required": false,
          "deprecated": false
        },
        "allowRedeliveryWhileStopping": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.",
          "title": "Allow Redelivery While Stopping",
          "required": false,
          "deprecated": false
        },
        "exchangeFormatterRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.",
          "title": "Exchange Formatter Ref",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "removeHeader": {
      "type": "object",
      "title": "Remove Header",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Removes a named header from the message",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of header to remove",
          "title": "Header Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "removeHeaders": {
      "type": "object",
      "title": "Remove Headers",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Removes message headers whose name matches a specified pattern",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Name or pattern of headers to remove",
          "title": "Pattern",
          "required": true,
          "deprecated": false
        },
        "excludePattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Name or patter of headers to not remove",
          "title": "Exclude Pattern",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "removeProperties": {
      "type": "object",
      "title": "Remove Properties",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Removes message exchange properties whose name matches a specified pattern",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Name or pattern of properties to remove",
          "title": "Pattern",
          "required": true,
          "deprecated": false
        },
        "excludePattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Name or pattern of properties to not remove",
          "title": "Exclude Pattern",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "removeProperty": {
      "type": "object",
      "title": "Remove Property",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Removes a named property from the message exchange",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "propertyName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of property to remove",
          "title": "Property Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "resequence": {
      "type": "object",
      "title": "Resequence",
      "group": "eip,routing",
      "icon": "resequence24.png",
      "description": "Resequences (re-order) messages based on an expression",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to use for re-ordering the messages such as a header with a sequence number",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "resequencerConfig": {
          "kind": "element",
          "type": "object",
          "description": "To configure the resequencer in using either batch or stream configuration. Will by default use batch configuration.",
          "title": "Resequencer Config",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "ribbonConfiguration": {
      "type": "object",
      "title": "Ribbon Configuration",
      "group": "eip,routing,remote",
      "icon": "generic24.png",
      "description": "Ribbon remote service call configuration",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "component": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "http",
          "description": "Sets the default Camel component to use for calling the remote service. By default the http component is used. You can configure this to use netty4-http jetty restlet or some other components of choice. If the service is not HTTP protocol you can use other components such as mqtt jms amqp etc. If the service call has been configured using an uri then the component from the uri is used instead of this default component.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "clientProperty": {
          "kind": "element",
          "type": "array",
          "description": "Set client properties to use. These properties are specific to what service call implementation are in use. For example if using ribbon then the client properties are define in com.netflix.client.config.CommonClientConfigKey.",
          "title": "Client Property",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "rollback": {
      "type": "object",
      "title": "Rollback",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Forces a rollback by stopping routing the message",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "markRollbackOnly": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Mark the transaction for rollback only (cannot be overruled to commit)",
          "title": "Mark Rollback Only",
          "required": false,
          "deprecated": false
        },
        "markRollbackOnlyLast": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Mark only last sub transaction for rollback only. When using sub transactions (if the transaction manager support this)",
          "title": "Mark Rollback Only Last",
          "required": false,
          "deprecated": false
        },
        "message": {
          "kind": "attribute",
          "type": "string",
          "description": "Message to use in rollback exception",
          "title": "Message",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "roundRobin": {
      "type": "object",
      "title": "Round Robin",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Round robin load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "route": {
      "type": "object",
      "title": "Route",
      "group": "configuration",
      "icon": "route24.png",
      "description": "A Camel route",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "group": {
          "kind": "attribute",
          "type": "string",
          "description": "The group that this route belongs to; could be the name of the RouteBuilder class or be explicitly configured in the XML. May be null.",
          "title": "Group",
          "required": false,
          "deprecated": false
        },
        "streamCache": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether stream caching is enabled on this route.",
          "title": "Stream Cache",
          "required": false,
          "deprecated": false
        },
        "trace": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether tracing is enabled on this route.",
          "title": "Trace",
          "required": false,
          "deprecated": false
        },
        "messageHistory": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Whether message history is enabled on this route.",
          "title": "Message History",
          "required": false,
          "deprecated": false
        },
        "handleFault": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether handle fault is enabled on this route.",
          "title": "Handle Fault",
          "required": false,
          "deprecated": false
        },
        "delayer": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether to slow down processing messages by a given delay in msec.",
          "title": "Delayer",
          "required": false,
          "deprecated": false
        },
        "autoStartup": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Whether to auto start this route",
          "title": "Auto Startup",
          "required": false,
          "deprecated": false
        },
        "startupOrder": {
          "kind": "attribute",
          "type": "integer",
          "description": "To configure the ordering of the routes being started",
          "title": "Startup Order",
          "required": false,
          "deprecated": false
        },
        "errorHandlerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the bean ref name of the error handler builder to use on this route",
          "title": "Error Handler Ref",
          "required": false,
          "deprecated": false
        },
        "routePolicyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to custom org.apache.camel.spi.RoutePolicy to use by the route. Multiple policies can be configured by separating values using comma.",
          "title": "Route Policy Ref",
          "required": false,
          "deprecated": false
        },
        "shutdownRoute": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "Default", "Defer" ],
          "description": "To control how to shutdown the route.",
          "title": "Shutdown Route",
          "required": false,
          "deprecated": false
        },
        "shutdownRunningTask": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "CompleteCurrentTaskOnly", "CompleteAllTasks" ],
          "description": "To control how to shutdown the route.",
          "title": "Shutdown Running Task",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "routeBuilder": {
      "type": "object",
      "title": "Route Builder",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To refer to a Java org.apache.camel.builder.RouteBuilder instance to use.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the route builder instance",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "routeContext": {
      "type": "object",
      "title": "Route Context",
      "group": "spring,configuration,routing",
      "icon": "generic24.png",
      "description": "Configuration of routes using XML",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "route": {
          "kind": "element",
          "type": "array",
          "description": "Contains the Camel routes",
          "title": "Route",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "routeContextRef": {
      "type": "object",
      "title": "Route Context Ref",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To refer to an XML file with routes defined using the xml-dsl",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the routes in the xml dsl",
          "title": "Ref",
          "required": true,
          "deprecated": false
        }
      }
    },
    "routes": {
      "type": "object",
      "title": "Routes",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "A series of Camel routes",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "routes": {
          "kind": "element",
          "type": "array",
          "description": "Contains the Camel routes",
          "title": "Routes",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "routingSlip": {
      "type": "object",
      "title": "Routing Slip",
      "group": "eip,endpoint,routing",
      "icon": "routingSlip24.png",
      "description": "Routes a message through a series of steps that are pre-determined (the slip)",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to define the routing slip which defines which endpoints to route the message in a pipeline style. Notice the expression is evaluated once if you want a more dynamic style then the dynamic router eip is a better choice.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "uriDelimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "Sets the uri delimiter to use",
          "title": "Uri Delimiter",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoints": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoints",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ProducerCache which is used to cache and reuse producers when using this recipient list when uris are reused.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "sample": {
      "type": "object",
      "title": "Sample",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Extract a sample of the messages passing through a route",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "samplePeriod": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1",
          "description": "Sets the sample period during which only a single Exchange will pass through.",
          "title": "Sample Period",
          "required": false,
          "deprecated": false
        },
        "messageFrequency": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the sample message count which only a single Exchange will pass through after this many received.",
          "title": "Message Frequency",
          "required": false,
          "deprecated": false
        },
        "units": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "SECONDS",
          "enum": [ "DAYS", "HOURS", "MICROSECONDS", "MILLISECONDS", "MINUTES", "NANOSECONDS", "SECONDS" ],
          "description": "Sets the time units for the sample period defaulting to seconds.",
          "title": "Units",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "script": {
      "type": "object",
      "title": "Script",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Executes a script from a language which does not change the message body.",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to return the transformed message body (the new message body to use)",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "serviceCall": {
      "type": "object",
      "title": "Service Call",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Remote service call",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "name": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the name of the service to use",
          "title": "Name",
          "required": true,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the optional ExchangePattern used to invoke this endpoint",
          "title": "Pattern",
          "required": false,
          "deprecated": false
        },
        "serviceCallConfiguration": {
          "kind": "element",
          "type": "object",
          "description": "Configures the ServiceCall using the given configuration",
          "title": "Service Call Configuration",
          "required": false,
          "deprecated": false
        },
        "serviceCallConfigurationRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a ServiceCall configuration to use",
          "title": "Service Call Configuration Ref",
          "required": false,
          "deprecated": false
        },
        "loadBalancerRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallLoadBalancer to use.",
          "title": "Load Balancer Ref",
          "required": false,
          "deprecated": false
        },
        "serverListStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to a custom org.apache.camel.spi.ServiceCallServerListStrategy to use.",
          "title": "Server List Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setBody": {
      "type": "object",
      "title": "Set Body",
      "group": "eip,transformation",
      "icon": "setBody24.png",
      "description": "Sets the contents of the message body",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression that returns the new body to use",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setExchangePattern": {
      "type": "object",
      "title": "Set Exchange Pattern",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Sets the exchange pattern on the message exchange",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the new exchange pattern of the Exchange to be used from this point forward",
          "title": "Pattern",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setFaultBody": {
      "type": "object",
      "title": "Set Fault Body",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Sets the contents of a fault message's body",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression that returns the new fault body to use",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setHeader": {
      "type": "object",
      "title": "Set Header",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Sets the value of a message header",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to return the value of the header",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of message header to set a new value The simple language can be used to define a dynamic evaluated header name to be used. Otherwise a constant name will be used.",
          "title": "Header Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setOutHeader": {
      "type": "object",
      "title": "Set Out Header",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Sets the value of a header on the outbound message",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to return the value of the header",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of message header to set a new value",
          "title": "Header Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "setProperty": {
      "type": "object",
      "title": "Set Property",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Sets a named property on the message exchange",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to return the value of the message exchange property",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "propertyName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of exchange property to set a new value. The simple language can be used to define a dynamic evaluated exchange property name to be used. Otherwise a constant name will be used.",
          "title": "Property Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "sort": {
      "type": "object",
      "title": "Sort",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Sorts the contents of the message",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Optional expression to sort by something else than the message body",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "comparatorRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to lookup for the comparator to use for sorting",
          "title": "Comparator Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "split": {
      "type": "object",
      "title": "Split",
      "group": "eip,routing",
      "icon": "split24.png",
      "description": "Splits a single message into many sub-messages.",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression of how to split the message body such as as-is using a tokenizer or using an xpath.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "parallelProcessing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then processing each splitted messages occurs concurrently. Note the caller thread will still wait until all messages has been fully processed before it continues. Its only processing the sub messages from the splitter which happens concurrently.",
          "title": "Parallel Processing",
          "required": false,
          "deprecated": false
        },
        "strategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages into a single outgoing message from the Splitter. By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy",
          "title": "Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "strategyMethodName": {
          "kind": "attribute",
          "type": "string",
          "description": "This option can be used to explicit declare the method name to use when using POJOs as the AggregationStrategy.",
          "title": "Strategy Method Name",
          "required": false,
          "deprecated": false
        },
        "strategyMethodAllowNull": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich) when using POJOs as the AggregationStrategy",
          "title": "Strategy Method Allow Null",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option then parallel processing is automatic implied and you do not have to enable that option as well.",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "streaming": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "When in streaming mode then the splitter splits the original message on-demand and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first but then we do not know the total size and therefore the link org.apache.camel.ExchangeSPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first to know the total size and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the link org.apache.camel.ExchangeSPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order eg in the order they come back. If disabled Camel will process replies in the same order as the messages was splitted.",
          "title": "Streaming",
          "required": false,
          "deprecated": false
        },
        "stopOnException": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the splitter will stop further processing. This is the same behavior as in pipeline which is used by the routing engine. The default behavior is to not stop but continue processing till the end",
          "title": "Stop On Exception",
          "required": false,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "0",
          "description": "Sets a total timeout specified in millis when using parallel processing. If the Splitter hasn't been able to split and process all the sub messages within the given timeframe then the timeout triggers and the Splitter breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "onPrepareRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.",
          "title": "On Prepare Ref",
          "required": false,
          "deprecated": false
        },
        "shareUnitOfWork": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Splitter will by default not share unit of work between the parent exchange and each splitted exchange. This means each splitted exchange has its own individual unit of work.",
          "title": "Share Unit Of Work",
          "required": false,
          "deprecated": false
        },
        "parallelAggregate": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.",
          "title": "Parallel Aggregate",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "sticky": {
      "type": "object",
      "title": "Sticky",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Sticky load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "correlationExpression": {
          "kind": "expression",
          "type": "object",
          "description": "The correlation expression to use to calculate the correlation key",
          "title": "Correlation Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "stop": {
      "type": "object",
      "title": "Stop",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Stops the processing of the current message",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "stream-config": {
      "type": "object",
      "title": "Stream-config",
      "group": "eip,routing,resequence",
      "icon": "generic24.png",
      "description": "Configures stream-processing resequence eip.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "capacity": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "100",
          "description": "Sets the capacity of the resequencer's inbound queue.",
          "title": "Capacity",
          "required": false,
          "deprecated": false
        },
        "timeout": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1000",
          "description": "Sets minimum time to wait for missing elements (messages).",
          "title": "Timeout",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidExchanges": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore invalid exchanges",
          "title": "Ignore Invalid Exchanges",
          "required": false,
          "deprecated": false
        },
        "comparatorRef": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom comparator",
          "title": "Comparator Ref",
          "required": false,
          "deprecated": false
        },
        "rejectOld": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If true throws an exception when messages older than the last delivered message are processed",
          "title": "Reject Old",
          "required": false,
          "deprecated": false
        }
      }
    },
    "streamCaching": {
      "type": "object",
      "title": "Stream Caching",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Stream caching configuration.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "enabled": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether the stream caching is enabled. Notice: This cannot be changed at runtime.",
          "title": "Enabled",
          "required": false,
          "deprecated": false
        },
        "spoolDirectory": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the spool (temporary) directory to use for overflow and spooling to disk. If no spool directory has been explicit configured then a temporary directory is created in the java.io.tmpdir directory.",
          "title": "Spool Directory",
          "required": false,
          "deprecated": false
        },
        "spoolChiper": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a chiper name to use when spooling to disk to write with encryption. By default the data is not encrypted.",
          "title": "Spool Chiper",
          "required": false,
          "deprecated": false
        },
        "spoolThreshold": {
          "kind": "attribute",
          "type": "string",
          "description": "Threshold in bytes when overflow to disk is activated. The default threshold is link org.apache.camel.StreamCacheDEFAULT_SPOOL_THRESHOLD bytes (eg 128kb). Use -1 to disable overflow to disk.",
          "title": "Spool Threshold",
          "required": false,
          "deprecated": false
        },
        "spoolUsedHeapMemoryThreshold": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a percentage (1-99) of used heap memory threshold to activate spooling to disk.",
          "title": "Spool Used Heap Memory Threshold",
          "required": false,
          "deprecated": false
        },
        "spoolUsedHeapMemoryLimit": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets what the upper bounds should be when spoolUsedHeapMemoryThreshold is in use.",
          "title": "Spool Used Heap Memory Limit",
          "required": false,
          "deprecated": false
        },
        "spoolRules": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to one or more custom org.apache.camel.spi.StreamCachingStrategy.SpoolRule to use. Multiple rules can be separated by comma.",
          "title": "Spool Rules",
          "required": false,
          "deprecated": false
        },
        "bufferSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the buffer size to use when allocating in-memory buffers used for in-memory stream caches. The default size is link org.apache.camel.util.IOHelperDEFAULT_BUFFER_SIZE",
          "title": "Buffer Size",
          "required": false,
          "deprecated": false
        },
        "removeSpoolDirectoryWhenStopping": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "true",
          "description": "Whether to remove the temporary directory when stopping. This option is default true",
          "title": "Remove Spool Directory When Stopping",
          "required": false,
          "deprecated": false
        },
        "statisticsEnabled": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether statistics is enabled.",
          "title": "Statistics Enabled",
          "required": false,
          "deprecated": false
        },
        "anySpoolRules": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "false",
          "description": "Sets whether if just any of the org.apache.camel.spi.StreamCachingStrategy.SpoolRule rules returns true then shouldSpoolCache(long) returns true. If this option is false then all the org.apache.camel.spi.StreamCachingStrategy.SpoolRule must return true. The default value is false which means that all the rules must return true.",
          "title": "Any Spool Rules",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "template": {
      "type": "object",
      "title": "Template",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Configures a ProducerTemplate",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "defaultEndpoint": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the default endpoint URI used by default for sending message exchanges",
          "title": "Default Endpoint",
          "required": false,
          "deprecated": false
        },
        "maximumCacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets a custom maximum cache size to use in the backing cache pools.",
          "title": "Maximum Cache Size",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "threadPool": {
      "type": "object",
      "title": "Thread Pool",
      "group": "spring,configuration",
      "icon": "generic24.png",
      "description": "Configuration of thread pools",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "poolSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the core pool size (threads to keep minimum in pool)",
          "title": "Pool Size",
          "required": true,
          "deprecated": false
        },
        "maxPoolSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum pool size",
          "title": "Max Pool Size",
          "required": false,
          "deprecated": false
        },
        "keepAliveTime": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the keep alive time for inactive threads",
          "title": "Keep Alive Time",
          "required": false,
          "deprecated": false
        },
        "timeUnit": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "SECONDS",
          "enum": [ "DAYS", "HOURS", "MICROSECONDS", "MILLISECONDS", "MINUTES", "NANOSECONDS", "SECONDS" ],
          "description": "Sets the time unit used for keep alive time",
          "title": "Time Unit",
          "required": false,
          "deprecated": false
        },
        "maxQueueSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum number of tasks in the work queue. Use -1 for an unbounded queue",
          "title": "Max Queue Size",
          "required": false,
          "deprecated": false
        },
        "allowCoreThreadTimeOut": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets whether to allow core threads to timeout",
          "title": "Allow Core Thread Time Out",
          "required": false,
          "deprecated": false
        },
        "rejectedPolicy": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "CallerRuns",
          "enum": [ "Abort", "CallerRuns", "Discard", "DiscardOldest" ],
          "description": "Sets the handler for tasks which cannot be executed by the thread pool.",
          "title": "Rejected Policy",
          "required": false,
          "deprecated": false
        },
        "threadName": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom thread name / pattern",
          "title": "Thread Name",
          "required": true,
          "deprecated": false
        },
        "scheduled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to use a scheduled thread pool",
          "title": "Scheduled",
          "required": false,
          "deprecated": false
        },
        "camelContextId": {
          "kind": "attribute",
          "type": "string",
          "description": "Id of CamelContext to use if there are multiple CamelContexts in the same JVM",
          "title": "Camel Context Id",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "threadPoolProfile": {
      "type": "object",
      "title": "Thread Pool Profile",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "To configure thread pools",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "defaultProfile": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether this profile is the default thread pool profile",
          "title": "Default Profile",
          "required": false,
          "deprecated": false
        },
        "poolSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the core pool size",
          "title": "Pool Size",
          "required": false,
          "deprecated": false
        },
        "maxPoolSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum pool size",
          "title": "Max Pool Size",
          "required": false,
          "deprecated": false
        },
        "keepAliveTime": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the keep alive time for idle threads in the pool",
          "title": "Keep Alive Time",
          "required": false,
          "deprecated": false
        },
        "timeUnit": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "DAYS", "HOURS", "MICROSECONDS", "MILLISECONDS", "MINUTES", "NANOSECONDS", "SECONDS" ],
          "description": "Sets the time unit to use for keep alive time By default SECONDS is used.",
          "title": "Time Unit",
          "required": false,
          "deprecated": false
        },
        "maxQueueSize": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue",
          "title": "Max Queue Size",
          "required": false,
          "deprecated": false
        },
        "allowCoreThreadTimeOut": {
          "kind": "attribute",
          "type": "string",
          "description": "Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false",
          "title": "Allow Core Thread Time Out",
          "required": false,
          "deprecated": false
        },
        "rejectedPolicy": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "Abort", "CallerRuns", "Discard", "DiscardOldest" ],
          "description": "Sets the handler for tasks which cannot be executed by the thread pool.",
          "title": "Rejected Policy",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "threads": {
      "type": "object",
      "title": "Threads",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Specifies that all steps after this node are processed asynchronously",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "To refer to a custom thread pool or use a thread pool profile (as overlay)",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "poolSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the core pool size",
          "title": "Pool Size",
          "required": false,
          "deprecated": false
        },
        "maxPoolSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum pool size",
          "title": "Max Pool Size",
          "required": false,
          "deprecated": false
        },
        "keepAliveTime": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the keep alive time for idle threads",
          "title": "Keep Alive Time",
          "required": false,
          "deprecated": false
        },
        "timeUnit": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "DAYS", "HOURS", "MICROSECONDS", "MILLISECONDS", "MINUTES", "NANOSECONDS", "SECONDS" ],
          "description": "Sets the keep alive time unit. By default SECONDS is used.",
          "title": "Time Unit",
          "required": false,
          "deprecated": false
        },
        "maxQueueSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum number of tasks in the work queue. Use -1 or Integer.MAX_VALUE for an unbounded queue",
          "title": "Max Queue Size",
          "required": false,
          "deprecated": false
        },
        "allowCoreThreadTimeOut": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether idle core threads is allowed to timeout and therefore can shrink the pool size below the core pool size Is by default false",
          "title": "Allow Core Thread Time Out",
          "required": false,
          "deprecated": false
        },
        "threadName": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "Threads",
          "description": "Sets the thread name to use.",
          "title": "Thread Name",
          "required": false,
          "deprecated": false
        },
        "rejectedPolicy": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "Abort", "CallerRuns", "Discard", "DiscardOldest" ],
          "description": "Sets the handler for tasks which cannot be executed by the thread pool.",
          "title": "Rejected Policy",
          "required": false,
          "deprecated": false
        },
        "callerRunsWhenRejected": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not to use as caller runs as fallback when a task is rejected being added to the thread pool (when its full). This is only used as fallback if no rejectedPolicy has been configured or the thread pool has no configured rejection handler. Is by default true",
          "title": "Caller Runs When Rejected",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "throttle": {
      "type": "object",
      "title": "Throttle",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Controls the rate at which messages are passed to the next node in the route",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to configure the maximum number of messages to throttle per request",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the ExecutorService which could be used by throttle definition",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "timePeriodMillis": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "1000",
          "description": "Sets the time period during which the maximum request count is valid for",
          "title": "Time Period Millis",
          "required": false,
          "deprecated": false
        },
        "asyncDelayed": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enables asynchronous delay which means the thread will not block while delaying.",
          "title": "Async Delayed",
          "required": false,
          "deprecated": false
        },
        "callerRunsWhenRejected": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the caller should run the task when it was rejected by the thread pool. Is by default true",
          "title": "Caller Runs When Rejected",
          "required": false,
          "deprecated": false
        },
        "rejectExecution": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not throttler throws the ThrottlerRejectedExecutionException when the exchange exceeds the request limit Is by default false",
          "title": "Reject Execution",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "throwException": {
      "type": "object",
      "title": "Throw Exception",
      "group": "error",
      "icon": "generic24.png",
      "description": "Throws an exception",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the exception instance to lookup from the registry to throw",
          "title": "Ref",
          "required": false,
          "deprecated": false
        },
        "message": {
          "kind": "attribute",
          "type": "string",
          "description": "To create a new exception instance and use the given message as caused message (supports simple language)",
          "title": "Message",
          "required": false,
          "deprecated": false
        },
        "exceptionType": {
          "kind": "attribute",
          "type": "string",
          "description": "The class of the exception to create using the message.",
          "title": "Exception Type",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "to": {
      "type": "object",
      "title": "To",
      "group": "eip,endpoint,routing",
      "icon": "endpoint24.png",
      "description": "Sends the message to a static endpoint",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the uri of the endpoint to send to.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the reference of the endpoint to send to.",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the optional ExchangePattern used to invoke this endpoint",
          "title": "Pattern",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "toD": {
      "type": "object",
      "title": "To D",
      "group": "eip,endpoint,routing",
      "icon": "endpoint24.png",
      "description": "Sends the message to a dynamic endpoint",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the optional ExchangePattern used to invoke this endpoint",
          "title": "Pattern",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ConsumerCache which is used to cache and reuse producers.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoint",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "topic": {
      "type": "object",
      "title": "Topic",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Topic load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "transacted": {
      "type": "object",
      "title": "Transacted",
      "group": "configuration",
      "icon": "transactionalClient24.png",
      "description": "Enables transaction on the route",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a reference to use for lookup the policy in the registry.",
          "title": "Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "transform": {
      "type": "object",
      "title": "Transform",
      "group": "eip,transformation",
      "icon": "transform24.png",
      "description": "Transforms the message body based on an expression",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to return the transformed message body (the new message body to use)",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "unmarshal": {
      "type": "object",
      "title": "Unmarshal",
      "group": "eip,transformation",
      "icon": "unmarshal24.png",
      "description": "Converts the message data received from the wire into a format that Apache Camel processors can consume",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "dataFormatType": {
          "kind": "element",
          "type": "object",
          "description": "The data format to be used",
          "title": "Data Format Type",
          "required": true,
          "deprecated": false
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "To refer to a custom data format to use as unmarshaller",
          "title": "Ref",
          "required": false,
          "deprecated": true
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "validate": {
      "type": "object",
      "title": "Validate",
      "group": "eip,transformation",
      "icon": "generic24.png",
      "description": "Validates a message based on an expression",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression to use for validation as a predicate. The expression should return either true or false. If returning false the message is invalid and an exception is thrown.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "weighted": {
      "type": "object",
      "title": "Weighted",
      "group": "eip,routing,loadbalance",
      "icon": "generic24.png",
      "description": "Weighted load balancer",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "roundRobin": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To enable round robin mode. By default the weighted distribution mode is used. The default value is false.",
          "title": "Round Robin",
          "required": false,
          "deprecated": false
        },
        "distributionRatio": {
          "kind": "attribute",
          "type": "string",
          "description": "The distribution ratio is a delimited String consisting on integer weights separated by delimiters for example 235. The distributionRatio must match the number of endpoints and/or processors specified in the load balancer list.",
          "title": "Distribution Ratio",
          "required": true,
          "deprecated": false
        },
        "distributionRatioDelimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "Delimiter used to specify the distribution ratio. The default value is",
          "title": "Distribution Ratio Delimiter",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "when": {
      "type": "object",
      "title": "When",
      "group": "eip,routing",
      "icon": "generic24.png",
      "description": "Triggers a route when an expression evaluates to true",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression used as the predicate to evaluate whether this when should trigger and route the message or not.",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "whenSkipSendToEndpoint": {
      "type": "object",
      "title": "When Skip Send To Endpoint",
      "group": "configuration",
      "icon": "generic24.png",
      "description": "Predicate to determine if the message should be sent or not to the endpoint when using interceptSentToEndpoint.",
      "acceptInput": "true",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "expression": {
          "kind": "expression",
          "type": "object",
          "description": "Expression used as the predicate to evaluate whether the message should be sent or not to the endpoint",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "wireTap": {
      "type": "object",
      "title": "Wire Tap",
      "group": "eip,endpoint,routing",
      "icon": "wireTap24.png",
      "description": "Routes a copy of a message (or creates a new message) to a secondary destination while continue routing the original message.",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "processorRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to a Processor to use for creating a new body as the message to use for wire tapping",
          "title": "Processor Ref",
          "required": false,
          "deprecated": false
        },
        "body": {
          "kind": "expression",
          "type": "object",
          "description": "Uses the expression for creating a new body as the message to use for wire tapping",
          "title": "Body",
          "required": false,
          "deprecated": false
        },
        "executorServiceRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Uses a custom thread pool",
          "title": "Executor Service Ref",
          "required": false,
          "deprecated": false
        },
        "copy": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Uses a copy of the original exchange",
          "title": "Copy",
          "required": false,
          "deprecated": false
        },
        "onPrepareRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send or any custom logic needed before the exchange is send.",
          "title": "On Prepare Ref",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.",
          "title": "Uri",
          "required": true,
          "deprecated": false
        },
        "pattern": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "InOnly", "InOptionalOut", "InOut", "OutIn", "OutOnly", "OutOptionalIn", "RobustInOnly", "RobustOutOnly" ],
          "description": "Sets the optional ExchangePattern used to invoke this endpoint",
          "title": "Pattern",
          "required": false,
          "deprecated": false
        },
        "cacheSize": {
          "kind": "attribute",
          "type": "integer",
          "description": "Sets the maximum size used by the org.apache.camel.impl.ConsumerCache which is used to cache and reuse producers.",
          "title": "Cache Size",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidEndpoint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Ignore the invalidate endpoint exception when try to create a producer with that endpoint",
          "title": "Ignore Invalid Endpoint",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    }
  },
  "rests": {
    "delete": {
      "type": "object",
      "title": "Delete",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest DELETE command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "get": {
      "type": "object",
      "title": "Get",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest GET command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "head": {
      "type": "object",
      "title": "Head",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest HEAD command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "options": {
      "type": "object",
      "title": "Options",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest OPTIONS command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "param": {
      "type": "object",
      "title": "Param",
      "group": "rest",
      "icon": "generic24.png",
      "description": "To specify the rest operation parameters using Swagger.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "name": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Swagger Parameter name.",
          "title": "Name",
          "required": true,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "path",
          "enum": [ "body", "formData", "header", "path", "query" ],
          "description": "Sets the Swagger Parameter type.",
          "title": "Type",
          "required": true,
          "deprecated": false
        },
        "defaultValue": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Swagger Parameter default value.",
          "title": "Default Value",
          "required": false,
          "deprecated": false
        },
        "required": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Sets the Swagger Parameter required flag.",
          "title": "Required",
          "required": false,
          "deprecated": false
        },
        "collectionFormat": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "csv",
          "enum": [ "csv", "multi", "pipes", "ssv", "tsv" ],
          "description": "Sets the Swagger Parameter collection format.",
          "title": "Collection Format",
          "required": false,
          "deprecated": false
        },
        "arrayType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "string",
          "description": "Sets the Swagger Parameter array type. Required if data type is array. Describes the type of items in the array.",
          "title": "Array Type",
          "required": false,
          "deprecated": false
        },
        "dataType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "string",
          "description": "Sets the Swagger Parameter data type.",
          "title": "Data Type",
          "required": false,
          "deprecated": false
        },
        "value": {
          "kind": "element",
          "type": "array",
          "description": "Sets the Swagger Parameter list of allowable values (enum).",
          "title": "Value",
          "required": false,
          "deprecated": false
        },
        "access": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Swagger Parameter paramAccess flag.",
          "title": "Access",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the Swagger Parameter description.",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "patch": {
      "type": "object",
      "title": "Patch",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest PATCH command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "post": {
      "type": "object",
      "title": "Post",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest POST command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "put": {
      "type": "object",
      "title": "Put",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest PUT command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "responseHeader": {
      "type": "object",
      "title": "Response Header",
      "group": "rest",
      "icon": "generic24.png",
      "description": "To specify the rest operation response headers using Swagger.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "name": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of the parameter. This option is mandatory.",
          "title": "Name",
          "required": true,
          "deprecated": false
        },
        "collectionFormat": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "csv",
          "enum": [ "csv", "multi", "pipes", "ssv", "tsv" ],
          "description": "Sets the Swagger Parameter collection format.",
          "title": "Collection Format",
          "required": false,
          "deprecated": false
        },
        "arrayType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "string",
          "description": "Sets the Swagger Parameter array type. Required if data type is array. Describes the type of items in the array.",
          "title": "Array Type",
          "required": false,
          "deprecated": false
        },
        "dataType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "string",
          "description": "Sets the Swagger header data type.",
          "title": "Data Type",
          "required": false,
          "deprecated": false
        },
        "value": {
          "kind": "element",
          "type": "array",
          "description": "Sets the Swagger Parameter list of allowable values.",
          "title": "Value",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "attribute",
          "type": "string",
          "description": "Description of the parameter.",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "responseMessage": {
      "type": "object",
      "title": "Response Message",
      "group": "rest",
      "icon": "generic24.png",
      "description": "To specify the rest operation response messages using Swagger.",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "code": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "200",
          "description": "The response code such as a HTTP status code.",
          "title": "Code",
          "required": false,
          "deprecated": false
        },
        "message": {
          "kind": "attribute",
          "type": "string",
          "description": "The response message (description)",
          "title": "Message",
          "required": true,
          "deprecated": false
        },
        "responseModel": {
          "kind": "attribute",
          "type": "string",
          "description": "The response model",
          "title": "Response Model",
          "required": false,
          "deprecated": false
        },
        "header": {
          "kind": "element",
          "type": "array",
          "description": "Adds a response header",
          "title": "Header",
          "required": false,
          "deprecated": false
        }
      }
    },
    "rest": {
      "type": "object",
      "title": "Rest",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Defines a rest service using the rest-dsl",
      "acceptInput": "false",
      "acceptOutput": "true",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "path": {
          "kind": "attribute",
          "type": "string",
          "description": "Path of the rest service such as /foo",
          "title": "Path",
          "required": false,
          "deprecated": false
        },
        "tag": {
          "kind": "attribute",
          "type": "string",
          "description": "To configure a special tag for the operations within this rest definition.",
          "title": "Tag",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. This option will override what may be configured on a parent level The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "verbs": {
          "kind": "element",
          "type": "array",
          "description": "The HTTP verbs this REST service accepts and uses",
          "title": "Verbs",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "restBinding": {
      "type": "object",
      "title": "Rest Binding",
      "group": "rest",
      "icon": "generic24.png",
      "description": "To configure rest binding",
      "acceptInput": "true",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "true",
      "properties": {
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "off",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. The default value is off",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "component": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the component name that this definition will apply to",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "restConfiguration": {
      "type": "object",
      "title": "Rest Configuration",
      "group": "rest",
      "icon": "generic24.png",
      "description": "To configure rest",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "component": {
          "kind": "attribute",
          "type": "string",
          "description": "The Camel Rest component to use for the REST transport (consumer) such as restlet spark-rest. If no component has been explicit configured then Camel will lookup if there is a Camel component that integrates with the Rest DSL or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found then that is being used.",
          "title": "Component",
          "required": false,
          "deprecated": false
        },
        "apiComponent": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "swagger",
          "description": "The name of the Camel component to use as the REST API (such as swagger)",
          "title": "Api Component",
          "required": false,
          "deprecated": false
        },
        "producerComponent": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the name of the Camel component to use as the REST producer",
          "title": "Producer Component",
          "required": false,
          "deprecated": false
        },
        "scheme": {
          "kind": "attribute",
          "type": "string",
          "description": "The scheme to use for exposing the REST service. Usually http or https is supported. The default value is http",
          "title": "Scheme",
          "required": false,
          "deprecated": false
        },
        "host": {
          "kind": "attribute",
          "type": "string",
          "description": "The hostname to use for exposing the REST service.",
          "title": "Host",
          "required": false,
          "deprecated": false
        },
        "port": {
          "kind": "attribute",
          "type": "string",
          "description": "The port number to use for exposing the REST service. Notice if you use servlet component then the port number configured here does not apply as the port number in use is the actual port number the servlet component is using. eg if using Apache Tomcat its the tomcat http port if using Apache Karaf its the HTTP service in Karaf that uses port 8181 by default etc. Though in those situations setting the port number here allows tooling and JMX to know the port number so its recommended to set the port number to the number that the servlet engine uses.",
          "title": "Port",
          "required": false,
          "deprecated": false
        },
        "producerApiDoc": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the location of the api document (swagger api) the REST producer will use to validate the REST uri and query parameters are valid accordingly to the api document. This requires adding camel-swagger-java to the classpath and any miss configuration will let Camel fail on startup and report the error(s). The location of the api document is loaded from classpath by default but you can use file: or http: to refer to resources to load from file or http url.",
          "title": "Producer Api Doc",
          "required": false,
          "deprecated": false
        },
        "contextPath": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a leading context-path the REST services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path. Or for components such as camel-jetty or camel-netty4-http that includes a HTTP server.",
          "title": "Context Path",
          "required": false,
          "deprecated": false
        },
        "apiContextPath": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets a leading API context-path the REST API services will be using. This can be used when using components such as camel-servlet where the deployed web application is deployed using a context-path.",
          "title": "Api Context Path",
          "required": false,
          "deprecated": false
        },
        "apiContextRouteId": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the route id to use for the route that services the REST API. The route will by default use an auto assigned route id.",
          "title": "Api Context Route Id",
          "required": false,
          "deprecated": false
        },
        "apiContextIdPattern": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets an CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern. The pattern name refers to the CamelContext name to match on the current CamelContext only. For any other value the pattern uses the rules from link org.apache.camel.util.EndpointHelpermatchPattern(String String)",
          "title": "Api Context Id Pattern",
          "required": false,
          "deprecated": false
        },
        "apiContextListing": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Sets whether listing of all available CamelContext's with REST services in the JVM is enabled. If enabled it allows to discover these contexts if false then only the current CamelContext is in use.",
          "title": "Api Context Listing",
          "required": false,
          "deprecated": false
        },
        "hostNameResolver": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "allLocalIp", "localHostName", "localIp" ],
          "description": "If no hostname has been explicit configured then this resolver is used to compute the hostname the REST service will be using.",
          "title": "Host Name Resolver",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "off",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. The default value is off",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do.",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "jsonDataFormat": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of specific json data format to use. By default json-jackson will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.",
          "title": "Json Data Format",
          "required": false,
          "deprecated": false
        },
        "xmlDataFormat": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of specific XML data format to use. By default jaxb will be used. Important: This option is only for setting a custom name of the data format not to refer to an existing data format instance.",
          "title": "Xml Data Format",
          "required": false,
          "deprecated": false
        },
        "componentProperty": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure as many additional properties for the rest component in use.",
          "title": "Component Property",
          "required": false,
          "deprecated": false
        },
        "endpointProperty": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure as many additional properties for the rest endpoint in use.",
          "title": "Endpoint Property",
          "required": false,
          "deprecated": false
        },
        "consumerProperty": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure as many additional properties for the rest consumer in use.",
          "title": "Consumer Property",
          "required": false,
          "deprecated": false
        },
        "dataFormatProperty": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure as many additional properties for the data formats in use. For example set property prettyPrint to true to have json outputted in pretty mode. The properties can be prefixed to denote the option is only for either JSON or XML and for either the IN or the OUT. The prefixes are: json.in. json.out. xml.in. xml.out. For example a key with value xml.out.mustBeJAXBElement is only for the XML data format for the outgoing. A key without a prefix is a common key for all situations.",
          "title": "Data Format Property",
          "required": false,
          "deprecated": false
        },
        "apiProperty": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure as many additional properties for the api documentation (swagger). For example set property api.title to my cool stuff",
          "title": "Api Property",
          "required": false,
          "deprecated": false
        },
        "corsHeaders": {
          "kind": "element",
          "type": "array",
          "description": "Allows to configure custom CORS headers.",
          "title": "Cors Headers",
          "required": false,
          "deprecated": false
        }
      }
    },
    "restContext": {
      "type": "object",
      "title": "Rest Context",
      "group": "spring,configuration,rest",
      "icon": "generic24.png",
      "description": "Configuration of REST services using rest-dsl using XML",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "rest": {
          "kind": "element",
          "type": "array",
          "description": "Contains the rest services defined using the rest-dsl",
          "title": "Rest",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "restContextRef": {
      "type": "object",
      "title": "Rest Context Ref",
      "group": "configuration,rest",
      "icon": "generic24.png",
      "description": "To refer to an XML file with rest services defined using the rest-dsl",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the rest-dsl",
          "title": "Ref",
          "required": true,
          "deprecated": false
        }
      }
    },
    "restProperty": {
      "type": "object",
      "title": "Rest Property",
      "group": "rest",
      "icon": "generic24.png",
      "description": "A key value pair",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "key": {
          "kind": "attribute",
          "type": "string",
          "description": "Property key",
          "title": "Key",
          "required": true,
          "deprecated": false
        },
        "value": {
          "kind": "attribute",
          "type": "string",
          "description": "Property value",
          "title": "Value",
          "required": true,
          "deprecated": false
        }
      }
    },
    "rests": {
      "type": "object",
      "title": "Rests",
      "group": "rest",
      "icon": "generic24.png",
      "description": "A series of rest services defined using the rest-dsl",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "rests": {
          "kind": "element",
          "type": "array",
          "description": "Contains the rest services defined using the rest-dsl",
          "title": "Rests",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    },
    "verb": {
      "type": "object",
      "title": "Verb",
      "group": "rest",
      "icon": "generic24.png",
      "description": "Rest command",
      "acceptInput": "false",
      "acceptOutput": "false",
      "nextSiblingAddedAsChild": "false",
      "properties": {
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "The HTTP verb such as GET or POST",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "uri": {
          "kind": "attribute",
          "type": "string",
          "description": "Uri template of this REST service such as /id.",
          "title": "Uri",
          "required": false,
          "deprecated": false
        },
        "consumes": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service consumes (accept as input) such as application/xml or application/json. This option will override what may be configured on a parent level",
          "title": "Consumes",
          "required": false,
          "deprecated": false
        },
        "produces": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the content type what the REST service produces (uses for output) such as application/xml or application/json This option will override what may be configured on a parent level",
          "title": "Produces",
          "required": false,
          "deprecated": false
        },
        "bindingMode": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "auto",
          "enum": [ "auto", "json", "json_xml", "off", "xml" ],
          "description": "Sets the binding mode to use. This option will override what may be configured on a parent level The default value is auto",
          "title": "Binding Mode",
          "required": false,
          "deprecated": false
        },
        "skipBindingOnErrorCode": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip binding on output if there is a custom HTTP error code header. This allows to build custom error messages that do not bind to json / xml etc as success messages otherwise will do. This option will override what may be configured on a parent level",
          "title": "Skip Binding On Error Code",
          "required": false,
          "deprecated": false
        },
        "enableCORS": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable CORS headers in the HTTP response. This option will override what may be configured on a parent level The default value is false.",
          "title": "Enable C O R S",
          "required": false,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from input to POJO for the incoming data This option will override what may be configured on a parent level",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "outType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name to use for binding from POJO to output for the outgoing data This option will override what may be configured on a parent level",
          "title": "Out Type",
          "required": false,
          "deprecated": false
        },
        "toOrRoute": {
          "kind": "element",
          "type": "object",
          "description": "To route from this REST service to a Camel endpoint or an inlined route",
          "title": "To Or Route",
          "required": true,
          "deprecated": false
        },
        "routeId": {
          "kind": "attribute",
          "type": "string",
          "description": "The route id this rest-dsl is using (read-only)",
          "title": "Route Id",
          "required": false,
          "deprecated": false
        },
        "apiDocs": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include or exclude the VerbDefinition in API documentation. The default value is true.",
          "title": "Api Docs",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        },
        "description": {
          "kind": "element",
          "type": "object",
          "description": "Sets the description of this node",
          "title": "Description",
          "required": false,
          "deprecated": false
        }
      }
    }
  },
  "dataformats": {
    "avro": {
      "type": "object",
      "title": "Avro",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Avro data format",
      "properties": {
        "instanceClassName": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name to use for marshal and unmarshalling",
          "title": "Instance Class Name",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "barcode": {
      "type": "object",
      "title": "Barcode",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Barcode data format",
      "properties": {
        "width": {
          "kind": "attribute",
          "type": "integer",
          "description": "Width of the barcode",
          "title": "Width",
          "required": false,
          "deprecated": false
        },
        "height": {
          "kind": "attribute",
          "type": "integer",
          "description": "Height of the barcode",
          "title": "Height",
          "required": false,
          "deprecated": false
        },
        "imageType": {
          "kind": "attribute",
          "type": "string",
          "description": "Image type of the barcode such as png",
          "title": "Image Type",
          "required": false,
          "deprecated": false
        },
        "barcodeFormat": {
          "kind": "attribute",
          "type": "string",
          "description": "Barcode format such as QR-Code",
          "title": "Barcode Format",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "base64": {
      "type": "object",
      "title": "Base64",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Base64 data format",
      "properties": {
        "lineLength": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "76",
          "description": "To specific a maximum line length for the encoded data. By default 76 is used.",
          "title": "Line Length",
          "required": false,
          "deprecated": false
        },
        "lineSeparator": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\r\n",
          "description": "The line separators to use. By default \r\n is used.",
          "title": "Line Separator",
          "required": false,
          "deprecated": false
        },
        "urlSafe": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Instead of emitting '' and '/' we emit '-' and '_' respectively. urlSafe is only applied to encode operations. Decoding seamlessly handles both modes. Is by default false.",
          "title": "Url Safe",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "beanio": {
      "type": "object",
      "title": "BeanIO",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "BeanIO data format",
      "properties": {
        "mapping": {
          "kind": "attribute",
          "type": "string",
          "description": "The BeanIO mapping file. Is by default loaded from the classpath. You can prefix with file: http: or classpath: to denote from where to load the mapping file.",
          "title": "Mapping",
          "required": true,
          "deprecated": false
        },
        "streamName": {
          "kind": "attribute",
          "type": "string",
          "description": "The name of the stream to use.",
          "title": "Stream Name",
          "required": true,
          "deprecated": false
        },
        "ignoreUnidentifiedRecords": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore unidentified records.",
          "title": "Ignore Unidentified Records",
          "required": false,
          "deprecated": false
        },
        "ignoreUnexpectedRecords": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore unexpected records.",
          "title": "Ignore Unexpected Records",
          "required": false,
          "deprecated": false
        },
        "ignoreInvalidRecords": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore invalid records.",
          "title": "Ignore Invalid Records",
          "required": false,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "The charset to use. Is by default the JVM platform default charset.",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "beanReaderErrorHandlerType": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom org.apache.camel.dataformat.beanio.BeanIOErrorHandler as error handler while parsing. Configure the fully qualified class name of the error handler. Notice the options ignoreUnidentifiedRecords ignoreUnexpectedRecords and ignoreInvalidRecords may not be in use when you use a custom error handler.",
          "title": "Bean Reader Error Handler Type",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "bindy": {
      "type": "object",
      "title": "Bindy",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "Bindy data format",
      "properties": {
        "type": {
          "kind": "attribute",
          "type": "string",
          "enum": [ "Csv", "Fixed", "KeyValue" ],
          "description": "Whether to use csv fixed or key value pairs mode.",
          "title": "Type",
          "required": true,
          "deprecated": false
        },
        "classType": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of model class to use.",
          "title": "Class Type",
          "required": false,
          "deprecated": false
        },
        "locale": {
          "kind": "attribute",
          "type": "string",
          "description": "To configure a default locale to use such as us for united states. To use the JVM platform default locale then use the name default",
          "title": "Locale",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "boon": {
      "type": "object",
      "title": "Boon",
      "group": "dataformat,transformation,json",
      "icon": "generic24.png",
      "description": "Boon data format",
      "properties": {
        "unmarshalTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name of the java type to use when unarmshalling",
          "title": "Unmarshal Type Name",
          "required": true,
          "deprecated": false
        },
        "useList": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To unarmshal to a List of Map or a List of Pojo.",
          "title": "Use List",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "castor": {
      "type": "object",
      "title": "Castor",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "Castor data format",
      "properties": {
        "mappingFile": {
          "kind": "attribute",
          "type": "string",
          "description": "Path to a Castor mapping file to load from the classpath.",
          "title": "Mapping File",
          "required": false,
          "deprecated": false
        },
        "validation": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether validation is turned on or off. Is by default true.",
          "title": "Validation",
          "required": false,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "UTF-8",
          "description": "Encoding to use when marshalling an Object to XML. Is by default UTF-8",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "packages": {
          "kind": "attribute",
          "type": "array",
          "description": "Add additional packages to Castor XmlContext",
          "title": "Packages",
          "required": false,
          "deprecated": false
        },
        "classes": {
          "kind": "attribute",
          "type": "array",
          "description": "Add additional class names to Castor XmlContext",
          "title": "Classes",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "crypto": {
      "type": "object",
      "title": "Crypto (Java Cryptographic Extension)",
      "group": "dataformat,transformation,security",
      "icon": "generic24.png",
      "description": "Crypto data format",
      "properties": {
        "algorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "DES/CBC/PKCS5Padding",
          "description": "The JCE algorithm name indicating the cryptographic algorithm that will be used. Is by default DES/CBC/PKCS5Padding.",
          "title": "Algorithm",
          "required": false,
          "deprecated": false
        },
        "cryptoProvider": {
          "kind": "attribute",
          "type": "string",
          "description": "The name of the JCE Security Provider that should be used.",
          "title": "Crypto Provider",
          "required": false,
          "deprecated": false
        },
        "keyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to the secret key to lookup from the register to use.",
          "title": "Key Ref",
          "required": false,
          "deprecated": false
        },
        "initVectorRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a byte array containing the Initialization Vector that will be used to initialize the Cipher.",
          "title": "Init Vector Ref",
          "required": false,
          "deprecated": false
        },
        "algorithmParameterRef": {
          "kind": "attribute",
          "type": "string",
          "description": "A JCE AlgorithmParameterSpec used to initialize the Cipher. Will lookup the type using the given name as a java.security.spec.AlgorithmParameterSpec type.",
          "title": "Algorithm Parameter Ref",
          "required": false,
          "deprecated": false
        },
        "buffersize": {
          "kind": "attribute",
          "type": "integer",
          "description": "The size of the buffer used in the signature process.",
          "title": "Buffersize",
          "required": false,
          "deprecated": false
        },
        "macAlgorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "HmacSHA1",
          "description": "The JCE algorithm name indicating the Message Authentication algorithm.",
          "title": "Mac Algorithm",
          "required": false,
          "deprecated": false
        },
        "shouldAppendHMAC": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Flag indicating that a Message Authentication Code should be calculated and appended to the encrypted data.",
          "title": "Should Append H M A C",
          "required": false,
          "deprecated": false
        },
        "inline": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Flag indicating that the configured IV should be inlined into the encrypted data stream. Is by default false.",
          "title": "Inline",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "csv": {
      "type": "object",
      "title": "CSV",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "CSV data format",
      "properties": {
        "formatRef": {
          "kind": "attribute",
          "type": "string",
          "description": "The reference format to use it will be updated with the other format options the default value is CSVFormat.DEFAULT",
          "title": "Format Ref",
          "required": false,
          "deprecated": false
        },
        "formatName": {
          "kind": "attribute",
          "type": "string",
          "description": "The name of the format to use the default value is CSVFormat.DEFAULT",
          "title": "Format Name",
          "required": false,
          "deprecated": false
        },
        "commentMarkerDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Disables the comment marker of the reference format.",
          "title": "Comment Marker Disabled",
          "required": false,
          "deprecated": false
        },
        "commentMarker": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the comment marker of the reference format.",
          "title": "Comment Marker",
          "required": false,
          "deprecated": false
        },
        "delimiter": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the delimiter to use. The default value is (comma)",
          "title": "Delimiter",
          "required": false,
          "deprecated": false
        },
        "escapeDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Use for disabling using escape character",
          "title": "Escape Disabled",
          "required": false,
          "deprecated": false
        },
        "escape": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the escape character to use",
          "title": "Escape",
          "required": false,
          "deprecated": false
        },
        "headerDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Use for disabling headers",
          "title": "Header Disabled",
          "required": false,
          "deprecated": false
        },
        "header": {
          "kind": "element",
          "type": "array",
          "description": "To configure the CSV headers",
          "title": "Header",
          "required": false,
          "deprecated": false
        },
        "allowMissingColumnNames": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to allow missing column names.",
          "title": "Allow Missing Column Names",
          "required": false,
          "deprecated": false
        },
        "ignoreEmptyLines": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore empty lines.",
          "title": "Ignore Empty Lines",
          "required": false,
          "deprecated": false
        },
        "ignoreSurroundingSpaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore surrounding spaces",
          "title": "Ignore Surrounding Spaces",
          "required": false,
          "deprecated": false
        },
        "nullStringDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Used to disable null strings",
          "title": "Null String Disabled",
          "required": false,
          "deprecated": false
        },
        "nullString": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the null string",
          "title": "Null String",
          "required": false,
          "deprecated": false
        },
        "quoteDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Used to disable quotes",
          "title": "Quote Disabled",
          "required": false,
          "deprecated": false
        },
        "quote": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the quote which by default is",
          "title": "Quote",
          "required": false,
          "deprecated": false
        },
        "recordSeparatorDisabled": {
          "kind": "attribute",
          "type": "string",
          "description": "Used for disabling record separator",
          "title": "Record Separator Disabled",
          "required": false,
          "deprecated": false
        },
        "recordSeparator": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the record separator (aka new line) which by default is \r\n (CRLF)",
          "title": "Record Separator",
          "required": false,
          "deprecated": false
        },
        "skipHeaderRecord": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to skip the header record in the output",
          "title": "Skip Header Record",
          "required": false,
          "deprecated": false
        },
        "quoteMode": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the quote mode",
          "title": "Quote Mode",
          "required": false,
          "deprecated": false
        },
        "lazyLoad": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one.",
          "title": "Lazy Load",
          "required": false,
          "deprecated": false
        },
        "useMaps": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected).",
          "title": "Use Maps",
          "required": false,
          "deprecated": false
        },
        "recordConverterRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom CsvRecordConverter to lookup from the registry to use.",
          "title": "Record Converter Ref",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "customDataFormat": {
      "type": "object",
      "title": "Custom",
      "group": "dataformat,transformation",
      "icon": "customDataFormat24.png",
      "description": "Custom data format",
      "properties": {
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to the custom org.apache.camel.spi.DataFormat to lookup from the Camel registry.",
          "title": "Ref",
          "required": true,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "dataFormats": {
      "type": "object",
      "title": "Data formats",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "To configure data formats",
      "properties": {
        "dataFormats": {
          "kind": "element",
          "type": "array",
          "description": "A list holding the configured data formats",
          "title": "Data Formats",
          "required": true,
          "deprecated": false
        }
      }
    },
    "flatpack": {
      "type": "object",
      "title": "Flatpack",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "Flatpack data format",
      "properties": {
        "parserFactoryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "References to a custom parser factory to lookup in the registry",
          "title": "Parser Factory Ref",
          "required": false,
          "deprecated": false
        },
        "definition": {
          "kind": "attribute",
          "type": "string",
          "description": "The flatpack pzmap configuration file. Can be omitted in simpler situations but its preferred to use the pzmap.",
          "title": "Definition",
          "required": false,
          "deprecated": false
        },
        "fixed": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Delimited or fixed. Is by default false = delimited",
          "title": "Fixed",
          "required": false,
          "deprecated": false
        },
        "ignoreFirstRecord": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether the first line is ignored for delimited files (for the column headers). Is by default true.",
          "title": "Ignore First Record",
          "required": false,
          "deprecated": false
        },
        "textQualifier": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\"",
          "description": "If the text is qualified with a char such as \"",
          "title": "Text Qualifier",
          "required": false,
          "deprecated": false
        },
        "delimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "The delimiter char (could be ; or similar)",
          "title": "Delimiter",
          "required": false,
          "deprecated": false
        },
        "allowShortLines": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Allows for lines to be shorter than expected and ignores the extra characters",
          "title": "Allow Short Lines",
          "required": false,
          "deprecated": false
        },
        "ignoreExtraColumns": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Allows for lines to be longer than expected and ignores the extra characters.",
          "title": "Ignore Extra Columns",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "gzip": {
      "type": "object",
      "title": "GZip",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "GZip compression data format",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "hessian": {
      "type": "object",
      "title": "Hessian",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Hessian data format",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "hl7": {
      "type": "object",
      "title": "HL7",
      "group": "dataformat,transformation,hl7",
      "icon": "generic24.png",
      "description": "HL7 data format",
      "properties": {
        "validate": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to validate the HL7 message Is by default true.",
          "title": "Validate",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "ical": {
      "type": "object",
      "title": "iCal",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "iCal data format",
      "properties": {
        "validating": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to validate.",
          "title": "Validating",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jacksonxml": {
      "type": "object",
      "title": "JacksonXML",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "Jackson XML data format",
      "properties": {
        "xmlMapper": {
          "kind": "attribute",
          "type": "string",
          "description": "Lookup and use the existing XmlMapper with the given id.",
          "title": "Xml Mapper",
          "required": false,
          "deprecated": false
        },
        "prettyPrint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To enable pretty printing output nicely formatted. Is by default false.",
          "title": "Pretty Print",
          "required": false,
          "deprecated": false
        },
        "unmarshalTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name of the java type to use when unarmshalling",
          "title": "Unmarshal Type Name",
          "required": false,
          "deprecated": false
        },
        "jsonView": {
          "kind": "attribute",
          "type": "string",
          "description": "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations",
          "title": "Json View",
          "required": false,
          "deprecated": false
        },
        "include": {
          "kind": "attribute",
          "type": "string",
          "description": "If you want to marshal a pojo to JSON and the pojo has some fields with null values. And you want to skip these null values you can set this option to NOT_NULL",
          "title": "Include",
          "required": false,
          "deprecated": false
        },
        "allowJmsType": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.",
          "title": "Allow Jms Type",
          "required": false,
          "deprecated": false
        },
        "collectionTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used but allows to use different collection types than java.util.Collection based as default.",
          "title": "Collection Type Name",
          "required": false,
          "deprecated": false
        },
        "useList": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To unarmshal to a List of Map or a List of Pojo.",
          "title": "Use List",
          "required": false,
          "deprecated": false
        },
        "enableJaxbAnnotationModule": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable the JAXB annotations module when using jackson. When enabled then JAXB annotations can be used by Jackson.",
          "title": "Enable Jaxb Annotation Module",
          "required": false,
          "deprecated": false
        },
        "moduleClassNames": {
          "kind": "attribute",
          "type": "string",
          "description": "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.",
          "title": "Module Class Names",
          "required": false,
          "deprecated": false
        },
        "moduleRefs": {
          "kind": "attribute",
          "type": "string",
          "description": "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.",
          "title": "Module Refs",
          "required": false,
          "deprecated": false
        },
        "enableFeatures": {
          "kind": "attribute",
          "type": "string",
          "description": "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma",
          "title": "Enable Features",
          "required": false,
          "deprecated": false
        },
        "disableFeatures": {
          "kind": "attribute",
          "type": "string",
          "description": "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma",
          "title": "Disable Features",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jaxb": {
      "type": "object",
      "title": "JAXB",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "JAXB data format",
      "properties": {
        "contextPath": {
          "kind": "attribute",
          "type": "string",
          "description": "Package name where your JAXB classes are located.",
          "title": "Context Path",
          "required": true,
          "deprecated": false
        },
        "schema": {
          "kind": "attribute",
          "type": "string",
          "description": "To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.",
          "title": "Schema",
          "required": false,
          "deprecated": false
        },
        "prettyPrint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To enable pretty printing output nicely formatted. Is by default false.",
          "title": "Pretty Print",
          "required": false,
          "deprecated": false
        },
        "objectFactory": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to allow using ObjectFactory classes to create the POJO classes during marshalling. This only applies to POJO classes that has not been annotated with JAXB and providing jaxb.index descriptor files.",
          "title": "Object Factory",
          "required": false,
          "deprecated": false
        },
        "ignoreJAXBElement": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to ignore JAXBElement elements - only needed to be set to false in very special use-cases.",
          "title": "Ignore J A X B Element",
          "required": false,
          "deprecated": false
        },
        "mustBeJAXBElement": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether marhsalling must be java objects with JAXB annotations. And if not then it fails. This option can be set to false to relax that such as when the data is already in XML format.",
          "title": "Must Be J A X B Element",
          "required": false,
          "deprecated": false
        },
        "filterNonXmlChars": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To ignore non xml characheters and replace them with an empty space.",
          "title": "Filter Non Xml Chars",
          "required": false,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "To overrule and use a specific encoding",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "fragment": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To turn on marshalling XML fragment trees. By default JAXB looks for XmlRootElement annotation on given class to operate on whole XML tree. This is useful but not always - sometimes generated code does not have XmlRootElement annotation sometimes you need unmarshall only part of tree. In that case you can use partial unmarshalling. To enable this behaviours you need set property partClass. Camel will pass this class to JAXB's unmarshaler.",
          "title": "Fragment",
          "required": false,
          "deprecated": false
        },
        "partClass": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of class used for fragment parsing. See more details at the fragment option.",
          "title": "Part Class",
          "required": false,
          "deprecated": false
        },
        "partNamespace": {
          "kind": "attribute",
          "type": "string",
          "description": "XML namespace to use for fragment parsing. See more details at the fragment option.",
          "title": "Part Namespace",
          "required": false,
          "deprecated": false
        },
        "namespacePrefixRef": {
          "kind": "attribute",
          "type": "string",
          "description": "When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.",
          "title": "Namespace Prefix Ref",
          "required": false,
          "deprecated": false
        },
        "xmlStreamWriterWrapper": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom xml stream writer.",
          "title": "Xml Stream Writer Wrapper",
          "required": false,
          "deprecated": false
        },
        "schemaLocation": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the location of the schema",
          "title": "Schema Location",
          "required": false,
          "deprecated": false
        },
        "noNamespaceSchemaLocation": {
          "kind": "attribute",
          "type": "string",
          "description": "To define the location of the namespaceless schema",
          "title": "No Namespace Schema Location",
          "required": false,
          "deprecated": false
        },
        "jaxbProviderProperties": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom java.util.Map to lookup in the registry containing custom JAXB provider properties to be used with the JAXB marshaller.",
          "title": "Jaxb Provider Properties",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jibx": {
      "type": "object",
      "title": "JiBX",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "JiBX data format",
      "properties": {
        "unmarshallClass": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name to use when unmarshalling from XML to Java.",
          "title": "Unmarshall Class",
          "required": false,
          "deprecated": false
        },
        "bindingName": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom binding factory",
          "title": "Binding Name",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "json": {
      "type": "object",
      "title": "JSon",
      "group": "dataformat,transformation,json",
      "icon": "generic24.png",
      "description": "JSon data format",
      "properties": {
        "objectMapper": {
          "kind": "attribute",
          "type": "string",
          "description": "Lookup and use the existing ObjectMapper with the given id when using Jackson.",
          "title": "Object Mapper",
          "required": false,
          "deprecated": false
        },
        "prettyPrint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To enable pretty printing output nicely formatted. Is by default false.",
          "title": "Pretty Print",
          "required": false,
          "deprecated": false
        },
        "library": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "XStream",
          "enum": [ "Gson", "Jackson", "Johnzon", "XStream" ],
          "description": "Which json library to use.",
          "title": "Library",
          "required": false,
          "deprecated": false
        },
        "unmarshalTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name of the java type to use when unarmshalling",
          "title": "Unmarshal Type Name",
          "required": false,
          "deprecated": false
        },
        "jsonView": {
          "kind": "attribute",
          "type": "string",
          "description": "When marshalling a POJO to JSON you might want to exclude certain fields from the JSON output. With Jackson you can use JSON views to accomplish this. This option is to refer to the class which has JsonView annotations",
          "title": "Json View",
          "required": false,
          "deprecated": false
        },
        "include": {
          "kind": "attribute",
          "type": "string",
          "description": "If you want to marshal a pojo to JSON and the pojo has some fields with null values. And you want to skip these null values you can set this option to NOT_NULL",
          "title": "Include",
          "required": false,
          "deprecated": false
        },
        "allowJmsType": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Used for JMS users to allow the JMSType header from the JMS spec to specify a FQN classname to use to unmarshal to.",
          "title": "Allow Jms Type",
          "required": false,
          "deprecated": false
        },
        "collectionTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a custom collection type to lookup in the registry to use. This option should rarely be used but allows to use different collection types than java.util.Collection based as default.",
          "title": "Collection Type Name",
          "required": false,
          "deprecated": false
        },
        "useList": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To unarmshal to a List of Map or a List of Pojo.",
          "title": "Use List",
          "required": false,
          "deprecated": false
        },
        "enableJaxbAnnotationModule": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to enable the JAXB annotations module when using jackson. When enabled then JAXB annotations can be used by Jackson.",
          "title": "Enable Jaxb Annotation Module",
          "required": false,
          "deprecated": false
        },
        "moduleClassNames": {
          "kind": "attribute",
          "type": "string",
          "description": "To use custom Jackson modules com.fasterxml.jackson.databind.Module specified as a String with FQN class names. Multiple classes can be separated by comma.",
          "title": "Module Class Names",
          "required": false,
          "deprecated": false
        },
        "moduleRefs": {
          "kind": "attribute",
          "type": "string",
          "description": "To use custom Jackson modules referred from the Camel registry. Multiple modules can be separated by comma.",
          "title": "Module Refs",
          "required": false,
          "deprecated": false
        },
        "enableFeatures": {
          "kind": "attribute",
          "type": "string",
          "description": "Set of features to enable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma",
          "title": "Enable Features",
          "required": false,
          "deprecated": false
        },
        "disableFeatures": {
          "kind": "attribute",
          "type": "string",
          "description": "Set of features to disable on the Jackson com.fasterxml.jackson.databind.ObjectMapper. The features should be a name that matches a enum from com.fasterxml.jackson.databind.SerializationFeature com.fasterxml.jackson.databind.DeserializationFeature or com.fasterxml.jackson.databind.MapperFeature Multiple features can be separated by comma",
          "title": "Disable Features",
          "required": false,
          "deprecated": false
        },
        "permissions": {
          "kind": "attribute",
          "type": "string",
          "description": "Adds permissions that controls which Java packages and classes XStream is allowed to use during unmarshal from xml/json to Java beans. A permission must be configured either here or globally using a JVM system property. The permission can be specified in a syntax where a plus sign is allow and minus sign is deny. Wildcards is supported by using . as prefix. For example to allow com.foo and all subpackages then specfy com.foo.. Multiple permissions can be configured separated by comma such as com.foo.-com.foo.bar.MySecretBean. The following default permission is always included: -java.lang.java.util. unless its overridden by specifying a JVM system property with they key org.apache.camel.xstream.permissions.",
          "title": "Permissions",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "lzf": {
      "type": "object",
      "title": "LZF Deflate Compression",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "LZF compression data format",
      "properties": {
        "usingParallelCompression": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Enable encoding (compress) using multiple processing cores.",
          "title": "Using Parallel Compression",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "mime-multipart": {
      "type": "object",
      "title": "MIME Multipart",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "MIME Multipart data format",
      "properties": {
        "multipartSubType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "mixed",
          "description": "Specify the subtype of the MIME Multipart. Default is mixed.",
          "title": "Multipart Sub Type",
          "required": false,
          "deprecated": false
        },
        "multipartWithoutAttachment": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Defines whether a message without attachment is also marshaled into a MIME Multipart (with only one body part). Default is false.",
          "title": "Multipart Without Attachment",
          "required": false,
          "deprecated": false
        },
        "headersInline": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Defines whether the MIME-Multipart headers are part of the message body (true) or are set as Camel headers (false). Default is false.",
          "title": "Headers Inline",
          "required": false,
          "deprecated": false
        },
        "includeHeaders": {
          "kind": "attribute",
          "type": "string",
          "description": "A regex that defines which Camel headers are also included as MIME headers into the MIME multipart. This will only work if headersInline is set to true. Default is to include no headers",
          "title": "Include Headers",
          "required": false,
          "deprecated": false
        },
        "binaryContent": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Defines whether the content of binary parts in the MIME multipart is binary (true) or Base-64 encoded (false) Default is false.",
          "title": "Binary Content",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "pgp": {
      "type": "object",
      "title": "PGP",
      "group": "dataformat,transformation,security",
      "icon": "generic24.png",
      "description": "PGP data format",
      "properties": {
        "keyUserid": {
          "kind": "attribute",
          "type": "string",
          "description": "The user ID of the key in the PGP keyring used during encryption. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the user ID.",
          "title": "Key Userid",
          "required": false,
          "deprecated": false
        },
        "signatureKeyUserid": {
          "kind": "attribute",
          "type": "string",
          "description": "User ID of the key in the PGP keyring used for signing (during encryption) or signature verification (during decryption). During the signature verification process the specified User ID restricts the public keys from the public keyring which can be used for the verification. If no User ID is specified for the signature verficiation then any public key in the public keyring can be used for the verification. Can also be only a part of a user ID. For example if the user ID is Test User then you can use the part Test User or to address the User ID.",
          "title": "Signature Key Userid",
          "required": false,
          "deprecated": false
        },
        "password": {
          "kind": "attribute",
          "type": "string",
          "description": "Password used when opening the private key (not used for encryption).",
          "title": "Password",
          "required": false,
          "deprecated": false
        },
        "signaturePassword": {
          "kind": "attribute",
          "type": "string",
          "description": "Password used when opening the private key used for signing (during encryption).",
          "title": "Signature Password",
          "required": false,
          "deprecated": false
        },
        "keyFileName": {
          "kind": "attribute",
          "type": "string",
          "description": "Filename of the keyring; must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).",
          "title": "Key File Name",
          "required": false,
          "deprecated": false
        },
        "signatureKeyFileName": {
          "kind": "attribute",
          "type": "string",
          "description": "Filename of the keyring to use for signing (during encryption) or for signature verification (during decryption); must be accessible as a classpath resource (but you can specify a location in the file system by using the file: prefix).",
          "title": "Signature Key File Name",
          "required": false,
          "deprecated": false
        },
        "signatureKeyRing": {
          "kind": "attribute",
          "type": "string",
          "description": "Keyring used for signing/verifying as byte array. You can not set the signatureKeyFileName and signatureKeyRing at the same time.",
          "title": "Signature Key Ring",
          "required": false,
          "deprecated": false
        },
        "armored": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "This option will cause PGP to base64 encode the encrypted text making it available for copy/paste etc.",
          "title": "Armored",
          "required": false,
          "deprecated": false
        },
        "integrity": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Adds an integrity check/sign into the encryption file. The default value is true.",
          "title": "Integrity",
          "required": false,
          "deprecated": false
        },
        "provider": {
          "kind": "attribute",
          "type": "string",
          "description": "Java Cryptography Extension (JCE) provider default is Bouncy Castle (BC). Alternatively you can use for example the IAIK JCE provider; in this case the provider must be registered beforehand and the Bouncy Castle provider must not be registered beforehand. The Sun JCE provider does not work.",
          "title": "Provider",
          "required": false,
          "deprecated": false
        },
        "algorithm": {
          "kind": "attribute",
          "type": "integer",
          "description": "Symmetric key encryption algorithm; possible values are defined in org.bouncycastle.bcpg.SymmetricKeyAlgorithmTags; for example 2 (= TRIPLE DES) 3 (= CAST5) 4 (= BLOWFISH) 6 (= DES) 7 (= AES_128). Only relevant for encrypting.",
          "title": "Algorithm",
          "required": false,
          "deprecated": false
        },
        "compressionAlgorithm": {
          "kind": "attribute",
          "type": "integer",
          "description": "Compression algorithm; possible values are defined in org.bouncycastle.bcpg.CompressionAlgorithmTags; for example 0 (= UNCOMPRESSED) 1 (= ZIP) 2 (= ZLIB) 3 (= BZIP2). Only relevant for encrypting.",
          "title": "Compression Algorithm",
          "required": false,
          "deprecated": false
        },
        "hashAlgorithm": {
          "kind": "attribute",
          "type": "integer",
          "description": "Signature hash algorithm; possible values are defined in org.bouncycastle.bcpg.HashAlgorithmTags; for example 2 (= SHA1) 8 (= SHA256) 9 (= SHA384) 10 (= SHA512) 11 (=SHA224). Only relevant for signing.",
          "title": "Hash Algorithm",
          "required": false,
          "deprecated": false
        },
        "signatureVerificationOption": {
          "kind": "attribute",
          "type": "string",
          "description": "Controls the behavior for verifying the signature during unmarshaling. There are 4 values possible: optional: The PGP message may or may not contain signatures; if it does contain signatures then a signature verification is executed. required: The PGP message must contain at least one signature; if this is not the case an exception (PGPException) is thrown. A signature verification is executed. ignore: Contained signatures in the PGP message are ignored; no signature verification is executed. no_signature_allowed: The PGP message must not contain a signature; otherwise an exception (PGPException) is thrown.",
          "title": "Signature Verification Option",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "protobuf": {
      "type": "object",
      "title": "Protobuf",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Google protobuf data format",
      "properties": {
        "instanceClass": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of class to use when unarmshalling",
          "title": "Instance Class",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "rss": {
      "type": "object",
      "title": "RSS",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "RSS data format",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "secureXML": {
      "type": "object",
      "title": "XML Security",
      "group": "dataformat,transformation,xml,security",
      "icon": "generic24.png",
      "description": "XML-Security data format",
      "properties": {
        "xmlCipherAlgorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "TRIPLEDES",
          "description": "The cipher algorithm to be used for encryption/decryption of the XML message content. The available choices are: XMLCipher.TRIPLEDES XMLCipher.AES_128 XMLCipher.AES_128_GCM XMLCipher.AES_192 XMLCipher.AES_192_GCM XMLCipher.AES_256 XMLCipher.AES_256_GCM XMLCipher.SEED_128 XMLCipher.CAMELLIA_128 XMLCipher.CAMELLIA_192 XMLCipher.CAMELLIA_256 The default value is MLCipher.TRIPLEDES",
          "title": "Xml Cipher Algorithm",
          "required": false,
          "deprecated": false
        },
        "passPhrase": {
          "kind": "attribute",
          "type": "string",
          "description": "A String used as passPhrase to encrypt/decrypt content. The passPhrase has to be provided. If no passPhrase is specified a default passPhrase is used. The passPhrase needs to be put together in conjunction with the appropriate encryption algorithm. For example using TRIPLEDES the passPhase can be a Only another 24 Byte key",
          "title": "Pass Phrase",
          "required": false,
          "deprecated": false
        },
        "secureTag": {
          "kind": "attribute",
          "type": "string",
          "description": "The XPath reference to the XML Element selected for encryption/decryption. If no tag is specified the entire payload is encrypted/decrypted.",
          "title": "Secure Tag",
          "required": false,
          "deprecated": false
        },
        "secureTagContents": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "A boolean value to specify whether the XML Element is to be encrypted or the contents of the XML Element false = Element Level true = Element Content Level",
          "title": "Secure Tag Contents",
          "required": false,
          "deprecated": false
        },
        "keyCipherAlgorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "RSA_OAEP",
          "description": "The cipher algorithm to be used for encryption/decryption of the asymmetric key. The available choices are: XMLCipher.RSA_v1dot5 XMLCipher.RSA_OAEP XMLCipher.RSA_OAEP_11 The default value is XMLCipher.RSA_OAEP",
          "title": "Key Cipher Algorithm",
          "required": false,
          "deprecated": false
        },
        "recipientKeyAlias": {
          "kind": "attribute",
          "type": "string",
          "description": "The key alias to be used when retrieving the recipient's public or private key from a KeyStore when performing asymmetric key encryption or decryption.",
          "title": "Recipient Key Alias",
          "required": false,
          "deprecated": false
        },
        "keyOrTrustStoreParametersId": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to a KeyStore instance to lookup in the registry which is used for configuration options for creating and loading a KeyStore instance that represents the sender's trustStore or recipient's keyStore.",
          "title": "Key Or Trust Store Parameters Id",
          "required": false,
          "deprecated": false
        },
        "keyPassword": {
          "kind": "attribute",
          "type": "string",
          "description": "The password to be used for retrieving the private key from the KeyStore. This key is used for asymmetric decryption.",
          "title": "Key Password",
          "required": false,
          "deprecated": false
        },
        "digestAlgorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "SHA1",
          "description": "The digest algorithm to use with the RSA OAEP algorithm. The available choices are: XMLCipher.SHA1 XMLCipher.SHA256 XMLCipher.SHA512 The default value is XMLCipher.SHA1",
          "title": "Digest Algorithm",
          "required": false,
          "deprecated": false
        },
        "mgfAlgorithm": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "MGF1_SHA1",
          "description": "The MGF Algorithm to use with the RSA OAEP algorithm. The available choices are: EncryptionConstants.MGF1_SHA1 EncryptionConstants.MGF1_SHA256 EncryptionConstants.MGF1_SHA512 The default value is EncryptionConstants.MGF1_SHA1",
          "title": "Mgf Algorithm",
          "required": false,
          "deprecated": false
        },
        "addKeyValueForEncryptedKey": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to add the public key used to encrypt the session key as a KeyValue in the EncryptedKey structure or not.",
          "title": "Add Key Value For Encrypted Key",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "serialization": {
      "type": "object",
      "title": "Java Object Serialization",
      "group": "dataformat,transformation,core",
      "icon": "generic24.png",
      "description": "Java Object Serialization data format",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "soapjaxb": {
      "type": "object",
      "title": "SOAP",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "SOAP data format",
      "properties": {
        "contextPath": {
          "kind": "attribute",
          "type": "string",
          "description": "Package name where your JAXB classes are located.",
          "title": "Context Path",
          "required": true,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "To overrule and use a specific encoding",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "elementNameStrategyRef": {
          "kind": "attribute",
          "type": "string",
          "description": "Refers to an element strategy to lookup from the registry. An element name strategy is used for two purposes. The first is to find a xml element name for a given object and soap action when marshaling the object into a SOAP message. The second is to find an Exception class for a given soap fault name. The following three element strategy class name is provided out of the box. QNameStrategy - Uses a fixed qName that is configured on instantiation. Exception lookup is not supported TypeNameStrategy - Uses the name and namespace from the XMLType annotation of the given type. If no namespace is set then package-info is used. Exception lookup is not supported ServiceInterfaceStrategy - Uses information from a webservice interface to determine the type name and to find the exception class for a SOAP fault All three classes is located in the package name org.apache.camel.dataformat.soap.name If you have generated the web service stub code with cxf-codegen or a similar tool then you probably will want to use the ServiceInterfaceStrategy. In the case you have no annotated service interface you should use QNameStrategy or TypeNameStrategy.",
          "title": "Element Name Strategy Ref",
          "required": false,
          "deprecated": false
        },
        "version": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "1.1",
          "description": "SOAP version should either be 1.1 or 1.2. Is by default 1.1",
          "title": "Version",
          "required": false,
          "deprecated": false
        },
        "namespacePrefixRef": {
          "kind": "attribute",
          "type": "string",
          "description": "When marshalling using JAXB or SOAP then the JAXB implementation will automatic assign namespace prefixes such as ns2 ns3 ns4 etc. To control this mapping Camel allows you to refer to a map which contains the desired mapping.",
          "title": "Namespace Prefix Ref",
          "required": false,
          "deprecated": false
        },
        "schema": {
          "kind": "attribute",
          "type": "string",
          "description": "To validate against an existing schema. Your can use the prefix classpath: file: or http: to specify how the resource should by resolved. You can separate multiple schema files by using the '' character.",
          "title": "Schema",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "string": {
      "type": "object",
      "title": "String Encoding",
      "group": "dataformat,transformation,core",
      "icon": "generic24.png",
      "description": "String (text based) data format",
      "properties": {
        "charset": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets an encoding to use. Will by default use the JVM platform default charset.",
          "title": "Charset",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "syslog": {
      "type": "object",
      "title": "Syslog",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Syslog data format",
      "properties": {
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "tarfile": {
      "type": "object",
      "title": "Tar File",
      "group": "dataformat,transformation,file",
      "icon": "generic24.png",
      "description": "TAR file data format",
      "properties": {
        "usingIterator": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If the tar file has more then one entry the setting this option to true allows to work with the splitter EIP to split the data using an iterator in a streaming mode.",
          "title": "Using Iterator",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "tidyMarkup": {
      "type": "object",
      "title": "TidyMarkup",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Tidymark (wellformed HTML) data format",
      "properties": {
        "dataObjectType": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "org.w3c.dom.Node",
          "description": "What data type to unmarshal as can either be org.w3c.dom.Node or java.lang.String. Is by default org.w3c.dom.Node",
          "title": "Data Object Type",
          "required": false,
          "deprecated": false
        },
        "omitXmlDeclaration": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "When returning a String do we omit the XML declaration in the top.",
          "title": "Omit Xml Declaration",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "univocity-csv": {
      "type": "object",
      "title": "uniVocity CSV",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "UniVocity CSV data format",
      "properties": {
        "quoteAllFields": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not all values must be quoted when writing them.",
          "title": "Quote All Fields",
          "required": false,
          "deprecated": false
        },
        "quote": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\"",
          "description": "The quote symbol.",
          "title": "Quote",
          "required": false,
          "deprecated": false
        },
        "quoteEscape": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\"",
          "description": "The quote escape symbol",
          "title": "Quote Escape",
          "required": false,
          "deprecated": false
        },
        "delimiter": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": ",",
          "description": "The delimiter of values",
          "title": "Delimiter",
          "required": false,
          "deprecated": false
        },
        "nullValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The string representation of a null value. The default value is null",
          "title": "Null Value",
          "required": false,
          "deprecated": false
        },
        "skipEmptyLines": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the empty lines must be ignored. The default value is true",
          "title": "Skip Empty Lines",
          "required": false,
          "deprecated": false
        },
        "ignoreTrailingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the trailing white spaces must ignored. The default value is true",
          "title": "Ignore Trailing Whitespaces",
          "required": false,
          "deprecated": false
        },
        "ignoreLeadingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the leading white spaces must be ignored. The default value is true",
          "title": "Ignore Leading Whitespaces",
          "required": false,
          "deprecated": false
        },
        "headersDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the headers are disabled. When defined this option explicitly sets the headers as null which indicates that there is no header. The default value is false",
          "title": "Headers Disabled",
          "required": false,
          "deprecated": false
        },
        "headerExtractionEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the header must be read in the first line of the test document The default value is false",
          "title": "Header Extraction Enabled",
          "required": false,
          "deprecated": false
        },
        "numberOfRecordsToRead": {
          "kind": "attribute",
          "type": "integer",
          "description": "The maximum number of record to read.",
          "title": "Number Of Records To Read",
          "required": false,
          "deprecated": false
        },
        "emptyValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The String representation of an empty value",
          "title": "Empty Value",
          "required": false,
          "deprecated": false
        },
        "lineSeparator": {
          "kind": "attribute",
          "type": "string",
          "description": "The line separator of the files The default value is to use the JVM platform line separator",
          "title": "Line Separator",
          "required": false,
          "deprecated": false
        },
        "normalizedLineSeparator": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\n",
          "description": "The normalized line separator of the files The default value is \n",
          "title": "Normalized Line Separator",
          "required": false,
          "deprecated": false
        },
        "comment": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "#",
          "description": "The comment symbol. The default value is",
          "title": "Comment",
          "required": false,
          "deprecated": false
        },
        "lazyLoad": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false",
          "title": "Lazy Load",
          "required": false,
          "deprecated": false
        },
        "asMap": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false",
          "title": "As Map",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "univocity-fixed": {
      "type": "object",
      "title": "uniVocity Fixed Length",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "UniVocity fixed-width data format",
      "properties": {
        "skipTrailingCharsUntilNewline": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the trailing characters until new line must be ignored. The default value is false",
          "title": "Skip Trailing Chars Until Newline",
          "required": false,
          "deprecated": false
        },
        "recordEndsOnNewline": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the record ends on new line. The default value is false",
          "title": "Record Ends On Newline",
          "required": false,
          "deprecated": false
        },
        "padding": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "",
          "description": "The padding character. The default value is a space",
          "title": "Padding",
          "required": false,
          "deprecated": false
        },
        "nullValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The string representation of a null value. The default value is null",
          "title": "Null Value",
          "required": false,
          "deprecated": false
        },
        "skipEmptyLines": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the empty lines must be ignored. The default value is true",
          "title": "Skip Empty Lines",
          "required": false,
          "deprecated": false
        },
        "ignoreTrailingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the trailing white spaces must ignored. The default value is true",
          "title": "Ignore Trailing Whitespaces",
          "required": false,
          "deprecated": false
        },
        "ignoreLeadingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the leading white spaces must be ignored. The default value is true",
          "title": "Ignore Leading Whitespaces",
          "required": false,
          "deprecated": false
        },
        "headersDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the headers are disabled. When defined this option explicitly sets the headers as null which indicates that there is no header. The default value is false",
          "title": "Headers Disabled",
          "required": false,
          "deprecated": false
        },
        "headerExtractionEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the header must be read in the first line of the test document The default value is false",
          "title": "Header Extraction Enabled",
          "required": false,
          "deprecated": false
        },
        "numberOfRecordsToRead": {
          "kind": "attribute",
          "type": "integer",
          "description": "The maximum number of record to read.",
          "title": "Number Of Records To Read",
          "required": false,
          "deprecated": false
        },
        "emptyValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The String representation of an empty value",
          "title": "Empty Value",
          "required": false,
          "deprecated": false
        },
        "lineSeparator": {
          "kind": "attribute",
          "type": "string",
          "description": "The line separator of the files The default value is to use the JVM platform line separator",
          "title": "Line Separator",
          "required": false,
          "deprecated": false
        },
        "normalizedLineSeparator": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\n",
          "description": "The normalized line separator of the files The default value is \n",
          "title": "Normalized Line Separator",
          "required": false,
          "deprecated": false
        },
        "comment": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "#",
          "description": "The comment symbol. The default value is",
          "title": "Comment",
          "required": false,
          "deprecated": false
        },
        "lazyLoad": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false",
          "title": "Lazy Load",
          "required": false,
          "deprecated": false
        },
        "asMap": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false",
          "title": "As Map",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "univocity-header": {
      "type": "object",
      "title": "uniVocity Header",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "To configure headers for UniVocity data formats.",
      "properties": {
        "name": {
          "kind": "value",
          "type": "string",
          "description": "Header name",
          "title": "Name",
          "required": true,
          "deprecated": false
        },
        "length": {
          "kind": "attribute",
          "type": "integer",
          "description": "Header length",
          "title": "Length",
          "required": false,
          "deprecated": false
        }
      }
    },
    "univocity-tsv": {
      "type": "object",
      "title": "uniVocity TSV",
      "group": "dataformat,transformation,csv",
      "icon": "generic24.png",
      "description": "UniVocity TSV data format",
      "properties": {
        "escapeChar": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\\",
          "description": "The escape character.",
          "title": "Escape Char",
          "required": false,
          "deprecated": false
        },
        "nullValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The string representation of a null value. The default value is null",
          "title": "Null Value",
          "required": false,
          "deprecated": false
        },
        "skipEmptyLines": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the empty lines must be ignored. The default value is true",
          "title": "Skip Empty Lines",
          "required": false,
          "deprecated": false
        },
        "ignoreTrailingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the trailing white spaces must ignored. The default value is true",
          "title": "Ignore Trailing Whitespaces",
          "required": false,
          "deprecated": false
        },
        "ignoreLeadingWhitespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether or not the leading white spaces must be ignored. The default value is true",
          "title": "Ignore Leading Whitespaces",
          "required": false,
          "deprecated": false
        },
        "headersDisabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the headers are disabled. When defined this option explicitly sets the headers as null which indicates that there is no header. The default value is false",
          "title": "Headers Disabled",
          "required": false,
          "deprecated": false
        },
        "headerExtractionEnabled": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether or not the header must be read in the first line of the test document The default value is false",
          "title": "Header Extraction Enabled",
          "required": false,
          "deprecated": false
        },
        "numberOfRecordsToRead": {
          "kind": "attribute",
          "type": "integer",
          "description": "The maximum number of record to read.",
          "title": "Number Of Records To Read",
          "required": false,
          "deprecated": false
        },
        "emptyValue": {
          "kind": "attribute",
          "type": "string",
          "description": "The String representation of an empty value",
          "title": "Empty Value",
          "required": false,
          "deprecated": false
        },
        "lineSeparator": {
          "kind": "attribute",
          "type": "string",
          "description": "The line separator of the files The default value is to use the JVM platform line separator",
          "title": "Line Separator",
          "required": false,
          "deprecated": false
        },
        "normalizedLineSeparator": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "\n",
          "description": "The normalized line separator of the files The default value is \n",
          "title": "Normalized Line Separator",
          "required": false,
          "deprecated": false
        },
        "comment": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "#",
          "description": "The comment symbol. The default value is",
          "title": "Comment",
          "required": false,
          "deprecated": false
        },
        "lazyLoad": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce an iterator that reads the lines on the fly or if all the lines must be read at one. The default value is false",
          "title": "Lazy Load",
          "required": false,
          "deprecated": false
        },
        "asMap": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the unmarshalling should produce maps for the lines values instead of lists. It requires to have header (either defined or collected). The default value is false",
          "title": "As Map",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xmlBeans": {
      "type": "object",
      "title": "XML Beans",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "XMLBeans data format",
      "properties": {
        "prettyPrint": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To enable pretty printing output nicely formatted. Is by default false.",
          "title": "Pretty Print",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xmljson": {
      "type": "object",
      "title": "XML JSon",
      "group": "dataformat,transformation,xml,json",
      "icon": "generic24.png",
      "description": "XML-JSon data format",
      "properties": {
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the encoding. Used for unmarshalling (JSON to XML conversion).",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "elementName": {
          "kind": "attribute",
          "type": "string",
          "description": "Specifies the name of the XML elements representing each array element. Used for unmarshalling (JSON to XML conversion).",
          "title": "Element Name",
          "required": false,
          "deprecated": false
        },
        "arrayName": {
          "kind": "attribute",
          "type": "string",
          "description": "Specifies the name of the top-level XML element. Used for unmarshalling (JSON to XML conversion). For example when converting 1 2 3 it will be output by default as 123. By setting this option or rootName you can alter the name of element 'a'.",
          "title": "Array Name",
          "required": false,
          "deprecated": false
        },
        "forceTopLevelObject": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Determines whether the resulting JSON will start off with a top-most element whose name matches the XML root element. Used for marshalling (XML to JSon conversion). If disabled XML string 12 turns into 'x: '1' 'y': '2' . Otherwise it turns into 'a': 'x: '1' 'y': '2' .",
          "title": "Force Top Level Object",
          "required": false,
          "deprecated": false
        },
        "namespaceLenient": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Flag to be tolerant to incomplete namespace prefixes. Used for unmarshalling (JSON to XML conversion). In most cases json-lib automatically changes this flag at runtime to match the processing.",
          "title": "Namespace Lenient",
          "required": false,
          "deprecated": false
        },
        "rootName": {
          "kind": "attribute",
          "type": "string",
          "description": "Specifies the name of the top-level element. Used for unmarshalling (JSON to XML conversion). If not set json-lib will use arrayName or objectName (default value: 'o' at the current time it is not configurable in this data format). If set to 'root' the JSON string 'x': 'value1' 'y' : 'value2' would turn into value1value2 otherwise the 'root' element would be named 'o'.",
          "title": "Root Name",
          "required": false,
          "deprecated": false
        },
        "skipWhitespace": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Determines whether white spaces between XML elements will be regarded as text values or disregarded. Used for marshalling (XML to JSon conversion).",
          "title": "Skip Whitespace",
          "required": false,
          "deprecated": false
        },
        "trimSpaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Determines whether leading and trailing white spaces will be omitted from String values. Used for marshalling (XML to JSon conversion).",
          "title": "Trim Spaces",
          "required": false,
          "deprecated": false
        },
        "skipNamespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Signals whether namespaces should be ignored. By default they will be added to the JSON output using xmlns elements. Used for marshalling (XML to JSon conversion).",
          "title": "Skip Namespaces",
          "required": false,
          "deprecated": false
        },
        "removeNamespacePrefixes": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Removes the namespace prefixes from XML qualified elements so that the resulting JSON string does not contain them. Used for marshalling (XML to JSon conversion).",
          "title": "Remove Namespace Prefixes",
          "required": false,
          "deprecated": false
        },
        "expandableProperties": {
          "kind": "attribute",
          "type": "array",
          "description": "With expandable properties JSON array elements are converted to XML as a sequence of repetitive XML elements with the local name equal to the JSON key for example: number: 123 normally converted to: 123 (where e can be modified by setting elementName) would instead translate to 123 if number is set as an expandable property Used for unmarshalling (JSON to XML conversion).",
          "title": "Expandable Properties",
          "required": false,
          "deprecated": false
        },
        "typeHints": {
          "kind": "attribute",
          "type": "string",
          "description": "Adds type hints to the resulting XML to aid conversion back to JSON. Used for unmarshalling (JSON to XML conversion).",
          "title": "Type Hints",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xmlrpc": {
      "type": "object",
      "title": "XML RPC",
      "group": "dataformat,transformation,xml",
      "icon": "generic24.png",
      "description": "XML-RPC data format",
      "properties": {
        "request": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to marshal/unmarshal request or response Is by default false",
          "title": "Request",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xstream": {
      "type": "object",
      "title": "XStream",
      "group": "dataformat,transformation,xml,json",
      "icon": "generic24.png",
      "description": "XStream data format",
      "properties": {
        "permissions": {
          "kind": "attribute",
          "type": "string",
          "description": "Adds permissions that controls which Java packages and classes XStream is allowed to use during unmarshal from xml/json to Java beans. A permission must be configured either here or globally using a JVM system property. The permission can be specified in a syntax where a plus sign is allow and minus sign is deny. Wildcards is supported by using . as prefix. For example to allow com.foo and all subpackages then specfy com.foo.. Multiple permissions can be configured separated by comma such as com.foo.-com.foo.bar.MySecretBean. The following default permission is always included: -java.lang.java.util. unless its overridden by specifying a JVM system property with they key org.apache.camel.xstream.permissions.",
          "title": "Permissions",
          "required": false,
          "deprecated": false
        },
        "encoding": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the encoding to use",
          "title": "Encoding",
          "required": false,
          "deprecated": false
        },
        "driver": {
          "kind": "attribute",
          "type": "string",
          "description": "To use a custom XStream driver. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver",
          "title": "Driver",
          "required": false,
          "deprecated": false
        },
        "driverRef": {
          "kind": "attribute",
          "type": "string",
          "description": "To refer to a custom XStream driver to lookup in the registry. The instance must be of type com.thoughtworks.xstream.io.HierarchicalStreamDriver",
          "title": "Driver Ref",
          "required": false,
          "deprecated": false
        },
        "mode": {
          "kind": "attribute",
          "type": "string",
          "description": "Mode for dealing with duplicate references The possible values are: NO_REFERENCES ID_REFERENCES XPATH_RELATIVE_REFERENCES XPATH_ABSOLUTE_REFERENCES SINGLE_NODE_XPATH_RELATIVE_REFERENCES SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES",
          "title": "Mode",
          "required": false,
          "deprecated": false
        },
        "converters": {
          "kind": "element",
          "type": "array",
          "description": "List of class names for using custom XStream converters. The classes must be of type com.thoughtworks.xstream.converters.Converter",
          "title": "Converters",
          "required": false,
          "deprecated": false
        },
        "aliases": {
          "kind": "element",
          "type": "object",
          "description": "Alias a Class to a shorter name to be used in XML elements.",
          "title": "Aliases",
          "required": false,
          "deprecated": false
        },
        "omitFields": {
          "kind": "element",
          "type": "object",
          "description": "Prevents a field from being serialized. To omit a field you must always provide the declaring type and not necessarily the type that is converted.",
          "title": "Omit Fields",
          "required": false,
          "deprecated": false
        },
        "implicitCollections": {
          "kind": "element",
          "type": "object",
          "description": "Adds a default implicit collection which is used for any unmapped XML tag.",
          "title": "Implicit Collections",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "yaml": {
      "type": "object",
      "title": "YAML",
      "group": "dataformat,transformation,yaml",
      "icon": "generic24.png",
      "description": "YAML data format",
      "properties": {
        "library": {
          "kind": "attribute",
          "type": "string",
          "defaultValue": "SnakeYAML",
          "enum": [ "SnakeYAML" ],
          "description": "Which yaml library to use such. Is by default SnakeYAML",
          "title": "Library",
          "required": false,
          "deprecated": false
        },
        "unmarshalTypeName": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name of the java type to use when unarmshalling",
          "title": "Unmarshal Type Name",
          "required": false,
          "deprecated": false
        },
        "constructor": {
          "kind": "attribute",
          "type": "string",
          "description": "BaseConstructor to construct incoming documents.",
          "title": "Constructor",
          "required": false,
          "deprecated": false
        },
        "representer": {
          "kind": "attribute",
          "type": "string",
          "description": "Representer to emit outgoing objects.",
          "title": "Representer",
          "required": false,
          "deprecated": false
        },
        "dumperOptions": {
          "kind": "attribute",
          "type": "string",
          "description": "DumperOptions to configure outgoing objects.",
          "title": "Dumper Options",
          "required": false,
          "deprecated": false
        },
        "resolver": {
          "kind": "attribute",
          "type": "string",
          "description": "Resolver to detect implicit type",
          "title": "Resolver",
          "required": false,
          "deprecated": false
        },
        "useApplicationContextClassLoader": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Use ApplicationContextClassLoader as custom ClassLoader",
          "title": "Use Application Context Class Loader",
          "required": false,
          "deprecated": false
        },
        "prettyFlow": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Force the emitter to produce a pretty YAML document when using the flow style.",
          "title": "Pretty Flow",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "zip": {
      "type": "object",
      "title": "Zip Deflate Compression",
      "group": "dataformat,transformation",
      "icon": "generic24.png",
      "description": "Zip compression data format (not for zip files)",
      "properties": {
        "compressionLevel": {
          "kind": "attribute",
          "type": "integer",
          "defaultValue": "-1",
          "description": "To specify a specific compression between 0-9. -1 is default compression 0 is no compression and 9 is best compression.",
          "title": "Compression Level",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "zipFile": {
      "type": "object",
      "title": "Zip File",
      "group": "dataformat,transformation,file",
      "icon": "generic24.png",
      "description": "Zip-file data format",
      "properties": {
        "usingIterator": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If the zip file has more then one entry the setting this option to true allows to work with the splitter EIP to split the data using an iterator in a streaming mode.",
          "title": "Using Iterator",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the value of the id property.",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    }
  },
  "languages": {
    "constant": {
      "type": "object",
      "title": "Constant",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "For expressions and predicates using a constant",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "el": {
      "type": "object",
      "title": "EL",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For EL expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "exchangeProperty": {
      "type": "object",
      "title": "ExchangeProperty",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "An expression which extracts the named exchange property",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "expression": {
      "type": "object",
      "title": "Expression",
      "group": "language",
      "icon": "generic24.png",
      "description": "A useful base class for an expression",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "groovy": {
      "type": "object",
      "title": "Groovy",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For Groovy expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "header": {
      "type": "object",
      "title": "Header",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "An expression which extracts the named exchange header",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "javaScript": {
      "type": "object",
      "title": "JavaScript",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For JavaScript expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jsonpath": {
      "type": "object",
      "title": "JSonPath",
      "group": "language,json",
      "icon": "generic24.png",
      "description": "For JSonPath expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "resultType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name of the result type (type from output)",
          "title": "Result Type",
          "required": false,
          "deprecated": false
        },
        "suppressExceptions": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to suppress exceptions such as PathNotFoundException.",
          "title": "Suppress Exceptions",
          "required": false,
          "deprecated": false
        },
        "allowSimple": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to allow in inlined simple exceptions in the json path expression",
          "title": "Allow Simple",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "jxpath": {
      "type": "object",
      "title": "JXPath",
      "group": "language,java",
      "icon": "generic24.png",
      "description": "For JXPath expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "lenient": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Allows to turn lenient on the JXPathContext. When turned on this allows the JXPath expression to evaluate against expressions and message bodies which may be invalid / missing data. This option is by default false",
          "title": "Lenient",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "language": {
      "type": "object",
      "title": "Language",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "Represents a parameterised language expression which can support any language at runtime using the language attribute.",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "language": {
          "kind": "attribute",
          "type": "string",
          "description": "The name of the language to use",
          "title": "Language",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "method": {
      "type": "object",
      "title": "Bean method",
      "group": "language,core,java",
      "icon": "generic24.png",
      "description": "For expressions and predicates using a java bean (aka method call)",
      "properties": {
        "bean": {
          "kind": "attribute",
          "type": "string",
          "description": "Either a reference or a class name of the bean to use",
          "title": "Bean",
          "required": false,
          "deprecated": true
        },
        "ref": {
          "kind": "attribute",
          "type": "string",
          "description": "Reference to bean to lookup in the registry",
          "title": "Ref",
          "required": false,
          "deprecated": false
        },
        "method": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of method to call",
          "title": "Method",
          "required": false,
          "deprecated": false
        },
        "beanType": {
          "kind": "attribute",
          "type": "string",
          "description": "Class name of the bean to use",
          "title": "Bean Type",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "mvel": {
      "type": "object",
      "title": "MVEL",
      "group": "language,java",
      "icon": "generic24.png",
      "description": "For MVEL expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "ognl": {
      "type": "object",
      "title": "OGNL",
      "group": "language,java",
      "icon": "generic24.png",
      "description": "For OGNL expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "php": {
      "type": "object",
      "title": "PHP",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For PHP expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "python": {
      "type": "object",
      "title": "Python",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For Python expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "ref": {
      "type": "object",
      "title": "Ref",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "For using a custom expression",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "ruby": {
      "type": "object",
      "title": "Ruby",
      "group": "language,script",
      "icon": "generic24.png",
      "description": "For Ruby expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "simple": {
      "type": "object",
      "title": "Simple",
      "group": "language,core,java",
      "icon": "generic24.png",
      "description": "For expressions and predicates using the simple language",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "resultType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name of the result type (type from output)",
          "title": "Result Type",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "spel": {
      "type": "object",
      "title": "SpEL",
      "group": "language,spring",
      "icon": "generic24.png",
      "description": "For Spring Expression Language (SpEL) expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "sql": {
      "type": "object",
      "title": "SQL",
      "group": "language",
      "icon": "generic24.png",
      "description": "For SQL expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "terser": {
      "type": "object",
      "title": "HL7 Terser",
      "group": "language,hl7",
      "icon": "generic24.png",
      "description": "For HL7 terser expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "tokenize": {
      "type": "object",
      "title": "Tokenize",
      "group": "language,core",
      "icon": "generic24.png",
      "description": "For expressions and predicates using a body or header tokenizer",
      "properties": {
        "token": {
          "kind": "attribute",
          "type": "string",
          "description": "The (start) token to use as tokenizer for example \n for a new line token. You can use simple language as the token to support dynamic tokens.",
          "title": "Token",
          "required": true,
          "deprecated": false
        },
        "endToken": {
          "kind": "attribute",
          "type": "string",
          "description": "The end token to use as tokenizer if using start/end token pairs. You can use simple language as the token to support dynamic tokens.",
          "title": "End Token",
          "required": false,
          "deprecated": false
        },
        "inheritNamespaceTagName": {
          "kind": "attribute",
          "type": "string",
          "description": "To inherit namespaces from a root/parent tag name when using XML You can use simple language as the tag name to support dynamic names.",
          "title": "Inherit Namespace Tag Name",
          "required": false,
          "deprecated": false
        },
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of header to tokenize instead of using the message body.",
          "title": "Header Name",
          "required": false,
          "deprecated": false
        },
        "regex": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "If the token is a regular expression pattern. The default value is false",
          "title": "Regex",
          "required": false,
          "deprecated": false
        },
        "xml": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether the input is XML messages. This option must be set to true if working with XML payloads.",
          "title": "Xml",
          "required": false,
          "deprecated": false
        },
        "includeTokens": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to include the tokens in the parts when using pairs The default value is false",
          "title": "Include Tokens",
          "required": false,
          "deprecated": false
        },
        "group": {
          "kind": "attribute",
          "type": "integer",
          "description": "To group N parts together for example to split big files into chunks of 1000 lines.",
          "title": "Group",
          "required": false,
          "deprecated": false
        },
        "skipFirst": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "To skip the very first element",
          "title": "Skip First",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xpath": {
      "type": "object",
      "title": "XPath",
      "group": "language,core,xml",
      "icon": "generic24.png",
      "description": "For XPath expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "documentType": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of class for document type The default value is org.w3c.dom.Document",
          "title": "Document Type",
          "required": false,
          "deprecated": false
        },
        "resultType": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name of the result type (type from output) The default result type is NodeSet",
          "title": "Result Type",
          "required": false,
          "deprecated": false
        },
        "saxon": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to use Saxon.",
          "title": "Saxon",
          "required": false,
          "deprecated": false
        },
        "factoryRef": {
          "kind": "attribute",
          "type": "string",
          "description": "References to a custom XPathFactory to lookup in the registry",
          "title": "Factory Ref",
          "required": false,
          "deprecated": false
        },
        "objectModel": {
          "kind": "attribute",
          "type": "string",
          "description": "The XPath object model to use",
          "title": "Object Model",
          "required": false,
          "deprecated": false
        },
        "logNamespaces": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "false",
          "description": "Whether to log namespaces which can assist during trouble shooting",
          "title": "Log Namespaces",
          "required": false,
          "deprecated": false
        },
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of header to use as input instead of the message body",
          "title": "Header Name",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xquery": {
      "type": "object",
      "title": "XQuery",
      "group": "language,xml",
      "icon": "generic24.png",
      "description": "For XQuery expressions and predicates",
      "properties": {
        "expression": {
          "kind": "value",
          "type": "string",
          "description": "The expression value in your chosen language syntax",
          "title": "Expression",
          "required": true,
          "deprecated": false
        },
        "type": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the class name of the result type (type from output) The default result type is NodeSet",
          "title": "Type",
          "required": false,
          "deprecated": false
        },
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of header to use as input instead of the message body",
          "title": "Header Name",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    },
    "xtokenize": {
      "type": "object",
      "title": "XML Tokenize",
      "group": "language,core,xml",
      "icon": "generic24.png",
      "description": "For expressions and predicates using a body or header tokenizer",
      "properties": {
        "headerName": {
          "kind": "attribute",
          "type": "string",
          "description": "Name of header to tokenize instead of using the message body.",
          "title": "Header Name",
          "required": false,
          "deprecated": false
        },
        "mode": {
          "kind": "attribute",
          "type": "string",
          "description": "The extraction mode. The available extraction modes are: i - injecting the contextual namespace bindings into the extracted token (default) w - wrapping the extracted token in its ancestor context u - unwrapping the extracted token to its child content t - extracting the text content of the specified element",
          "title": "Mode",
          "required": false,
          "deprecated": false
        },
        "group": {
          "kind": "attribute",
          "type": "integer",
          "description": "To group N parts together",
          "title": "Group",
          "required": false,
          "deprecated": false
        },
        "trim": {
          "kind": "attribute",
          "type": "boolean",
          "defaultValue": "true",
          "description": "Whether to trim the value to remove leading and trailing whitespaces and line breaks",
          "title": "Trim",
          "required": false,
          "deprecated": false
        },
        "id": {
          "kind": "attribute",
          "type": "string",
          "description": "Sets the id of this node",
          "title": "Id",
          "required": false,
          "deprecated": false
        }
      }
    }
  }
};

/*****************************************************************************
 * Metrics-Watcher
 *
 * Copyright 2012 Ben Bertola and iovation, Inc.
 *
 * To use this library:
 * 1. Call metricsWatcher.addXXX() for each graph you want on your page
 * 2. Call metricsWatcher.initGraphs() once to draw the initial graphs
 * 3. Call metricsWatcher.updateGraphs(jsonData) with JSON data from your
 *    metrics/servlet as often as you'd like your graphs to update
 *
 *****************************************************************************/

(function(metricsWatcher, $) {

	/**
	 * Add a Gauge type graph to your page.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addGauge = function(divId, className, metricName, title) {
		var metricInfo = new MetricInfo(divId, className, metricName, null, title, 'gauges', null);
		graphs.push(metricInfo);
	};

	/**
	 * Add a Meter type graph to your page.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param max What the max value target is, used to determine the % width of progress bars for this graph
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addMeter = function(divId, className, metricName, max, title, eventType) {
		if (eventType == undefined) eventType = 'Calls';
		var metricInfo = new MetricInfo(divId, className, metricName, max, title, 'meters', eventType);
		metricInfo.eventType = eventType;
		graphs.push(metricInfo);
	};

	/**
	 * Add a Counter graph
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param max What the max value target is, used to determine the % width of progress bars for this graph
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addCounter = function(divId, className, metricName, max, title) {
		var metricInfo = new MetricInfo(divId, className, metricName, max, title, 'counters', null);
		graphs.push(metricInfo);
	};

		/**
	 * Add a standalone Histogram graph
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param max What the max value target is, used to determine the % width of progress bars for this graph
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addHistogram = function(divId, className, metricName, max, title){
		var metricInfo = new MetricInfo(divId, className, metricName, (!max ? 1: max), title, 'histograms', null);
		graphs.push(metricInfo);
	};

	/**
	 * Add a linked Counter graph. Linked Counters differ from a plain counter graph in that both the numerator and denominator
	 * of a linked counter graph each come from individual Counter Metrics.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param maxClassName
	 * @param maxMetricName
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addLinkedCounter = function(divId, className, metricName, maxClassName, maxMetricName, title) {
		var metricInfo = new MetricInfo(divId, className, metricName, null, title, "counters", null);
		if(!metricInfo)
			metricInfo = new MetricInfo(divId, className, metricName, null, title, "timers", null);
		
		metricInfo.maxClassName = maxClassName;
		metricInfo.maxMetricName = maxMetricName;

		metricInfo.getMax = function(json) {
			var maxNode = this.getMetricNode(this.maxClassName, this.maxMetricName, json);
			return maxNode["count"];
		};
		
			metricInfo.getMetricNode = function getMetricNode(className, metricName, jsonRoot) {
				
				var node=!(jsonRoot["counters"][className+'.'+metricName]) ? null : jsonRoot["counters"][className+'.'+metricName];
				if(node){
					return node;
				}else{
					return !(jsonRoot["timers"][className+'.'+metricName]) ? null : jsonRoot["timers"][className+'.'+metricName];
				}
			};

		graphs.push(metricInfo);
	};

	/**
	 * Add a Timer graph. This will include a Meter, Timing Info, and a Histogram.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param metricName The metric name of your metrics data, from the metrics servlet
	 * @param max The max target value for the Meter, showing frequency
	 * @param title The user-displayed title of this graph
	 * @param eventType a name for this event type
	 * @param durationMax The max target value for duration
	 */
	metricsWatcher.addTimer = function(divId, className, metricName, max, title, eventType, durationMax) {
		var timer = addTimerInternal(divId, className, metricName, max, title, eventType, durationMax, false);
		graphs.push(timer);
	};

	/**
	 * Add an ehcache graph.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addCache = function(divId, className, title) {
		var metricInfo = new MetricInfo(divId, className, null, null, title, "caches", null);

		metricInfo.components = {
			gauges : [
				new MetricInfo(null, className, "hits", null, "Hits", "gauges", null),
				new MetricInfo(null, className, "misses", null, "Misses", "gauges", null),
				new MetricInfo(null, className, "objects", null, "Objects", "gauges", null),
				new MetricInfo(null, className, "eviction-count", null, "Eviction Count", "gauges", null),
				new MetricInfo(null, className, "in-memory-hits", null, "In Memory Hits", "gauges", null),
				new MetricInfo(null, className, "in-memory-misses", null, "In Memory Misses", "gauges", null),
				new MetricInfo(null, className, "in-memory-objects", null, "In Memory Objects", "gauges", null),
				new MetricInfo(null, className, "off-heap-hits", null, "Off Heap Hits", "gauges", null),
				new MetricInfo(null, className, "off-heap-misses", null, "Off Heap Misses", "gauges", null),
				new MetricInfo(null, className, "off-heap-objects", null, "Off Heap Objects", "gauges", null),
				new MetricInfo(null, className, "on-disk-hits", null, "On Disk Hits", "gauges", null),
				new MetricInfo(null, className, "on-disk-misses", null, "On Disk Misses", "gauges", null),
				new MetricInfo(null, className, "on-disk-objects", null, "On Disk Objects", "gauges", null),
				new MetricInfo(null, className, "mean-get-time", null, "Mean Get Time", "gauges", null),
				new MetricInfo(null, className, "mean-search-time", null, "Mean Search Time", "gauges", null),
				new MetricInfo(null, className, "searches-per-second", null, "Searches Per Sec", "gauges", null),
				new MetricInfo(null, className, "writer-queue-size", null, "Writer Queue Size", "gauges", null),
				new MetricInfo(null, className, "accuracy", null, "Accuracy", "gauges", null)
			]
		};
		metricInfo.getTimer = addTimerInternal(divId + "gettimer", className, "gets", 5, "Get", "get", 1, true);
		metricInfo.putTimer = addTimerInternal(divId + "puttimer", className, "puts", 5, "Put", "put", 1, true);

		graphs.push(metricInfo);
	};

	/**
	 * Add a JVM graph.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addJvm = function(divId, className, title) {
		var metricInfo = new MetricInfo(divId, className, null, null, title, "jvms", null);
		graphs.push(metricInfo);
	};

	/**
	 * Add a web server graph.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addWeb = function(divId, className, title) {
		var metricInfo = new MetricInfo(divId, className, null, null, title, "webs", null);

		metricInfo.components = {
			meters : [
				new MetricInfo(divId + " td.responseCodesOkGraph", className, "responseCodes.ok", 10, "OK Responses", "meters", null),
				new MetricInfo(divId + " td.responseCodesBadRequestGraph", className, "responseCodes.badRequest", 10, "Bad Requests", "meters", null),
				new MetricInfo(divId + " td.responseCodesCreatedGraph", className, "responseCodes.created", 10, "Created Responses", "meters", null),
				new MetricInfo(divId + " td.responseCodesNoContentGraph", className, "responseCodes.noContent", 10, "No Content Responses", "meters", null),
				new MetricInfo(divId + " td.responseCodesNotFoundGraph", className, "responseCodes.notFound", 10, "Not Found Responses", "meters", null),
				new MetricInfo(divId + " td.responseCodesOtherGraph", className, "responseCodes.other", 10, "Other Responses", "meters", null),
				new MetricInfo(divId + " td.responseCodesServerErrorGraph", className, "responseCodes.serverError", 10, "Server Error Responses", "meters", null)
			],
			activeRequestsInfo : new MetricInfo(divId + " td.activeRequestsGraph", className, "activeRequests", 10, "Active Requests", "counters", null),
			requestsInfo : addTimerInternal(divId + " td.requestsGraph", className, "requests", 100, "Requests", "requests", 100, true)
		};

		graphs.push(metricInfo);
	};

	/**
	 * Add a log4j logged events graph.
	 *
	 * @param divId The id of the div to draw the graph in
	 * @param className The class name of your metrics data, from the metrics servlet
	 * @param title The user-displayed title of this graph
	 */
	metricsWatcher.addLog4j = function(divId, className, title) {
		var metricInfo = new MetricInfo(divId, className, null, null, title, "log4js", null);

		metricInfo.components = {
			meters : [
				new MetricInfo(divId + " td.all", className, "all", 100, "all", "meters", null),
				new MetricInfo(divId + " td.fatal", className, "fatal", 100, "fatal", "meters", null),
				new MetricInfo(divId + " td.error", className, "error", 100, "error", "meters", null),
				new MetricInfo(divId + " td.warn", className, "warn", 100, "warn", "meters", null),
				new MetricInfo(divId + " td.info", className, "info", 100, "info", "meters", null),
				new MetricInfo(divId + " td.debug", className, "debug", 100, "debug", "meters", null),
				new MetricInfo(divId + " td.trace", className, "trace", 100, "trace", "meters", null)
			]
		};

		graphs.push(metricInfo);
	};

	/**
	 * Initialized each of the graphs that you have added through addXXX() calls,
	 * and draws them on the screen for the first time
	 */
	metricsWatcher.initGraphs = function() {
		// draw all graphs for the first time
		for (var i = 0; i < graphs.length; i++) {
			if (graphs[i].type == "gauges")
				drawGauge(graphs[i]);
			else if (graphs[i].type == "meters")
				drawMeter(graphs[i]);
			else if (graphs[i].type == "counters" || graphs[i].type == "linkedTimerCounters")
				drawCounter(graphs[i]);
			else if (graphs[i].type == "histograms")
				drawHistogram(graphs[i]);
			else if (graphs[i].type == "timers")
				drawTimer(graphs[i]);
			else if (graphs[i].type == "caches")
				drawCache(graphs[i]);
			else if (graphs[i].type == "jvms")
				drawJvm(graphs[i]);
			else if (graphs[i].type == "webs")
				drawWeb(graphs[i]);
			else if (graphs[i].type == "log4js")
				drawLog4j(graphs[i]);
			else
				alert("Unknown meter info type: " + graphs[i].type);
		}
	};

	/**
	 * Update the existing graphs with new data. You can call this method as frequently as you would
	 * like to, and all graph info will be updated.
	 *
	 * @param json The root of the json node returned from your ajax call to the metrics servlet
	 */
	metricsWatcher.updateGraphs = function(json) {
		for (var i = 0; i < graphs.length; i++) {
			if (graphs[i].type == "gauges")
				updateGauge(graphs[i], json);
			else if (graphs[i].type == "meters")
				updateMeter(graphs[i], json);
			else if (graphs[i].type == "counters" || graphs[i].type == "linkedTimerCounters")
				updateCounter(graphs[i], json);
			else if (graphs[i].type == "histograms")
				updateHistogram(graphs[i], json);
			else if (graphs[i].type == "timers")
				updateTimer(graphs[i], json);
			else if (graphs[i].type == "caches")
				updateCache(graphs[i], json);
			else if (graphs[i].type == "jvms")
				updateJvm(graphs[i], json);
			else if (graphs[i].type == "webs")
				updateWeb(graphs[i], json);
			else if (graphs[i].type == "log4js")
				updateLog4j(graphs[i], json);
			else
				alert("Unknown meter info type: " + graphs[i].type);
		}
	};

	/*
	 * Private Methods
	 */
	var graphs = [];

  function MetricInfo(divId, className, metricName, max, title, type, subTitle) {
		this.divId = divId;
		this.className = className;
		this.metricName = metricName;
		this.max = max;
		this.title = title;
		this.type = type;
    this.subTitle = subTitle;

		this.getMax = function(json) {
			return this.max;
		};
		this.getMetricNode = function getMetricNode(className, metricName, jsonRoot) {
			return !(jsonRoot[type][className+'.'+metricName]) ? null : jsonRoot[type][className+'.'+metricName];
		};

    this.getSubTitle = function() {
      if (this.subTitle != null) {
        return this.subTitle;
      } else {
        // fallback and use title
        return this.title;
      }
    }
	}

	function calculatePercentage(currentVal, maxVal) {
		var p = (currentVal / maxVal) * 100;
		return p.toFixed(0);
	}

	function formatNumber(varNumber, n) {
		if (isNaN(n)) n = 1;

		return !isNaN(varNumber)?varNumber.toFixed(n):n;
	}

	function capitalizeFirstLetter(input) {
		return input.charAt(0).toUpperCase() + input.slice(1);
	}

	function addTimerInternal(divId, className, metricName, max, title, eventType, durationMax, isNested) {
		var metricInfo = new MetricInfo(divId, className, metricName, max, title, 'timers', eventType);

		metricInfo.getMeterInfo = function() {
			var myDivId = this.divId + " div.timerGraph div.meterGraph";
			var retVal = new MetricInfo(myDivId, this.className, this.metricName, this.max, "Frequency", 'timers', null);

			retVal.getMetricNode = function(className, metricName, jsonRoot) {
				return !jsonRoot['timers'][className+'.'+metricName] ? null : jsonRoot['timers'][className+'.'+metricName];
			};

			retVal.eventType = eventType;
			return retVal;
		};

		metricInfo.getTimerStatsDivId = function() {
			return "#" + this.divId + " div.timerGraph div.timerStatsGraph";
		};
		metricInfo.getTimerHistogramDivId = function() {
			return "#" + this.divId + " div.timerGraph div.timerHistogram";
		};
		metricInfo.durationMax = durationMax;
		metricInfo.isNested = isNested;

		return metricInfo;
	}

	/*
	 * Counter methods
	 */
	function drawCounter(counterInfo) {
		var parentDiv = $("#" + counterInfo.divId);
		var html = "<div class='counter counterGraph'><h3>" + counterInfo.title
				+ "</h3><div class='progress'><div class='progress-bar' style='width: 0%;'></div></div></div>";
		parentDiv.html(html);
	}
	
	function updateCounter(counterInfo, json) {
		var metricData = counterInfo.getMetricNode(counterInfo.className, counterInfo.metricName, json);
		var pct = calculatePercentage(metricData.count, counterInfo.getMax(json));

		$("#" + counterInfo.divId + " div.progress div.progress-bar").css("width", pct + "%");
		$("#" + counterInfo.divId + " div.progress div.progress-bar").html(metricData.count + "/" + counterInfo.getMax(json));
	}

	/*
	 * Timer methods
	 */
	function drawTimer(timerInfo) {
		var parentDiv = $("#" + timerInfo.divId);

		var nested = (timerInfo.isNested) ? " nested" : "";
		var html = 
          '<div class="metricsWatcher timer timerGraph' + nested + '">'
        + '  <div class="panel-group" id="accordion-' + timerInfo.divId + '">'
				+ '    <div class="panel panel-default">'
				+ '      <div class="panel-heading">'
				+ '        <h4 class="panel-title">'
        +            ((timerInfo.isNested)
                       ? '<a>'
                       : '<a data-toggle="collapse" data-parent="accordion-' + timerInfo.divId + '" href="#' + timerInfo.divId + 'Collapse">')
				+            timerInfo.title + '</a>'
				+ '        </h4>'
				+ '      </div>'
				+ '      <div id="' + timerInfo.divId + 'Collapse" class="panel-collapse' + ((timerInfo.isNested) ? '': ' collapse in') + '">'
				+ '        <div class="panel-body">'
				+ '          <div class="meterGraph col-md-12 col-lg-4"></div>'
				+ '          <div class="timerStatsGraph col-md-12 col-lg-4"></div>'
				+ '          <div class="timerHistogram col-md-12 col-lg-4"></div>'
				+ '        </div>'
        + '      </div>'
        + '    </div>'
        + '  </div>'
        + '</div>';
		parentDiv.html(html);

		drawMeter(timerInfo.getMeterInfo());
		drawDurationStats(timerInfo);
		drawDurationHistogram(timerInfo);
	};

	function drawDurationStats(timerInfo) {
		var html = "<h3>Duration</h3><div class='timeUnit'></div><div class='metricGraph'><table class='progressTable'>"
			+ addMeterRow("Min", "min")
			+ addMeterRow("Mean", "mean")
			+ addMeterRow("Max", "max")
			+ addMeterRow("Std&nbsp;Dev", "stddev")
			+ "</table></div>";
		var parentDiv = $(timerInfo.getTimerStatsDivId());
		parentDiv.html(html);
	}

	function drawDurationHistogram(timerInfo) {
		var html = "<h3> " +(timerInfo.isNested?  "Histogram" :timerInfo.getSubTitle()) + "</h3><div>Percentiles</div><div class='metricGraph'><table class='progressTable'>"
			+ addMeterRow("99.9%", "p999")
			+ addMeterRow("99%", "p99")
			+ addMeterRow("98%", "p98")
			+ addMeterRow("95%", "p95")
			+ addMeterRow("75%", "p75")
			+ addMeterRow("50%", "p50")
			+ "</table></div>";
		var parentDiv = $(timerInfo.getTimerHistogramDivId());
		parentDiv.html(html);
	}

	function updateTimer(timerInfo, json) {
		updateMeter(timerInfo.getMeterInfo(), json);
		updateDurationStats(timerInfo, json);
		updateDurationHistogram(timerInfo, json);
	}

	function updateDurationStats(timerInfo, json) {
		var metricNode = timerInfo.getMetricNode(timerInfo.className, timerInfo.metricName, json);
		if (!metricNode) return;

		var timeUnitDiv = $(timerInfo.getTimerStatsDivId() + " div.timeUnit");
		timeUnitDiv.html(capitalizeFirstLetter(metricNode["duration_units"]));

		updateDuration(timerInfo.getTimerStatsDivId(), metricNode, "min", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerStatsDivId(), metricNode, "mean", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerStatsDivId(), metricNode, "max", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerStatsDivId(), metricNode, "stddev", timerInfo.durationMax);
	}

	function updateDuration(timerStatsDivId, durationData, style, max) {
		$(timerStatsDivId + " tr." + style + " td.progressValue").html(formatNumber(durationData[style]));
		$(timerStatsDivId + " tr." + style + " td.progressBar div.progress div.progress-bar")
			.css("width", calculatePercentage(durationData[style], max) + "%");
	}

	function updateDurationHistogram(timerInfo, json) {
		var metricNode = timerInfo.getMetricNode(timerInfo.className, timerInfo.metricName, json);
		if (!metricNode) return;

		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p999", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p99", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p98", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p95", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p75", timerInfo.durationMax);
		updateDuration(timerInfo.getTimerHistogramDivId(), metricNode, "p50", timerInfo.durationMax);
	}

/*
 * Histogram methods
 */

	function drawHistogram(histogramInfo) {
		var parentDiv = $("#" + histogramInfo.divId);
		var html = "<div class='metricsWatcher histogram histogramContainer'>" 
			+ "<div class='heading1 btn-link col-md-12' data-toggle='collapse' data-target='#" + histogramInfo.divId + "Collapse'> " +(histogramInfo.isNested?  "Histogram" :histogramInfo.title) + "</div>" 
			+ "<div class='collapse' id='" + histogramInfo.divId + "Collapse'>"
			+ "<table>" 
				+ "<tr><td class='col-md-4'>Count</td><td class='col-md-4'>Min</td><td class='col-md-4'>Max<td class='col-md-4'>Mean</td></tr>" 
				+ "<tr><td class='countVal'></td><td class='minVal'></td><td class='meanVal'></td><td class='maxVal'></td></tr>"
			+ "</table>"
			+	"<p>Percentiles</p>"
			+"<table class='progressTable'>"
			+ addMeterRow("99.9%", "p999")
			+ addMeterRow("99%", "p99")
			+ addMeterRow("98%", "p98")
			+ addMeterRow("95%", "p95")
			+ addMeterRow("75%", "p75")
			+ addMeterRow("50%", "p50")
			+ "</table></div></div>";
		parentDiv.html(html);
	}

	function updateHistogram(histogramInfo, json) {
		var metricNode = histogramInfo.getMetricNode(histogramInfo.className, histogramInfo.metricName, json);
		$("#" + histogramInfo.divId +  " td.countVal").html(formatNumber(metricNode['count'],0));
		$("#" + histogramInfo.divId +  " td.minVal").html(formatNumber(metricNode['min'],0));
		$("#" + histogramInfo.divId +  " td.maxVal").html(formatNumber(metricNode['max'],0));
		$("#" + histogramInfo.divId +  " td.meanVal").html(formatNumber(metricNode['mean'],0));
		
		setMeterRow(histogramInfo, metricNode, "p999", "p999", histogramInfo.max);
		setMeterRow(histogramInfo, metricNode, "p99", "p99", histogramInfo.max);
		setMeterRow(histogramInfo, metricNode, "p98", "p98", histogramInfo.max);
		setMeterRow(histogramInfo, metricNode, "p95", "p95", histogramInfo.max);
		setMeterRow(histogramInfo, metricNode, "p75", "p75", histogramInfo.max);
		setMeterRow(histogramInfo, metricNode, "p50", "p50", histogramInfo.max);
	}

	/*
	 * Meter methods
	 */
	function drawMeter(meterInfo) {
		var parentDiv = $("#" + meterInfo.divId);

		var html = "<div class='metric metricGraph'><h3>" + meterInfo.title
			+ "</h3><div class='counterVal'></div><table class='progressTable'>"
			+ addMeterRow("1&nbsp;min", "onemin")
			+ addMeterRow("5&nbsp;min", "fivemin")
			+ addMeterRow("15&nbsp;min", "fifteenmin")
			+ addMeterRow("Mean", "mean")
			+ "</table></div>";
		parentDiv.html(html);
	}

	function addMeterRow(type, className) {
		return "<tr class='" + className + "'><td class='progressLabel'>" + type + "</td>"
			+ "<td class='progressBar'><div class='progress'><div class='progress-bar' style='width: 0%;'></div>"
			+ "</div></td><td class='progressValue'>0</td></tr>";
	}

	function updateMeter(meterInfo, json) {
		var metricData = meterInfo.getMetricNode(meterInfo.className, meterInfo.metricName, json);
		if (metricData) {
			updateMeterData(meterInfo, metricData);
		}
	}

	function updateMeterData(meterInfo, meterData) {
		// set the big counter
		var gaugeDiv = $("#" + meterInfo.divId + " div.counterVal");

		gaugeDiv.html(meterData.rate_units + " (" + meterData.count + " total)");

		var maxRate = Math.max(meterData['mean_rate'],meterData['m1_rate'],meterData['m5_rate'],meterData['m15_rate']);

		// set the mean count
		setMeterRow(meterInfo, meterData, "mean_rate", "mean", maxRate);
		setMeterRow(meterInfo, meterData, "m1_rate", "onemin", maxRate);
		setMeterRow(meterInfo, meterData, "m5_rate", "fivemin", maxRate);
		setMeterRow(meterInfo, meterData, "m15_rate", "fifteenmin", maxRate);
	}

	function setMeterRow(meterInfo, meterData, rowType, rowStyle) {
		setMeterRow(meterInfo, meterData, rowType, rowStyle, meterInfo.max);
	}

	function setMeterRow(meterInfo, meterData, rowType, rowStyle, max) {
		$("#" + meterInfo.divId + " tr." + rowStyle + " td.progressValue").html(formatNumber(meterData[rowType]));
		$("#" + meterInfo.divId + " tr." + rowStyle + " td.progressBar div.progress div.progress-bar")
			.css("width", calculatePercentage(meterData[rowType], max) + "%");
	}

	/*
	 * Gauge methods
	 */
	function drawGauge(gaugeInfo) {
		var parentDiv = $("#" + gaugeInfo.divId);
		var html = "<div class='metric metricGraph'><h3>" + gaugeInfo.title + "</h3><div class='gaugeDataVal'></div></div>";
		parentDiv.html(html);
	}
	function updateGauge(gaugeInfo, json) {
		var metricData = gaugeInfo.getMetricNode(gaugeInfo.className, gaugeInfo.metricName, json);
		if (metricData) {
			updateGaugeData(gaugeInfo, metricData);
		}
	}
	function updateGaugeData(gaugeInfo, gaugeData) {
		var gaugeDiv = $("#" + gaugeInfo.divId + " div.gaugeDataVal");
		gaugeDiv.html(gaugeData.value);
	}

	/*
	 * GaugeTable methods
	 */
	function drawGaugeTable(divId, title, gauges) {
		var parentDiv = $("#" + divId);
		var html = "<div class='metricsWatcher metric metricGraph nested'>"
				+ "<fieldset><legend><div class='heading1'>" + title + "</div></legend>"
				+ "<div class='gaugeTableContainer'><table class='gaugeTable'></table></div></fieldset></div>";

		parentDiv.html(html);
	}
	function updateGaugeTable(divId, gauges, json) {
		var div = $("#" + divId + " table");

		var html = "";
		var length = gauges.length;
		for (var i = 0; i < length; i++) {
			var gauge = gauges[i];
			html += "<tr><td><h5>" + gauge.title + "</h5></td>"
				+ "<td><h4>" + gauge.getMetricNode(gauge.className, gauge.metricName, json).value
				+ "</h4></td></tr>";
		}
		div.html(html);
	}

	/*
	 * Cache methods
	 */
	function drawCache(cacheInfo) {
		var parentDiv = $("#" + cacheInfo.divId);

		var html = "<div class='metricsWatcher cache cacheGraph col-md-12'>"
				+ "<fieldset><legend><div class='heading1'>" + cacheInfo.title + "</div></legend>"
				+ "<div class='cacheContainer col-md-12'>"
				+ "	<div class='row'>"
				+ "		<div class='col-md-3'><div id='" + cacheInfo.divId + "Statistics'></div></div>"
				+ "		<div class='col-md-9'>"
				+ "			<div id='" + cacheInfo.divId + "gettimer'></div>"
				+ "			<div id='" + cacheInfo.divId + "puttimer'></div>"
				+ "		</div>"
				+ "	</div>"
				+ "</div></fieldset></div>";
		parentDiv.html(html);

		var length = cacheInfo.components.gauges.length;
		for (var i = 0; i < length; i++) {
			drawGauge(cacheInfo.components.gauges[i]);
		}
		drawTimer(cacheInfo.getTimer);
		drawTimer(cacheInfo.putTimer);
		drawGaugeTable(cacheInfo.divId + "Statistics", "Statistics", cacheInfo.components.gauges);
	}
	function updateCache(cacheInfo, json) {
		var length = cacheInfo.components.gauges.length;
		for (var i = 0; i < length; i++) {
			var gauge = cacheInfo.components.gauges[i];
			var data = gauge.getMetricNode(cacheInfo.className, gauge.metricName, json);
			if (data) {
				var gaugeDiv = $("#" + gauge.divId + " div.metricGraph div.gaugeDataVal");
				gaugeDiv.html(data.value);
			}
		}
		updateTimer(cacheInfo.getTimer, json);
		updateTimer(cacheInfo.putTimer, json);
		updateGaugeTable(cacheInfo.divId + "Statistics", cacheInfo.components.gauges, json);
	}

	/*
	 * JVM methods
	 */
	function drawJvm(jvmInfo) {
		var parentDiv = $("#" + jvmInfo.divId);
		var html = "<div class='metricsWatcher jvm metricGraph col-md-12'>"
				+ "<fieldset><legend><div  class='heading1 btn-link' data-toggle='collapse' data-target='#" + jvmInfo.divId + "Collapse'>" + jvmInfo.title + "</div></legend>"
				+ "<div class='jvmContainer col-md-12 collapse' id='" + jvmInfo.divId + "Collapse'>"
				+ "	<div id='" + jvmInfo.divId + "Vm'></div>"
				+ "</div>"
				+ "</fieldset></div>";
		parentDiv.html(html);
	}

	function updateJvm(jvmInfo, json) {
		var vmDiv = $("#" + jvmInfo.divId + "Vm");
		var jvm = json['gauges'];
		var html = "<div class='row'>"
				+ "<div class='col-md-3'><table class='jvmTable'><caption>Memory</caption>"
				+ "<tr><td><h5>Total Init</h5></td><td>" + jvm['jvm.memory.total.init'].value + "</td></tr>"
				+ "<tr><td><h5>Total Used</h5></td><td>" + jvm['jvm.memory.total.used'].value + "</td></tr>"
				+ "<tr><td><h5>Total Max</h5></td><td>" + jvm['jvm.memory.total.max'].value + "</td></tr>"
				+ "<tr><td><h5>Total Committed</h5></td><td>" + jvm['jvm.memory.total.committed'].value + "</td></tr>"
				+ "<tr><td><h5>Heap Init</h5></td><td>" + jvm['jvm.memory.heap.init'].value + "</td></tr>"
				+ "<tr><td><h5>Heap Used</h5></td><td>" + jvm['jvm.memory.heap.used'].value + "</td></tr>"
				+ "<tr><td><h5>Heap Max</h5></td><td>" + jvm['jvm.memory.heap.max'].value + "</td></tr>"
				+ "<tr><td><h5>Heap Committed</h5></td><td>" + jvm['jvm.memory.heap.committed'].value + "</td></tr>"
				+ "<tr><td><h5>Non Heap Init</h5></td><td>" + jvm['jvm.memory.non-heap.init'].value + "</td></tr>"
				+ "<tr><td><h5>Non Heap Used</h5></td><td>" + jvm['jvm.memory.non-heap.used'].value + "</td></tr>"
				+ "<tr><td><h5>Non Heap Max</h5></td><td>" + jvm['jvm.memory.non-heap.max'].value + "</td></tr>"
				+ "<tr><td><h5>Non Heap Committed</h5></td><td>" + jvm['jvm.memory.non-heap.committed'].value + "</td></tr>"
				+ "</table></div>"
				+ "<div class='col-md-3'><table class='jvmTable'><caption>Memory Usage</caption>"
				+ "<tr><td><h5>Heap Usage</h5></td><td>" + (jvm['jvm.memory.heap.usage'].value * 100).toFixed(2) + "</td></tr>"
				+ "<tr><td><h5>Non Heap Usage</h5></td><td>" + (jvm['jvm.memory.non-heap.usage'].value * 100).toFixed(2) + "</td></tr>"
				+ (!jvm['jvm.memory.pools.JIT-code-cache.usage']?"":("<tr><td><h5>JIT Code Cache Usage</h5></td><td>" + (jvm['jvm.memory.pools.JIT-code-cache.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Code-Cache.usage']?"":("<tr><td><h5>JIT Code Cache Usage</h5></td><td>" + (jvm['jvm.memory.pools.Code-Cache.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.JIT-data-cache.usage']?"":("<tr><td><h5>JIT Data Cache Usage</h5></td><td>" + (jvm['jvm.memory.pools.JIT-data-cache.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Java-heap.usage']?"":("<tr><td><h5>Java Heap Usage</h5></td><td>" + (jvm['jvm.memory.pools.Java-heap.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.class-storage.usage']?"":("<tr><td><h5>Class Storage Usage</h5></td><td>" + (jvm['jvm.memory.pools.class-storage.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Perm-Gen.usage']?"":("<tr><td><h5>Perm Gen Usage</h5></td><td>" + (jvm['jvm.memory.pools.Perm-Gen.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Tenured-Gen.usage']?"":("<tr><td><h5>Tenured Gen Usage</h5></td><td>" + (jvm['jvm.memory.pools.Tenured-Gen.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.miscellaneous-non-heap-storage.usage']?"":("<tr><td><h5>Misc Non Heap Storage Usage</h5></td><td>" + (jvm['jvm.memory.pools.miscellaneous-non-heap-storage.usage'].value * 100).toFixed(2)  + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Survivor-Space.usage']?"":("<tr><td><h5>Survivor Space Usage</h5></td><td>" + (jvm['jvm.memory.pools.Survivor-Space.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+ (!jvm['jvm.memory.pools.Eden-Space.usage']?"":("<tr><td><h5>Eden Space Usage</h5></td><td>" + (jvm['jvm.memory.pools.Eden-Space.usage'].value * 100).toFixed(2) + "</td></tr>"))
				+"</table></div>"
				+ "<div class='col-md-3'><table class='jvmTable'><caption>Garbage Collection</caption>"
				+ "<tr><td><h5>PS Mark Sweep Runs</h5></td><td>" + jvm['jvm.gc.MarkSweepCompact.count'].value + "</td></tr>"
				+ "<tr><td><h5>PS Mark Sweep Time</h5></td><td>" + jvm['jvm.gc.MarkSweepCompact.time'].value + "</td></tr>"
				+ "<tr><td><h5>GC Copy Runs</h5></td><td>" + jvm['jvm.gc.Copy.count'].value + "</td></tr>"
				+ "<tr><td><h5>GC Copy Time</h5></td><td>" + jvm['jvm.gc.Copy.time'].value + "</td></tr>"
				+ "</table></div>"
				+ "<div class='col-md-3'><table class='jvmTable'><caption>Threads</caption>"
//				+ "<tr><td class='rowName'><h5>Name</h5></td><td>" + jvm['jvm.vm.name'].value + "</td></tr>"
//				+ "<tr><td><h5>Version</h5></td><td>" + jvm['jvm.vm.version'].value + "</td></tr>"
//				+ "<tr><td><h5>Current Time</h5></td><td>" + jvm['jvm.current_time'].value + "</td></tr>"
//				+ "<tr><td><h5>Uptime</h5></td><td>" + jvm['jvm.uptime'].value + "</td></tr>"
				+ "<tr><td><h5>FD Usage</h5></td><td>" + formatNumber(jvm['jvm.fd.usage'].value, 2) + "</td></tr>"
				+ "<tr><td><h5>Daemon Threads</h5></td><td>" + jvm['jvm.thread-states.daemon.count'].value + "</td></tr>"
				+ "<tr><td><h5>Threads</h5></td><td>" + jvm['jvm.thread-states.count'].value + "</td></tr>"
				+ "<tr><td><h5>Deadlocks</h5></td><td>" + jvm['jvm.thread-states.deadlocks'].value + "</td></tr>"
				+ "</table><table class='jvmTable'><caption>Thread States</caption>"
				+ "<tr><td><h5>Terminated</h5></td><td>" + jvm['jvm.thread-states.terminated.count'].value + "</td></tr>"
				+ "<tr><td><h5>Timed Waiting</h5></td><td>" + jvm['jvm.thread-states.timed_waiting.count'].value + "</td></tr>"
				+ "<tr><td><h5>Blocked</h5></td><td>" + jvm['jvm.thread-states.blocked.count'].value + "</td></tr>"
				+ "<tr><td><h5>Waiting</h5></td><td>" + jvm['jvm.thread-states.waiting.count'].value + "</td></tr>"
				+ "<tr><td><h5>Runnable</h5></td><td>" + jvm['jvm.thread-states.runnable.count'].value + "</td></tr>"
				+ "<tr><td><h5>New</h5></td><td>" + jvm['jvm.thread-states.new.count'].value + "</td></tr>"
				+ "</table></div></div>";

		vmDiv.html(html);
	};

	/*
	 * Web Server methods
	 */
	function drawWeb(webInfo) {
		var parentDiv = $("#" + webInfo.divId);
		var html = "<div class='metricsWatcher web metricGraph col-md-12'>"
				+ "<fieldset><legend><div class='heading1 btn-link' data-toggle='collapse' data-target='#"+webInfo.divId+"Collapse'>" + webInfo.title + "</div></legend>"
				+ "<div class='webContainer col-md-12' id='"+webInfo.divId+"Collapse'>"
				+ "	<div id='" + webInfo.divId + "Web'></div>"
				+ "<table><tr>"
				+ "<td colspan='4' class='requestsGraph col-md-12'></td>"
				+ "</tr><tr>"
				+ "<td class='activeRequestsGraph col-md-3'></td>"
				+ "<td class='responseCodesOkGraph col-md-3'></td>"
				+ "<td class='responseCodesCreatedGraph col-md-3'></td>"
				+ "<td class='responseCodesOtherGraph col-md-3'></td>"
				+ "</tr><tr>"
				+ "<td class='responseCodesBadRequestGraph col-md-3'></td>"
				+ "<td class='responseCodesNoContentGraph col-md-3'></td>"
				+ "<td class='responseCodesNotFoundGraph col-md-3'></td>"
				+ "<td class='responseCodesServerErrorGraph col-md-3'></td>"
				+ "</tr></table>"
				+ "</div>"
				+ "</fieldset></div>";
		parentDiv.html(html);

		drawTimer(webInfo.components.requestsInfo);
		drawCounter(webInfo.components.activeRequestsInfo);

		var length = webInfo.components.meters.length;
		for (var i = 0; i < length; i++) {
			drawMeter(webInfo.components.meters[i]);
		}
	};

	function updateWeb(webInfo, json) {
		updateTimer(webInfo.components.requestsInfo, json);
		updateCounter(webInfo.components.activeRequestsInfo, json);

		var length = webInfo.components.meters.length;
		for (var i = 0; i < length; i++) {
			updateMeter(webInfo.components.meters[i], json);
		}
	};

	/*
	 * Log4j events stream  methods
	 */
	function drawLog4j(log4jInfo) {
		var parentDiv = $("#" + log4jInfo.divId);
		var html = "<div class='metricsWatcher log4j metricGraph col-md-12'>"
				+ "<fieldset><legend><div class='heading1 btn-link' data-toggle='collapse' data-target='#"+log4jInfo.divId+"Collapse'>" + log4jInfo.title + "</div></legend>"
				+ "<div class='log4jContainer col-md-12' id='"+log4jInfo.divId+"Collapse'>"
				+ "	<div id='" + log4jInfo.divId + "Log4j'></div>"
				+ "<table><tr>"
				+ "<td colspan='4' class='col-md-12'></td>"
				+ "</tr><tr>"
				+ "<td class='all col-md-3'></td>"
				+ "<td class='fatal col-md-3'></td>"
				+ "<td class='error col-md-3'></td>"
				+ "<td class='warn col-md-3'></td>"
				+ "</tr><tr>"
				+ "<td class='info col-md-3'></td>"
				+ "<td class='debug col-md-3'></td>"
				+ "<td class='trace col-md-3'></td>"
				+ "</tr></table>"
				+ "</div>"
				+ "</fieldset></div>";
		parentDiv.html(html);

		var length = log4jInfo.components.meters.length;
		for (var i = 0; i < length; i++) {
			drawMeter(log4jInfo.components.meters[i]);
		}
	};

	function updateLog4j(log4jInfo, json) {
		var length = log4jInfo.components.meters.length;
		for (var i = 0; i < length; i++) {
			updateMeter(log4jInfo.components.meters[i], json);
		}
	};

}(window.metricsWatcher = window.metricsWatcher || {}, jQuery));

var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.log = Logger.get("ActiveMQ");
    ActiveMQ.jmxDomain = 'org.apache.activemq';
    function findFolder(node, titles, ascend) {
        if (!node) {
            return null;
        }
        var answer = null;
        angular.forEach(titles, function (title) {
            if (node.text === title) {
                answer = node;
            }
        });
        if (answer === null) {
            if (ascend) {
                var parent = node.parent;
                if (parent) {
                    answer = findFolder(parent, titles, ascend);
                }
            }
            else {
                // retrieves only one level down for children
                angular.forEach(node.children, function (child) {
                    angular.forEach(titles, function (title) {
                        if (child.text === title) {
                            answer = child;
                        }
                    });
                });
            }
        }
        return answer;
    }
    function retrieveQueueNames(workspace, ascend) {
        var selection = workspace.selection;
        var queueFolder = selection ? findFolder(selection, ["Queues", "Queue"], ascend) : null;
        return queueFolder ? queueFolder.children.map(function (n) { return n.text; }) : [];
    }
    ActiveMQ.retrieveQueueNames = retrieveQueueNames;
    function retrieveTopicNames(workspace, ascend) {
        var selection = workspace.selection;
        var topicFolder = selection ? findFolder(selection, ["Topics", "Topic"], ascend) : null;
        return topicFolder ? topicFolder.children.map(function (n) { return n.text; }) : [];
    }
    ActiveMQ.retrieveTopicNames = retrieveTopicNames;
    /**
     * Sets $scope.row to currently selected JMS message.
     * Used in:
     *  - activemq/js/browse.ts
     *  - camel/js/browseEndpoint.ts
     *
     * TODO: remove $scope argument and operate directly on other variables. but it's too much side effects here...
     *
     * @param message
     * @param key unique key inside message that distinguishes between values
     * @param $scope
     */
    function selectCurrentMessage(message, key, $scope) {
        // clicking on message's link would interfere with messages selected with checkboxes
        if ('selectAll' in $scope.gridOptions) {
            $scope.gridOptions.selectAll(false);
        }
        else {
            $scope.gridOptions.selectedItems.length = 0;
        }
        var idx = Core.pathGet(message, ["rowIndex"]) || Core.pathGet(message, ['index']);
        var jmsMessageID = Core.pathGet(message, ["entity", key]);
        $scope.rowIndex = idx;
        var selected = $scope.gridOptions.selectedItems;
        selected.splice(0, selected.length);
        if (idx >= 0 && idx < $scope.messages.length) {
            $scope.row = _.find($scope.messages, function (msg) { return msg[key] === jmsMessageID; });
            if ($scope.row) {
                selected.push($scope.row);
            }
        }
        else {
            $scope.row = null;
        }
    }
    ActiveMQ.selectCurrentMessage = selectCurrentMessage;
    /**
     * - Adds functions needed for message browsing with details
     * - Adds a watch to deselect all rows after closing the slideout with message details
     * TODO: export these functions too?
     *
     * @param $scope
     * @param fn optional function to call if the selected row was changed
     */
    function decorate($scope, fn) {
        if (fn === void 0) { fn = null; }
        $scope.selectRowIndex = function (idx) {
            $scope.rowIndex = idx;
            var selected = $scope.gridOptions.selectedItems;
            selected.splice(0, selected.length);
            if (idx >= 0 && idx < $scope.messages.length) {
                $scope.row = $scope.messages[idx];
                if ($scope.row) {
                    selected.push($scope.row);
                }
            }
            else {
                $scope.row = null;
            }
            if (fn) {
                fn.apply();
            }
        };
        $scope.$watch("showMessageDetails", function () {
            if (!$scope.showMessageDetails) {
                $scope.row = null;
                $scope.gridOptions.selectedItems.splice(0, $scope.gridOptions.selectedItems.length);
            }
        });
    }
    ActiveMQ.decorate = decorate;
    function getBrokerMBean(workspace, jolokia, jmxDomain) {
        var mbean = null;
        var selection = workspace.selection;
        if (selection && ActiveMQ.isBroker(workspace) && selection.objectName) {
            return selection.objectName;
        }
        var folderNames = selection.folderNames;
        var parent = selection ? selection.parent : null;
        if (selection && parent && jolokia && folderNames && folderNames.length > 1) {
            mbean = parent.objectName;
            // we might be a destination, so lets try one more parent
            if (!mbean && parent) {
                mbean = parent.parent.objectName;
            }
            if (!mbean) {
                mbean = "" + folderNames[0] + ":BrokerName=" + folderNames[1] + ",Type=Broker";
            }
        }
        return mbean;
    }
    ActiveMQ.getBrokerMBean = getBrokerMBean;
    ;
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="../activemqHelpers.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    var DestinationController = /** @class */ (function () {
        DestinationController.$inject = ["$scope", "workspace", "$location", "jolokia", "localStorage"];
        function DestinationController($scope, workspace, $location, jolokia, localStorage) {
            'ngInject';
            this.$scope = $scope;
            this.workspace = workspace;
            this.$location = $location;
            this.jolokia = jolokia;
            this.localStorage = localStorage;
            this.log = Logger.get("ActiveMQ");
            this.buttonNameLimit = 30;
            this.amqJmxDomain = this.localStorage['activemqJmxDomain'] || "org.apache.activemq";
            this.message = "";
            this.destinationName = "";
            this.destinationType = "Queue";
            this.createDialog = false;
            this.deleteDialog = false;
            this.purgeDialog = false;
        }
        DestinationController.prototype.operationSuccess = function () {
            this.destinationName = "";
            this.workspace.operationCounter += 1;
            Core.notification("success", this.message);
            this.workspace.loadTree();
            Core.$apply(this.$scope);
        };
        DestinationController.prototype.deleteSuccess = function () {
            // lets set the selection to the parent
            this.workspace.removeAndSelectParentNode();
            this.workspace.operationCounter += 1;
            Core.notification("success", this.message);
            // and switch to show the attributes (table view)
            this.$location.path('/jmx/attributes').search({ "main-tab": "activemq", "sub-tab": "activemq-attributes" });
            this.workspace.loadTree();
            Core.$apply(this.$scope);
        };
        DestinationController.prototype.validateDestinationName = function (name) {
            return name.indexOf(":") === -1;
        };
        DestinationController.prototype.isQueue = function (destinationType) {
            return destinationType === "Queue";
        };
        DestinationController.prototype.checkIfDestinationExists = function (name, destinationType) {
            var answer = false;
            var destinations;
            if (this.isQueue(destinationType)) {
                destinations = ActiveMQ.retrieveQueueNames(this.workspace, false);
            }
            else {
                destinations = ActiveMQ.retrieveTopicNames(this.workspace, false);
            }
            angular.forEach(destinations, function (destination) {
                if (name === destination) {
                    answer = true;
                }
            });
            return answer;
        };
        DestinationController.prototype.validateAndCreateDestination = function (name, destinationType) {
            if (!this.validateDestinationName(name)) {
                this.createDialog = true;
                return;
            }
            if (this.checkIfDestinationExists(name, destinationType)) {
                Core.notification("error", "The " + this.uncapitalisedDestinationType() + " \"" + name + "\" already exists");
                return;
            }
            this.createDestination(name, destinationType);
        };
        DestinationController.prototype.createDestination = function (name, destinationType) {
            var _this = this;
            var mbean = ActiveMQ.getBrokerMBean(this.workspace, this.jolokia, this.amqJmxDomain);
            name = Core.escapeHtml(name);
            if (mbean) {
                var operation = void 0;
                if (this.isQueue(destinationType)) {
                    operation = "addQueue(java.lang.String)";
                    this.message = "Created queue \"" + name + "\"";
                }
                else {
                    operation = "addTopic(java.lang.String)";
                    this.message = "Created topic \"" + name + "\"";
                }
                if (mbean) {
                    this.jolokia.execute(mbean, operation, name, Core.onSuccess(function () { return _this.operationSuccess(); }));
                }
                else {
                    Core.notification("error", "Could not find the Broker MBean!");
                }
            }
        };
        /**
         * When destination name contains "_" like "aaa_bbb", the actual name might be either
         * "aaa_bbb" or "aaa:bbb", so the actual name needs to be checked before removal.
         * @param name destination name
         */
        DestinationController.prototype.restoreRealDestinationName = function (name) {
            if (name.indexOf("_") === -1) {
                return name;
            }
            return this.jolokia.getAttribute(this.workspace.getSelectedMBeanName(), "Name", Core.onSuccess(null));
        };
        DestinationController.prototype.deleteDestination = function () {
            var _this = this;
            var mbean = ActiveMQ.getBrokerMBean(this.workspace, this.jolokia, this.amqJmxDomain);
            var selection = this.workspace.selection;
            var entries = selection.entries;
            if (mbean && selection && this.jolokia && entries) {
                var domain = selection.domain;
                var name_1 = entries["Destination"] || entries["destinationName"] || selection.text;
                var operation = void 0;
                if (this.isQueue(entries["Type"] || entries["destinationType"])) {
                    operation = "removeQueue(java.lang.String)";
                    this.message = "Deleted queue \"" + name_1 + "\"";
                }
                else {
                    operation = "removeTopic(java.lang.String)";
                    this.message = "Deleted topic \"" + name_1 + "\"";
                }
                name_1 = this.restoreRealDestinationName(name_1);
                // do not unescape name for destination deletion
                this.jolokia.execute(mbean, operation, name_1, Core.onSuccess(function () { return _this.deleteSuccess(); }));
            }
        };
        DestinationController.prototype.purgeDestination = function () {
            var _this = this;
            var mbean = this.workspace.getSelectedMBeanName();
            var selection = this.workspace.selection;
            var entries = selection.entries;
            if (mbean && selection && this.jolokia && entries) {
                var name_2 = entries["Destination"] || entries["destinationName"] || selection.text;
                var operation = "purge()";
                this.message = "Purged queue \"" + name_2 + "\"";
                // unescape should be done right before invoking jolokia
                name_2 = _.unescape(name_2);
                this.jolokia.execute(mbean, operation, Core.onSuccess(function () { return _this.operationSuccess(); }));
            }
        };
        DestinationController.prototype.selectedShortName = function () {
            var name = this.selectedName();
            if (name === null) {
                return null;
            }
            var ellipsis = name.length > this.buttonNameLimit ? "..." : "";
            return name ? name.substring(0, this.buttonNameLimit) + ellipsis : null;
        };
        DestinationController.prototype.selectedName = function () {
            var selection = this.workspace.selection;
            return selection ? _.unescape(selection.text) : null;
        };
        DestinationController.prototype.uncapitalisedDestinationType = function () {
            return this.destinationType.charAt(0).toLowerCase() + this.destinationType.substring(1);
        };
        return DestinationController;
    }());
    ActiveMQ.DestinationController = DestinationController;
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="destination.controller.ts"/>
/// <reference path="../activemqHelpers.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.createDestinationComponent = {
        controller: ActiveMQ.DestinationController,
        templateUrl: 'plugins/activemq/html/createDestination.html'
    };
    ActiveMQ.deleteQueueComponent = {
        controller: ActiveMQ.DestinationController,
        templateUrl: 'plugins/activemq/html/deleteQueue.html'
    };
    ActiveMQ.deleteTopicComponent = {
        controller: ActiveMQ.DestinationController,
        templateUrl: 'plugins/activemq/html/deleteTopic.html'
    };
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="destination.component.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.destinationModule = angular
        .module('hawtio-activemq-destination', [])
        .component('createDestination', ActiveMQ.createDestinationComponent)
        .component('deleteQueue', ActiveMQ.deleteQueueComponent)
        .component('deleteTopic', ActiveMQ.deleteTopicComponent)
        .name;
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="destination/destination.module.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.pluginName = 'activemq';
    ActiveMQ._module = angular.module(ActiveMQ.pluginName, [
        'angularResizable',
        ActiveMQ.destinationModule
    ]);
    ActiveMQ._module.config(["$routeProvider", function ($routeProvider) {
            $routeProvider.
                when('/activemq/browseQueue', { templateUrl: 'plugins/activemq/html/browseQueue.html' }).
                when('/activemq/createDestination', { template: '<create-destination></create-destination>' }).
                when('/activemq/deleteQueue', { template: '<delete-queue></delete-queue>' }).
                when('/activemq/deleteTopic', { template: '<delete-topic></delete-topic>' }).
                when('/activemq/sendMessage', { templateUrl: 'plugins/camel/html/sendMessage.html' }).
                when('/activemq/durableSubscribers', { templateUrl: 'plugins/activemq/html/durableSubscribers.html' }).
                when('/activemq/jobs', { templateUrl: 'plugins/activemq/html/jobs.html' }).
                when('/activemq/queues', { templateUrl: 'app/activemq/html/destinations.html' }).
                when('/activemq/topics', { templateUrl: 'app/activemq/html/destinations.html', controller: 'topicsController' });
        }]);
    ActiveMQ._module.controller('topicsController', ["$scope", function ($scope) {
        $scope.destinationType = 'topic';
    }]);
    ActiveMQ._module.run(["HawtioNav", "$location", "workspace", "viewRegistry", "helpRegistry", "preferencesRegistry", "$templateCache", "documentBase", function (nav, $location, workspace, viewRegistry, helpRegistry, preferencesRegistry, $templateCache, documentBase) {
            viewRegistry['{ "main-tab": "activemq" }'] = 'plugins/activemq/html/layoutActiveMQTree.html';
            helpRegistry.addUserDoc('activemq', 'plugins/activemq/doc/help.md', function () {
                return workspace.treeContainsDomainAndProperties("org.apache.activemq");
            });
            preferencesRegistry.addTab("ActiveMQ", "plugins/activemq/html/preferences.html", function () {
                return workspace.treeContainsDomainAndProperties("org.apache.activemq");
            });
            workspace.addTreePostProcessor(postProcessTree);
            // register default attribute views
            var attributes = workspace.attributeColumnDefs;
            attributes[ActiveMQ.jmxDomain + "/Broker/folder"] = [
                { field: 'BrokerName', displayName: 'Name', width: "**" },
                { field: 'TotalProducerCount', displayName: 'Producer' },
                { field: 'TotalConsumerCount', displayName: 'Consumer' },
                { field: 'StorePercentUsage', displayName: 'Store %' },
                { field: 'TempPercentUsage', displayName: 'Temp %' },
                { field: 'MemoryPercentUsage', displayName: 'Memory %' },
                { field: 'TotalEnqueueCount', displayName: 'Enqueue' },
                { field: 'TotalDequeueCount', displayName: 'Dequeue' }
            ];
            attributes[ActiveMQ.jmxDomain + "/Queue/folder"] = [
                { field: 'Name', displayName: 'Name', width: "***" },
                { field: 'QueueSize', displayName: 'Queue Size' },
                { field: 'ProducerCount', displayName: 'Producer' },
                { field: 'ConsumerCount', displayName: 'Consumer' },
                { field: 'EnqueueCount', displayName: 'Enqueue' },
                { field: 'DequeueCount', displayName: 'Dequeue' },
                { field: 'MemoryPercentUsage', displayName: 'Memory %' },
                { field: 'DispatchCount', displayName: 'Dispatch', visible: false }
            ];
            attributes[ActiveMQ.jmxDomain + "/Topic/folder"] = [
                { field: 'Name', displayName: 'Name', width: "****" },
                { field: 'ProducerCount', displayName: 'Producer' },
                { field: 'ConsumerCount', displayName: 'Consumer' },
                { field: 'EnqueueCount', displayName: 'Enqueue' },
                { field: 'DequeueCount', displayName: 'Dequeue' },
                { field: 'MemoryPercentUsage', displayName: 'Memory %' },
                { field: 'DispatchCount', displayName: 'Dispatch', visible: false }
            ];
            attributes[ActiveMQ.jmxDomain + "/Consumer/folder"] = [
                { field: 'ConnectionId', displayName: 'Name', width: "**" },
                { field: 'PrefetchSize', displayName: 'Prefetch Size' },
                { field: 'Priority', displayName: 'Priority' },
                { field: 'DispatchedQueueSize', displayName: 'Dispatched Queue #' },
                { field: 'SlowConsumer', displayName: 'Slow ?' },
                { field: 'Retroactive', displayName: 'Retroactive' },
                { field: 'Selector', displayName: 'Selector' }
            ];
            attributes[ActiveMQ.jmxDomain + "/networkConnectors/folder"] = [
                { field: 'Name', displayName: 'Name', width: "**" },
                { field: 'UserName', displayName: 'User Name' },
                { field: 'PrefetchSize', displayName: 'Prefetch Size' },
                { field: 'ConduitSubscriptions', displayName: 'Conduit Subscriptions?' },
                { field: 'Duplex', displayName: 'Duplex' },
                { field: 'DynamicOnly', displayName: 'Dynamic Only' }
            ];
            attributes[ActiveMQ.jmxDomain + "/PersistenceAdapter/folder"] = [
                { field: 'IndexDirectory', displayName: 'Index Directory', width: "**" },
                { field: 'LogDirectory', displayName: 'Log Directory', width: "**" }
            ];
            var tab = nav.builder().id('activemq')
                .title(function () { return 'ActiveMQ'; })
                .defaultPage({
                rank: 15,
                isValid: function (yes, no) { return workspace.treeContainsDomainAndProperties(ActiveMQ.jmxDomain) ? yes() : no(); }
            })
                .href(function () { return '/jmx/attributes'; })
                .isValid(function () { return workspace.treeContainsDomainAndProperties(ActiveMQ.jmxDomain); })
                .isSelected(function () { return workspace.isMainTabActive('activemq'); })
                .build();
            nav.add(tab);
            function postProcessTree(tree) {
                var activemq = tree.get("org.apache.activemq");
                setConsumerType(activemq);
                // lets move queue and topic as first children within brokers
                if (activemq) {
                    angular.forEach(activemq.children, function (broker) {
                        angular.forEach(broker.children, function (child) {
                            // lets move Topic/Queue to the front.
                            var grandChildren = child.children;
                            if (grandChildren) {
                                var names = ["Topic", "Queue"];
                                angular.forEach(names, function (name) {
                                    var idx = _.findIndex(grandChildren, function (n) { return n.text === name; });
                                    if (idx > 0) {
                                        var old = grandChildren[idx];
                                        grandChildren.splice(idx, 1);
                                        grandChildren.splice(0, 0, old);
                                    }
                                });
                            }
                        });
                    });
                }
            }
            function setConsumerType(node) {
                if (node) {
                    var parent = node.parent;
                    var entries = node.entries;
                    if (parent && !parent.typeName && entries) {
                        var endpoint = entries["endpoint"];
                        if (endpoint === "Consumer" || endpoint === "Producer") {
                            parent.typeName = endpoint;
                        }
                        var connectorName = entries["connectorName"];
                        if (connectorName && !node.icon) {
                            // lets default a connector icon
                            node.icon = UrlHelpers.join(documentBase, "/img/icons/activemq/connector.png");
                        }
                    }
                    angular.forEach(node.children, function (child) { return setConsumerType(child); });
                }
            }
        }]);
    hawtioPluginLoader.addModule(ActiveMQ.pluginName);
    function getBroker(workspace) {
        var answer = null;
        var selection = workspace.selection;
        if (selection) {
            answer = selection.findAncestor(function (current) {
                // log.debug("Checking current: ", current);
                var entries = current.entries;
                if (entries) {
                    return (('type' in entries && entries.type === 'Broker') && 'brokerName' in entries && !('destinationName' in entries) && !('destinationType' in entries));
                }
                else {
                    return false;
                }
            });
        }
        return answer;
    }
    ActiveMQ.getBroker = getBroker;
    function isQueue(workspace) {
        //return workspace.selectionHasDomainAndType(jmxDomain, 'Queue');
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'destinationType': 'Queue' }, 4) || workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Queue');
    }
    ActiveMQ.isQueue = isQueue;
    function isTopic(workspace) {
        //return workspace.selectionHasDomainAndType(jmxDomain, 'Topic');
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'destinationType': 'Topic' }, 4) || workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Topic');
    }
    ActiveMQ.isTopic = isTopic;
    function isQueuesFolder(workspace) {
        return workspace.selectionHasDomainAndLastFolderName(ActiveMQ.jmxDomain, 'Queue');
    }
    ActiveMQ.isQueuesFolder = isQueuesFolder;
    function isTopicsFolder(workspace) {
        return workspace.selectionHasDomainAndLastFolderName(ActiveMQ.jmxDomain, 'Topic');
    }
    ActiveMQ.isTopicsFolder = isTopicsFolder;
    function isJobScheduler(workspace) {
        return workspace.hasDomainAndProperties(ActiveMQ.jmxDomain, { 'service': 'JobScheduler' }, 4);
    }
    ActiveMQ.isJobScheduler = isJobScheduler;
    function isBroker(workspace) {
        if (workspace.selectionHasDomainAndType(ActiveMQ.jmxDomain, 'Broker')) {
            var self = Core.pathGet(workspace, ["selection"]);
            var parent = Core.pathGet(workspace, ["selection", "parent"]);
            return !(parent && (parent.ancestorHasType('Broker') || self.ancestorHasType('Broker')));
        }
        return false;
    }
    ActiveMQ.isBroker = isBroker;
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ.BrowseQueueController = ActiveMQ._module.controller("ActiveMQ.BrowseQueueController", ["$scope", "workspace", "jolokia", "localStorage", '$location', "activeMQMessage", "$timeout", "$routeParams", "$dialog", "$templateCache", function ($scope, workspace, jolokia, localStorage, $location, activeMQMessage, $timeout, $routeParams, $dialog, $templateCache) {
            var amqJmxDomain = localStorage['activemqJmxDomain'] || "org.apache.activemq";
            // all the queue names from the tree
            $scope.queueNames = [];
            // selected queue name in move dialog
            $scope.queueName = $routeParams["queueName"];
            $scope.searchText = '';
            $scope.workspace = workspace;
            $scope.allMessages = [];
            $scope.messages = [];
            $scope.headers = {};
            $scope.mode = 'text';
            $scope.showButtons = true;
            $scope.deleteDialog = false;
            $scope.moveDialog = false;
            $scope.gridOptions = {
                selectedItems: [],
                data: 'messages',
                displayFooter: false,
                showFilter: false,
                showColumnMenu: true,
                enableColumnResize: true,
                enableColumnReordering: true,
                enableHighlighting: true,
                filterOptions: {
                    filterText: '',
                    useExternalFilter: true
                },
                selectWithCheckboxOnly: true,
                showSelectionCheckbox: true,
                maintainColumnRatios: false,
                columnDefs: [
                    {
                        field: 'JMSMessageID',
                        displayName: 'Message ID',
                        cellTemplate: '<div class="ngCellText"><a href="" ng-click="row.entity.openMessageDialog(row)">{{row.entity.JMSMessageID}}</a></div>',
                        // for ng-grid
                        width: '34%'
                        // for hawtio-datatable
                        // width: "22em"
                    },
                    {
                        field: 'JMSType',
                        displayName: 'Type',
                        width: '10%'
                    },
                    {
                        field: 'JMSPriority',
                        displayName: 'Priority',
                        width: '7%'
                    },
                    {
                        field: 'JMSTimestamp',
                        displayName: 'Timestamp',
                        width: '19%'
                    },
                    {
                        field: 'JMSExpiration',
                        displayName: 'Expires',
                        width: '10%'
                    },
                    {
                        field: 'JMSReplyTo',
                        displayName: 'Reply To',
                        width: '10%'
                    },
                    {
                        field: 'JMSCorrelationID',
                        displayName: 'Correlation ID',
                        width: '10%'
                    }
                ],
                primaryKeyFn: function (entity) { return entity.JMSMessageID; }
            };
            $scope.showMessageDetails = false;
            // openMessageDialog is for the dialog itself so we should skip that guy
            var ignoreColumns = ["PropertiesText", "BodyPreview", "Text", "openMessageDialog"];
            var flattenColumns = ["BooleanProperties", "ByteProperties", "ShortProperties", "IntProperties", "LongProperties", "FloatProperties",
                "DoubleProperties", "StringProperties"];
            $scope.$watch('gridOptions.filterOptions.filterText', function (filterText) {
                filterMessages(filterText);
            });
            $scope.openMessageDialog = function (message) {
                ActiveMQ.selectCurrentMessage(message, "JMSMessageID", $scope);
                if ($scope.row) {
                    $scope.mode = CodeEditor.detectTextFormat($scope.row.Text);
                    $scope.showMessageDetails = true;
                }
            };
            $scope.refresh = loadTable;
            ActiveMQ.decorate($scope);
            $scope.moveMessages = function () {
                var selection = workspace.selection;
                var mbean = selection.objectName;
                if (!mbean || !selection || !$scope.queueName) {
                    return;
                }
                var selectedItems = $scope.gridOptions.selectedItems;
                $scope.message = "Moved " + Core.maybePlural(selectedItems.length, "message") + " to " + $scope.queueName;
                var operation = "moveMessageTo(java.lang.String, java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.JMSMessageID;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : moveSuccess;
                        jolokia.execute(mbean, operation, id, $scope.queueName, Core.onSuccess(callback));
                    }
                });
            };
            $scope.resendMessage = function () {
                var selection = workspace.selection;
                var mbean = selection.objectName;
                if (mbean && selection) {
                    var selectedItems = $scope.gridOptions.selectedItems;
                    //always assume a single message
                    activeMQMessage.message = selectedItems[0];
                    $location.path('activemq/sendMessage');
                }
            };
            $scope.deleteMessages = function () {
                var selection = workspace.selection;
                var mbean = selection.objectName;
                if (!mbean || !selection) {
                    return;
                }
                var selectedItems = $scope.gridOptions.selectedItems;
                if (!selectedItems || selectedItems.length === 0) {
                    return;
                }
                $scope.message = "Deleted " + Core.maybePlural(selectedItems.length, "message");
                var operation = "removeMessage(java.lang.String)";
                angular.forEach(selectedItems, function (item, idx) {
                    var id = item.JMSMessageID;
                    if (id) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                        jolokia.execute(mbean, operation, id, Core.onSuccess(callback));
                    }
                });
            };
            $scope.retryMessages = function () {
                var selection = workspace.selection;
                var mbean = selection.objectName;
                if (mbean && selection) {
                    var selectedItems = $scope.gridOptions.selectedItems;
                    $scope.message = "Retry " + Core.maybePlural(selectedItems.length, "message");
                    var operation = "retryMessage(java.lang.String)";
                    angular.forEach(selectedItems, function (item, idx) {
                        var id = item.JMSMessageID;
                        if (id) {
                            var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                            jolokia.execute(mbean, operation, id, Core.onSuccess(callback));
                        }
                    });
                }
            };
            function populateTable(response) {
                // setup queue names
                if ($scope.queueNames.length === 0) {
                    var queueNames = ActiveMQ.retrieveQueueNames(workspace, true);
                    var selectedQueue = workspace.selection.text;
                    $scope.queueNames = queueNames.filter(function (name) { return name !== selectedQueue; });
                }
                var data = response.value;
                if (!angular.isArray(data)) {
                    $scope.allMessages = [];
                    angular.forEach(data, function (value, idx) {
                        $scope.allMessages.push(value);
                    });
                }
                else {
                    $scope.allMessages = data;
                }
                angular.forEach($scope.allMessages, function (message) {
                    message.openMessageDialog = $scope.openMessageDialog;
                    message.headerHtml = createHeaderHtml(message);
                    message.bodyText = createBodyText(message);
                });
                filterMessages($scope.gridOptions.filterOptions.filterText);
                Core.$apply($scope);
            }
            /*
             * For some reason using ng-repeat in the modal dialog doesn't work so lets
             * just create the HTML in code :)
             */
            function createBodyText(message) {
                if (message.Text) {
                    var body = message.Text;
                    var lenTxt = "" + body.length;
                    message.textMode = "text (" + lenTxt + " chars)";
                    return body;
                }
                else if (message.BodyPreview) {
                    var code = Core.parseIntValue(localStorage["activemqBrowseBytesMessages"] || "1", "browse bytes messages");
                    var body;
                    message.textMode = "bytes (turned off)";
                    if (code != 99) {
                        var bytesArr = [];
                        var textArr = [];
                        message.BodyPreview.forEach(function (b) {
                            if (code === 1 || code === 2) {
                                // text
                                textArr.push(String.fromCharCode(b));
                            }
                            if (code === 1 || code === 4) {
                                // hex and must be 2 digit so they space out evenly
                                var s = b.toString(16);
                                if (s.length === 1) {
                                    s = "0" + s;
                                }
                                bytesArr.push(s);
                            }
                            else {
                                // just show as is without spacing out, as that is usually more used for hex than decimal
                                var s = b.toString(10);
                                bytesArr.push(s);
                            }
                        });
                        var bytesData = bytesArr.join(" ");
                        var textData = textArr.join("");
                        if (code === 1 || code === 2) {
                            // bytes and text
                            var len = message.BodyPreview.length;
                            var lenTxt = "" + textArr.length;
                            body = "bytes:\n" + bytesData + "\n\ntext:\n" + textData;
                            message.textMode = "bytes (" + len + " bytes) and text (" + lenTxt + " chars)";
                        }
                        else {
                            // bytes only
                            var len = message.BodyPreview.length;
                            body = bytesData;
                            message.textMode = "bytes (" + len + " bytes)";
                        }
                    }
                    return body;
                }
                else {
                    message.textMode = "unsupported";
                    return "Unsupported message body type which cannot be displayed by hawtio";
                }
            }
            /*
             * For some reason using ng-repeat in the modal dialog doesn't work so lets
             * just create the HTML in code :)
             */
            function createHeaderHtml(message) {
                var headers = createHeaders(message);
                var properties = createProperties(message);
                var headerKeys = _.keys(headers);
                function sort(a, b) {
                    if (a > b)
                        return 1;
                    if (a < b)
                        return -1;
                    return 0;
                }
                var propertiesKeys = _.keys(properties).sort(sort);
                var jmsHeaders = _.filter(headerKeys, function (key) { return _.startsWith(key, "JMS"); }).sort(sort);
                var remaining = _.difference(headerKeys, jmsHeaders.concat(propertiesKeys)).sort(sort);
                var buffer = [];
                function appendHeader(key) {
                    var value = headers[key];
                    if (value === null) {
                        value = '';
                    }
                    buffer.push('<tr><td class="propertyName"><span class="green">Header</span> - ' +
                        key +
                        '</td><td class="property-value">' +
                        value +
                        '</td></tr>');
                }
                function appendProperty(key) {
                    var value = properties[key];
                    if (value === null) {
                        value = '';
                    }
                    buffer.push('<tr><td class="propertyName">' +
                        key +
                        '</td><td class="property-value">' +
                        value +
                        '</td></tr>');
                }
                jmsHeaders.forEach(appendHeader);
                remaining.forEach(appendHeader);
                propertiesKeys.forEach(appendProperty);
                return buffer.join("\n");
            }
            function createHeaders(row) {
                var answer = {};
                angular.forEach(row, function (value, key) {
                    if (!_.some(ignoreColumns, function (k) { return k === key; }) && !_.some(flattenColumns, function (k) { return k === key; })) {
                        answer[_.escape(key)] = _.escape(value);
                    }
                });
                return answer;
            }
            function createProperties(row) {
                var answer = {};
                angular.forEach(row, function (value, key) {
                    if (!_.some(ignoreColumns, function (k) { return k === key; }) && _.some(flattenColumns, function (k) { return k === key; })) {
                        angular.forEach(value, function (v2, k2) {
                            answer['<span class="green">' + key.replace('Properties', ' Property') + '</span> - ' + _.escape(k2)] = _.escape(v2);
                        });
                    }
                });
                return answer;
            }
            function loadTable() {
                var objName;
                if ($scope.queueName) {
                    $scope.showButtons = false;
                    $scope.dlq = false;
                    var mbean = ActiveMQ.getBrokerMBean(workspace, jolokia, amqJmxDomain);
                    // browseQueue(java.lang.String) is not available until ActiveMQ 5.15.0
                    // https://issues.apache.org/jira/browse/AMQ-6435
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'browseQueue(java.lang.String)', arguments: [$scope.queueName] }, Core.onSuccess(populateTable, {
                        error: function (response) {
                            // try again with the old ActiveMQ API
                            $scope.queueName = null;
                            $scope.showButtons = true;
                            loadTable();
                        }
                    }));
                    $scope.queueName = null;
                }
                else {
                    if (workspace.selection) {
                        objName = workspace.selection.objectName;
                    }
                    else {
                        // in case of refresh
                        var key = $location.search()['nid'];
                        var node = workspace.keyToNodeMap[key];
                        objName = node.objectName;
                    }
                    if (objName) {
                        $scope.dlq = false;
                        jolokia.getAttribute(objName, "DLQ", Core.onSuccess(onDlq, { silent: true }));
                        jolokia.request({ type: 'exec', mbean: objName, operation: 'browse()' }, Core.onSuccess(populateTable));
                    }
                }
            }
            function onDlq(response) {
                $scope.dlq = response;
                Core.$apply($scope);
            }
            function intermediateResult() {
            }
            function operationSuccess() {
                deselectAll();
                Core.notification("success", $scope.message);
                setTimeout(loadTable, 50);
            }
            function moveSuccess() {
                operationSuccess();
                workspace.loadTree();
            }
            function filterMessages(filter) {
                var searchConditions = buildSearchConditions(filter);
                evalFilter(searchConditions);
            }
            function evalFilter(searchConditions) {
                if (!searchConditions || searchConditions.length === 0) {
                    $scope.messages = $scope.allMessages;
                }
                else {
                    ActiveMQ.log.debug("Filtering conditions:", searchConditions);
                    $scope.messages = $scope.allMessages.filter(function (message) {
                        ActiveMQ.log.debug("Message:", message);
                        var matched = true;
                        $.each(searchConditions, function (index, condition) {
                            if (!condition.column) {
                                matched = matched && evalMessage(message, condition.regex);
                            }
                            else {
                                matched = matched &&
                                    (message[condition.column] && condition.regex.test(message[condition.column])) ||
                                    (message.StringProperties && message.StringProperties[condition.column] && condition.regex.test(message.StringProperties[condition.column]));
                            }
                        });
                        return matched;
                    });
                }
            }
            function evalMessage(message, regex) {
                var jmsHeaders = ['JMSDestination', 'JMSDeliveryMode', 'JMSExpiration', 'JMSPriority', 'JMSMessageID', 'JMSTimestamp', 'JMSCorrelationID', 'JMSReplyTo', 'JMSType', 'JMSRedelivered'];
                for (var i = 0; i < jmsHeaders.length; i++) {
                    var header = jmsHeaders[i];
                    if (message[header] && regex.test(message[header])) {
                        return true;
                    }
                }
                if (message.StringProperties) {
                    for (var property in message.StringProperties) {
                        if (regex.test(message.StringProperties[property])) {
                            return true;
                        }
                    }
                }
                if (message.bodyText && regex.test(message.bodyText)) {
                    return true;
                }
                return false;
            }
            function getRegExp(str, modifiers) {
                try {
                    return new RegExp(str, modifiers);
                }
                catch (err) {
                    return new RegExp(str.replace(/(\^|\$|\(|\)|<|>|\[|\]|\{|\}|\\|\||\.|\*|\+|\?)/g, '\\$1'));
                }
            }
            function buildSearchConditions(filterText) {
                var searchConditions = [];
                var qStr;
                if (!(qStr = $.trim(filterText))) {
                    return;
                }
                var columnFilters = qStr.split(";");
                for (var i = 0; i < columnFilters.length; i++) {
                    var args = columnFilters[i].split(':');
                    if (args.length > 1) {
                        var columnName = $.trim(args[0]);
                        var columnValue = $.trim(args[1]);
                        if (columnName && columnValue) {
                            searchConditions.push({
                                column: columnName,
                                columnDisplay: columnName.replace(/\s+/g, '').toLowerCase(),
                                regex: getRegExp(columnValue, 'i')
                            });
                        }
                    }
                    else {
                        var val = $.trim(args[0]);
                        if (val) {
                            searchConditions.push({
                                column: '',
                                regex: getRegExp(val, 'i')
                            });
                        }
                    }
                }
                return searchConditions;
            }
            function deselectAll() {
                $scope.gridOptions.selectedItems = [];
            }
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.QueuesController", ["$scope", "workspace", "jolokia", "localStorage", function ($scope, workspace, jolokia, localStorage) {
            var amqJmxDomain = localStorage['activemqJmxDomain'] || "org.apache.activemq";
            $scope.workspace = workspace;
            $scope.destinationType;
            $scope.destinations = [];
            $scope.totalServerItems = 0;
            $scope.pagingOptions = {
                pageSizes: [50, 100, 200],
                pageSize: 100,
                currentPage: 1
            };
            $scope.destinationFilter = {
                name: '',
                filter: '',
                sortColumn: '',
                sortOrder: ''
            };
            $scope.destinationFilterOptions = [
                { id: "noConsumer", name: "No Consumer" }
            ];
            $scope.destinationFilter;
            $scope.sortOptions = {
                fields: ["name"],
                directions: ["asc"]
            };
            var refreshed = false;
            var attributes = [];
            var hiddenAttributes = [
                {
                    field: 'inFlightCount',
                    displayName: 'In-flight Count',
                    visible: false
                },
                {
                    field: 'expiredCount',
                    displayName: 'Expired Count',
                    visible: false
                },
                {
                    field: 'memoryPercentUsage',
                    displayName: 'Memory Percent Usage [%]',
                    visible: false
                },
                {
                    field: 'memoryLimit',
                    displayName: 'Memory Limit',
                    visible: false
                },
                {
                    field: 'memoryUsageByteCount',
                    displayName: 'Memory Usage Byte Count',
                    visible: false
                },
                {
                    field: 'memoryUsagePortion',
                    displayName: 'Memory Usage Portion',
                    visible: false
                },
                {
                    field: 'forwardCount',
                    displayName: 'Forward Count',
                    visible: false
                },
                {
                    field: 'maxAuditDepth',
                    displayName: 'Max Audit Depth',
                    visible: false
                },
                {
                    field: 'maxEnqueueTime',
                    displayName: 'Max Enqueue Time',
                    visible: false
                },
                {
                    field: 'maxMessageSize',
                    displayName: 'Max Message Size',
                    visible: false
                },
                {
                    field: 'maxPageSize',
                    displayName: 'Max Page Size',
                    visible: false
                },
                {
                    field: 'maxProducersToAudit',
                    displayName: 'Max Producers To Audit',
                    visible: false
                },
                {
                    field: 'messagesCached',
                    displayName: 'Messages Cached',
                    visible: false
                },
                {
                    field: 'minEnqueueTime',
                    displayName: 'Min Enqueue Time',
                    visible: false
                },
                {
                    field: 'minMessageSize',
                    displayName: 'Min Message Size',
                    visible: false
                },
                {
                    field: 'options',
                    displayName: 'Options',
                    visible: false
                },
                {
                    field: 'storeMessageSize',
                    displayName: 'Store Message Size',
                    visible: false
                },
                {
                    field: 'totalBlockedTime',
                    displayName: 'Totel Blocked Time',
                    visible: false
                },
                {
                    field: 'dlq',
                    displayName: 'DLQ?',
                    visible: false
                },
                {
                    field: 'enableAudit',
                    displayName: 'Audit Enabled?',
                    visible: false
                },
                {
                    field: 'prioritizedMessages',
                    displayName: 'Prioritized Messages?',
                    visible: false
                },
                {
                    field: 'producerFlowControl',
                    displayName: 'Producer Flow Control?',
                    visible: false
                },
                {
                    field: 'useCache',
                    displayName: 'Use Cache?',
                    visible: false
                }
            ];
            if ($scope.destinationType == 'topic') {
                $scope.destinationFilterOptions.push({ id: "nonAdvisory", name: "No Advisory Topics" });
                $scope.destinationFilterPlaceholder = "Filter Topic Names...";
                attributes = [
                    {
                        field: 'name',
                        displayName: 'Name',
                        width: '*'
                    },
                    {
                        field: 'producerCount',
                        displayName: 'Producer Count',
                        width: '10%',
                    },
                    {
                        field: 'consumerCount',
                        displayName: 'Consumer Count',
                        width: '10%',
                    },
                    {
                        field: 'enqueueCount',
                        displayName: 'Enqueue Count',
                        width: '10%',
                    },
                    {
                        field: 'dequeueCount',
                        displayName: 'Dequeue Count',
                        width: '10%',
                    },
                    {
                        field: 'dispatchCount',
                        displayName: 'Dispatch Count',
                        width: '10%',
                    }
                ];
                attributes = attributes.concat(hiddenAttributes);
            }
            else {
                $scope.destinationFilterOptions.push({ id: "empty", name: "Only Empty" });
                $scope.destinationFilterOptions.push({ id: "nonEmpty", name: "Only Non-Empty" });
                $scope.destinationFilterPlaceholder = "Filter Queue Names...";
                attributes = [
                    {
                        field: 'name',
                        displayName: 'Name',
                        width: '*',
                        cellTemplate: '<div class="ngCellText"><a href="#/activemq/browseQueue?tab=activemq&queueName={{row.entity.name}}">{{row.entity.name}}</a></div>'
                    },
                    {
                        field: 'queueSize',
                        displayName: 'Queue Size',
                        width: '10%'
                    },
                    {
                        field: 'producerCount',
                        displayName: 'Producer Count',
                        width: '10%'
                    },
                    {
                        field: 'consumerCount',
                        displayName: 'Consumer Count',
                        width: '10%'
                    },
                    {
                        field: 'enqueueCount',
                        displayName: 'Enqueue Count',
                        width: '10%'
                    },
                    {
                        field: 'dequeueCount',
                        displayName: 'Dequeue Count',
                        width: '10%'
                    },
                    {
                        field: 'dispatchCount',
                        displayName: 'Dispatch Count',
                        width: '10%'
                    }
                ];
                attributes = attributes.concat(hiddenAttributes);
            }
            $scope.gridOptions = {
                selectedItems: [],
                data: 'destinations',
                showFooter: true,
                showFilter: true,
                showColumnMenu: true,
                enableCellSelection: false,
                enableHighlighting: true,
                enableColumnResize: true,
                enableColumnReordering: true,
                selectWithCheckboxOnly: false,
                showSelectionCheckbox: false,
                multiSelect: false,
                displaySelectionCheckbox: false,
                pagingOptions: $scope.pagingOptions,
                filterOptions: {
                    filterText: '',
                    useExternalFilter: true
                },
                enablePaging: true,
                totalServerItems: 'totalServerItems',
                maintainColumnRatios: false,
                columnDefs: attributes,
                enableFiltering: true,
                useExternalFiltering: true,
                sortInfo: $scope.sortOptions,
                useExternalSorting: true
            };
            $scope.refresh = function () {
                refreshed = true;
                $scope.loadTable();
            };
            $scope.loadTable = function () {
                $scope.destinationFilter.name = $scope.gridOptions.filterOptions.filterText;
                $scope.destinationFilter.sortColumn = $scope.sortOptions.fields[0];
                $scope.destinationFilter.sortOrder = $scope.sortOptions.directions[0];
                var mbean = ActiveMQ.getBrokerMBean(workspace, jolokia, amqJmxDomain);
                if (mbean) {
                    var method = 'queryQueues(java.lang.String, int, int)';
                    if ($scope.destinationType == 'topic') {
                        method = 'queryTopics(java.lang.String, int, int)';
                    }
                    jolokia.request({ type: 'exec', mbean: mbean, operation: method, arguments: [JSON.stringify($scope.destinationFilter), $scope.pagingOptions.currentPage, $scope.pagingOptions.pageSize] }, Core.onSuccess(populateTable, { error: onError }));
                }
            };
            function onError() {
                Core.notification("error", "The feature is not available in this broker version!");
                $scope.workspace.selectParentNode();
            }
            function populateTable(response) {
                var data = JSON.parse(response.value);
                $scope.destinations = [];
                angular.forEach(data["data"], function (value, idx) {
                    $scope.destinations.push(value);
                });
                $scope.totalServerItems = data["count"];
                if (refreshed == true) {
                    $scope.gridOptions.pagingOptions.currentPage = 1;
                    refreshed = false;
                }
                Core.$apply($scope);
            }
            $scope.$watch('sortOptions', function (newVal, oldVal) {
                if (newVal !== oldVal) {
                    $scope.loadTable();
                }
            }, true);
            $scope.$watch('pagingOptions', function (newVal, oldVal) {
                if (parseInt(newVal.currentPage) && newVal !== oldVal && newVal.currentPage !== oldVal.currentPage) {
                    $scope.loadTable();
                }
            }, true);
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.DurableSubscriberController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
            var amqJmxDomain = localStorage['activemqJmxDomain'] || "org.apache.activemq";
            $scope.refresh = loadTable;
            $scope.durableSubscribers = [];
            $scope.tempData = [];
            $scope.createSubscriberDialog = new UI.Dialog();
            $scope.deleteSubscriberDialog = new UI.Dialog();
            $scope.showSubscriberDialog = new UI.Dialog();
            $scope.topicName = '';
            $scope.clientId = '';
            $scope.subscriberName = '';
            $scope.subSelector = '';
            $scope.gridOptions = {
                selectedItems: [],
                data: 'durableSubscribers',
                displayFooter: false,
                showFilter: false,
                showColumnMenu: true,
                enableCellSelection: false,
                enableColumnResize: true,
                enableColumnReordering: true,
                selectWithCheckboxOnly: false,
                showSelectionCheckbox: false,
                multiSelect: false,
                displaySelectionCheckbox: false,
                filterOptions: {
                    filterText: ''
                },
                maintainColumnRatios: false,
                columnDefs: [
                    {
                        field: 'destinationName',
                        displayName: 'Topic',
                        width: '30%'
                    },
                    {
                        field: 'clientId',
                        displayName: 'Client ID',
                        width: '30%'
                    },
                    {
                        field: 'consumerId',
                        displayName: 'Consumer ID',
                        cellTemplate: '<div class="ngCellText"><span ng-hide="row.entity.status != \'Offline\'">{{row.entity.consumerId}}</span><a ng-show="row.entity.status != \'Offline\'" ng-click="openSubscriberDialog(row)">{{row.entity.consumerId}}</a></div>',
                        width: '30%'
                    },
                    {
                        field: 'status',
                        displayName: 'Status',
                        width: '10%'
                    }
                ],
                primaryKeyFn: function (entity) { return entity.destinationName + '/' + entity.clientId + '/' + entity.consumerId; }
            };
            $scope.doCreateSubscriber = function (clientId, subscriberName, topicName, subSelector) {
                $scope.createSubscriberDialog.close();
                $scope.clientId = clientId;
                $scope.subscriberName = subscriberName;
                $scope.topicName = topicName;
                $scope.subSelector = subSelector;
                if (Core.isBlank($scope.subSelector)) {
                    $scope.subSelector = null;
                }
                var mbean = ActiveMQ.getBrokerMBean(workspace, jolokia, amqJmxDomain);
                if (mbean) {
                    jolokia.execute(mbean, "createDurableSubscriber(java.lang.String, java.lang.String, java.lang.String, java.lang.String)", $scope.clientId, $scope.subscriberName, $scope.topicName, $scope.subSelector, Core.onSuccess(function () {
                        Core.notification('success', "Created durable subscriber " + clientId);
                        $scope.clientId = '';
                        $scope.subscriberName = '';
                        $scope.topicName = '';
                        $scope.subSelector = '';
                        loadTable();
                    }));
                }
                else {
                    Core.notification("error", "Could not find the Broker MBean!");
                }
            };
            $scope.deleteSubscribers = function () {
                var mbean = $scope.gridOptions.selectedItems[0]._id;
                jolokia.execute(mbean, "destroy()", Core.onSuccess(function () {
                    $scope.showSubscriberDialog.close();
                    Core.notification('success', "Deleted durable subscriber");
                    loadTable();
                    $scope.gridOptions.selectedItems.splice(0, $scope.gridOptions.selectedItems.length);
                }));
            };
            $scope.openSubscriberDialog = function (subscriber) {
                jolokia.request({ type: "read", mbean: subscriber.entity._id }, Core.onSuccess(function (response) {
                    $scope.showSubscriberDialog.subscriber = response.value;
                    $scope.showSubscriberDialog.subscriber.Status = subscriber.entity.status;
                    console.log("Subscriber is now " + $scope.showSubscriberDialog.subscriber);
                    Core.$apply($scope);
                    // now lets start opening the dialog
                    setTimeout(function () {
                        $scope.showSubscriberDialog.open();
                        Core.$apply($scope);
                    }, 100);
                }));
            };
            $scope.topicNames = function (completionText) { return ActiveMQ.retrieveTopicNames(workspace, false); };
            function loadTable() {
                var mbean = ActiveMQ.getBrokerMBean(workspace, jolokia, amqJmxDomain);
                if (mbean) {
                    $scope.durableSubscribers = [];
                    jolokia.request({ type: "read", mbean: mbean, attribute: ["DurableTopicSubscribers"] }, Core.onSuccess(function (response) { return populateTable(response, "DurableTopicSubscribers", "Active"); }));
                    jolokia.request({ type: "read", mbean: mbean, attribute: ["InactiveDurableTopicSubscribers"] }, Core.onSuccess(function (response) { return populateTable(response, "InactiveDurableTopicSubscribers", "Offline"); }));
                }
            }
            function populateTable(response, attr, status) {
                var data = response.value;
                ActiveMQ.log.debug("Got data: ", data);
                $scope.durableSubscribers.push.apply($scope.durableSubscribers, data[attr].map(function (o) {
                    var objectName = o["objectName"];
                    var entries = Core.objectNameProperties(objectName);
                    if (!('objectName' in o)) {
                        if ('canonicalName' in o) {
                            objectName = o['canonicalName'];
                        }
                        entries = _.cloneDeep(o['keyPropertyList']);
                    }
                    entries["_id"] = objectName;
                    entries["status"] = status;
                    return entries;
                }));
                Core.$apply($scope);
            }
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.JobSchedulerController", ["$scope", "workspace", "jolokia", function ($scope, workspace, jolokia) {
            $scope.refresh = loadTable;
            $scope.jobs = [];
            $scope.deleteJobsDialog = new UI.Dialog();
            $scope.gridOptions = {
                selectedItems: [],
                data: 'jobs',
                displayFooter: false,
                showFilter: false,
                showColumnMenu: true,
                enableColumnResize: true,
                enableColumnReordering: true,
                filterOptions: {
                    filterText: ''
                },
                selectWithCheckboxOnly: true,
                showSelectionCheckbox: true,
                maintainColumnRatios: false,
                columnDefs: [
                    {
                        field: 'jobId',
                        displayName: 'Job ID',
                        width: '25%'
                    },
                    {
                        field: 'cronEntry',
                        displayName: 'Cron Entry',
                        width: '10%'
                    },
                    {
                        field: 'delay',
                        displayName: 'Delay',
                        width: '5%'
                    },
                    {
                        field: 'repeat',
                        displayName: 'repeat',
                        width: '5%'
                    },
                    {
                        field: 'period',
                        displayName: 'period',
                        width: '5%'
                    },
                    {
                        field: 'start',
                        displayName: 'Start',
                        width: '25%'
                    },
                    {
                        field: 'next',
                        displayName: 'Next',
                        width: '25%'
                    }
                ],
                primaryKeyFn: function (entity) { return entity.jobId; }
            };
            function loadTable() {
                var selection = workspace.selection;
                if (selection) {
                    var mbean = selection.objectName;
                    if (mbean) {
                        jolokia.request({ type: 'read', mbean: mbean, attribute: "AllJobs" }, Core.onSuccess(populateTable));
                    }
                }
                Core.$apply($scope);
            }
            function populateTable(response) {
                var data = response.value;
                if (!angular.isArray(data)) {
                    $scope.jobs = [];
                    angular.forEach(data, function (value, idx) {
                        $scope.jobs.push(value);
                    });
                }
                else {
                    $scope.jobs = data;
                }
                Core.$apply($scope);
            }
            $scope.deleteJobs = function () {
                var selection = workspace.selection;
                var mbean = selection.objectName;
                if (mbean && selection) {
                    var selectedItems = $scope.gridOptions.selectedItems;
                    $scope.message = "Deleted " + Core.maybePlural(selectedItems.length, "job");
                    var operation = "removeJob(java.lang.String)";
                    angular.forEach(selectedItems, function (item, idx) {
                        var id = item.jobId;
                        if (id) {
                            var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                            jolokia.execute(mbean, operation, id, Core.onSuccess(callback));
                        }
                    });
                }
            };
            function intermediateResult() {
            }
            function operationSuccess() {
                $scope.gridOptions.selectedItems.splice(0);
                Core.notification("success", $scope.message);
                setTimeout(loadTable, 50);
            }
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.PreferencesController", ["$scope", "localStorage", "userDetails", "$rootScope", function ($scope, localStorage, userDetails, $rootScope) {
            var config = {
                properties: {
                    activemqUserName: {
                        type: 'string',
                        description: 'The user name to be used when connecting to the broker'
                    },
                    activemqPassword: {
                        type: 'password',
                        description: 'Password to be used when connecting to the broker'
                    },
                    activemqFilterAdvisoryTopics: {
                        type: 'boolean',
                        default: 'false',
                        description: 'Whether to exclude advisory topics in tree/table'
                    },
                    activemqBrowseBytesMessages: {
                        type: 'number',
                        enum: {
                            'Hex and text': 1,
                            'Decimal and text': 2,
                            'Hex': 4,
                            'Decimal': 8,
                            'Off': 99
                        },
                        description: 'Browsing byte messages should display the message body as'
                    }
                }
            };
            $scope.entity = $scope;
            $scope.config = config;
            Core.initPreferenceScope($scope, localStorage, {
                'activemqUserName': {
                    'value': userDetails.username ? userDetails.username : ""
                },
                'activemqPassword': {
                    'value': userDetails.password ? userDetails.password : ""
                },
                'activemqBrowseBytesMessages': {
                    'value': 1,
                    'converter': parseInt
                },
                'activemqFilterAdvisoryTopics': {
                    'value': false,
                    'converter': Core.parseBooleanValue,
                    'post': function (newValue) {
                        $rootScope.$broadcast('jmxTreeUpdated');
                    }
                }
            });
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller('ActiveMQ.TabsController', ['$scope', '$location', 'workspace', function ($scope, $location, workspace) {
            $scope.tabs = [
                {
                    id: 'jmx-attributes',
                    title: 'Attributes',
                    path: "/jmx/attributes",
                    show: function () { return true; }
                },
                {
                    id: 'jmx-operations',
                    title: 'Operations',
                    path: "/jmx/operations",
                    show: function () { return true; }
                },
                {
                    id: 'jmx-charts',
                    title: 'Chart',
                    path: "/jmx/charts",
                    show: function () { return true; }
                },
                {
                    id: 'activemq-browse',
                    title: 'Browse',
                    tooltip: "Browse the messages on the queue",
                    show: function () { return ActiveMQ.isQueue(workspace) && workspace.hasInvokeRights(workspace.selection, 'browse()'); },
                    path: '/activemq/browseQueue'
                },
                {
                    id: 'activemq-send',
                    title: 'Send',
                    tooltip: 'Send a message to this destination',
                    show: function () { return (ActiveMQ.isQueue(workspace) || ActiveMQ.isTopic(workspace)) && workspace.hasInvokeRights(workspace.selection, 'sendTextMessage(java.util.Map,java.lang.String,java.lang.String,java.lang.String)'); },
                    path: '/activemq/sendMessage'
                },
                {
                    id: 'activemq-durable-subscribers',
                    title: 'Durable Subscribers',
                    tooltip: 'Manage durable subscribers',
                    show: function () { return ActiveMQ.isBroker(workspace); },
                    path: '/activemq/durableSubscribers'
                },
                {
                    id: 'activemq-jobs',
                    title: 'Jobs',
                    tooltip: 'Manage jobs',
                    show: function () { return ActiveMQ.isJobScheduler(workspace); },
                    path: '/activemq/jobs'
                },
                {
                    id: 'activemq-create-destination',
                    title: 'Create',
                    tooltip: 'Create a new destination',
                    show: function () { return ActiveMQ.isBroker(workspace) && workspace.hasInvokeRights(ActiveMQ.getBroker(workspace), 'addQueue', 'addTopic'); },
                    path: '/activemq/createDestination'
                },
                {
                    id: 'activemq-delete-topic',
                    title: 'Delete',
                    tooltip: 'Delete this topic',
                    show: function () { return ActiveMQ.isTopic(workspace) && workspace.hasInvokeRights(ActiveMQ.getBroker(workspace), 'removeTopic'); },
                    path: '/activemq/deleteTopic'
                },
                {
                    id: 'activemq-delete-queue',
                    title: 'Delete',
                    tooltip: 'Delete or purge this queue',
                    show: function () { return ActiveMQ.isQueue(workspace) && workspace.hasInvokeRights(ActiveMQ.getBroker(workspace), 'removeQueue'); },
                    path: '/activemq/deleteQueue'
                },
                {
                    id: 'activemq-queues',
                    title: 'Queues',
                    tooltip: 'View Queues',
                    show: function () { return ActiveMQ.isBroker(workspace); },
                    path: '/activemq/queues'
                },
                {
                    id: 'activemq-topics',
                    title: 'Topics',
                    tooltip: 'View Topics',
                    show: function () { return ActiveMQ.isBroker(workspace); },
                    path: '/activemq/topics'
                }
            ];
            $scope.isActive = function (tab) { return workspace.isLinkActive(tab.path); };
            $scope.goto = function (path) { return $location.path(path); };
        }]);
})(ActiveMQ || (ActiveMQ = {}));
/// <reference path="activemqHelpers.ts"/>
/// <reference path="activemqPlugin.ts"/>
var ActiveMQ;
(function (ActiveMQ) {
    ActiveMQ._module.controller("ActiveMQ.TreeHeaderController", ["$scope", function ($scope) {
            // TODO: the tree should ideally be initialised synchronously
            var tree = function () { return $('#activemqtree').treeview(true); };
            $scope.expandAll = function () { return tree().expandNode(tree().getNodes(), { levels: 1, silent: true }); };
            $scope.contractAll = function () { return tree().collapseNode(tree().getNodes(), { ignoreChildren: true, silent: true }); };
            var search = _.debounce(function (filter) {
                var result = tree().search(filter, {
                    ignoreCase: true,
                    exactMatch: false,
                    revealResults: true
                });
                $scope.result.length = 0;
                (_a = $scope.result).push.apply(_a, result);
                Core.$apply($scope);
                var _a;
            }, 300, { leading: false, trailing: true });
            $scope.filter = '';
            $scope.result = [];
            $scope.$watch('filter', function (filter, previous) {
                if (filter !== previous) {
                    search(filter);
                }
            });
        }]);
    ActiveMQ._module.controller("ActiveMQ.TreeController", ["$scope", "$location", "workspace", "localStorage", function ($scope, $location, workspace, localStorage) {
            $scope.treeFetched = function () { return workspace.treeFetched; };
            $scope.$on('$routeChangeStart', function () { return Jmx.updateTreeSelectionFromURL($location, $('#activemqtree')); });
            $scope.$watch('workspace.tree', function () {
                reloadTree();
            });
            $scope.$on('jmxTreeUpdated', function () {
                reloadTree();
            });
            function reloadTree() {
                ActiveMQ.log.debug("workspace tree has changed, lets reload the activemq tree");
                var children = [];
                var tree = workspace.tree;
                if (tree) {
                    var domainName = "org.apache.activemq";
                    var folder = tree.get(domainName);
                    if (folder) {
                        children = folder.children;
                    }
                    if (children.length) {
                        var firstChild = children[0];
                        // the children could be AMQ 5.7 style broker name folder with the actual MBean in the children
                        // along with folders for the Queues etc...
                        if (!firstChild.typeName && firstChild.children.length < 4) {
                            // lets avoid the top level folder
                            var answer = [];
                            angular.forEach(children, function (child) {
                                answer = answer.concat(child.children);
                            });
                            children = answer;
                        }
                    }
                    // filter out advisory topics
                    children.forEach(function (broker) {
                        var grandChildren = broker.children;
                        if (grandChildren) {
                            var old = _.find(grandChildren, function (n) { return n.text === "Topic"; });
                            if (old) {
                                // we need to store all topics the first time on the workspace
                                // so we have access to them later if the user changes the filter in the preferences
                                var key = "ActiveMQ-allTopics-" + broker.text;
                                var allTopics = _.clone(old.children);
                                workspace.mapData[key] = allTopics;
                                var filter = Core.parseBooleanValue(localStorage["activemqFilterAdvisoryTopics"]);
                                if (filter) {
                                    if (old && old.children) {
                                        var filteredTopics = _.filter(old.children, function (c) { return !_.startsWith(c.text, "ActiveMQ.Advisory"); });
                                        old.children = filteredTopics;
                                    }
                                }
                                else if (allTopics) {
                                    old.children = allTopics;
                                }
                            }
                        }
                    });
                    var treeElement = $("#activemqtree");
                    Jmx.enableTree($scope, $location, workspace, treeElement, children);
                    // lets do this asynchronously to avoid Error: $digest already in progress
                    setTimeout(updateSelectionFromURL, 50);
                }
            }
            function updateSelectionFromURL() {
                Jmx.updateTreeSelectionFromURLAndAutoSelect($location, $("#activemqtree"), function (first) {
                    if (first.children == null) {
                        return null;
                    }
                    // use function to auto select the queue folder on the 1st broker
                    var queues = first.children[0];
                    if (queues && queues.text === 'Queue') {
                        return queues;
                    }
                    return null;
                }, true);
            }
            $scope.$on('$destroy', function () {
                var tree = $('#activemqtree').treeview(true);
                tree.clearSearch();
                // Bootstrap tree view leaks the node elements into the data structure
                // so let's clean this up when the user leaves the view
                var cleanTreeFolder = function (node) {
                    delete node['$el'];
                    if (node.nodes)
                        node.nodes.forEach(cleanTreeFolder);
                };
                cleanTreeFolder(workspace.tree);
                // Then call the tree clean-up method
                tree.remove();
            });
        }]);
})(ActiveMQ || (ActiveMQ = {}));
var Camel;
(function (Camel) {
    /**
     * Define the default categories for endpoints and map them to endpoint names
     * @property
     * @for Camel
     * @type {Object}
     */
    Camel.endpointCategories = {
        bigdata: {
            label: "Big Data",
            endpoints: ["hdfs", "hbase", "lucene", "solr"],
            endpointIcon: "img/icons/camel/endpointRepository24.png"
        },
        database: {
            label: "Database",
            endpoints: ["couchdb", "elasticsearch", "hbase", "jdbc", "jpa", "hibernate", "mongodb", "mybatis", "sql"],
            endpointIcon: "img/icons/camel/endpointRepository24.png"
        },
        cloud: {
            label: "Cloud",
            endpoints: [
                "aws-cw", "aws-ddb", "aws-sdb", "aws-ses", "aws-sns", "aws-sqs", "aws-s3",
                "gauth", "ghhtp", "glogin", "gtask",
                "jclouds"
            ]
        },
        core: {
            label: "Core",
            endpoints: ["bean", "direct", "seda"]
        },
        messaging: {
            label: "Messaging",
            endpoints: ["jms", "activemq", "amqp", "cometd", "cometds", "mqtt", "netty", "vertx", "websocket"],
            endpointIcon: "img/icons/camel/endpointQueue24.png"
        },
        mobile: {
            label: "Mobile",
            endpoints: ["apns"]
        },
        sass: {
            label: "SaaS",
            endpoints: ["salesforce", "sap-netweaver"]
        },
        social: {
            label: "Social",
            endpoints: ["atom", "facebook", "irc", "ircs", "rss", "smpp", "twitter", "weather"]
        },
        storage: {
            label: "Storage",
            endpointIcon: "img/icons/camel/endpointFolder24.png",
            endpoints: ["file", "ftp", "sftp", "scp", "jsch"]
        },
        template: {
            label: "Templating",
            endpoints: ["freemarker", "velocity", "xquery", "xslt", "scalate", "string-template"]
        }
    };
    /**
     * Maps endpoint names to a category object
     * @property
     * @for Camel
     * @type {Object}
     */
    Camel.endpointToCategory = {};
    Camel.endpointIcon = "img/icons/camel/endpoint24.png";
    /**
     *  specify custom label & icon properties for endpoint names
     * @property
     * @for Camel
     * @type {Object}
     */
    Camel.endpointConfigurations = {
        drools: {
            icon: "img/icons/camel/endpointQueue24.png"
        },
        quartz: {
            icon: "img/icons/camel/endpointTimer24.png"
        },
        facebook: {
            icon: "img/icons/camel/endpoints/facebook24.jpg"
        },
        salesforce: {
            icon: "img/icons/camel/endpoints/salesForce24.png"
        },
        sap: {
            icon: "img/icons/camel/endpoints/SAPe24.png"
        },
        "sap-netweaver": {
            icon: "img/icons/camel/endpoints/SAPNetweaver24.jpg"
        },
        timer: {
            icon: "img/icons/camel/endpointTimer24.png"
        },
        twitter: {
            icon: "img/icons/camel/endpoints/twitter24.png"
        },
        weather: {
            icon: "img/icons/camel/endpoints/weather24.jpg"
        }
    };
    /**
     * Define the default form configurations
     * @property
     * @for Camel
     * @type {Object}
     */
    Camel.endpointForms = {
        file: {
            tabs: {
                //'Core': ['key', 'value'],
                'Options': ['*']
            }
        },
        activemq: {
            tabs: {
                'Connection': ['clientId', 'transacted', 'transactedInOut', 'transactionName', 'transactionTimeout'],
                'Producer': ['timeToLive', 'priority', 'allowNullBody', 'pubSubNoLocal', 'preserveMessageQos'],
                'Consumer': ['concurrentConsumers', 'acknowledgementModeName', 'selector', 'receiveTimeout'],
                'Reply': ['replyToDestination', 'replyToDeliveryPersistent', 'replyToCacheLevelName', 'replyToDestinationSelectorName'],
                'Options': ['*']
            }
        }
    };
    Camel.endpointForms["jms"] = Camel.endpointForms.activemq;
    angular.forEach(Camel.endpointCategories, function (category, catKey) {
        category['id'] = catKey;
        angular.forEach(category.endpoints, function (endpoint) {
            Camel.endpointToCategory[endpoint] = category;
        });
    });
    /**
     * Override the EIP pattern tabs...
     * @property
     * @for Camel
     * @type {Object}
     */
    var camelModelTabExtensions = {
        route: {
            'Overview': ['id', 'description'],
            'Advanced': ['*']
        }
    };
    function getEndpointIcon(endpointName) {
        var value = Camel.getEndpointConfig(endpointName, null);
        var answer = Core.pathGet(value, ["icon"]);
        if (!answer) {
            var category = getEndpointCategory(endpointName);
            answer = Core.pathGet(category, ["endpointIcon"]);
        }
        return answer || Camel.endpointIcon;
    }
    Camel.getEndpointIcon = getEndpointIcon;
    function getEndpointConfig(endpointName, category) {
        var answer = Camel.endpointConfigurations[endpointName];
        if (!answer) {
            answer = {};
            Camel.endpointConfigurations[endpointName] = answer;
        }
        if (!answer.label) {
            answer.label = endpointName;
        }
        if (!answer.icon) {
            answer.icon = Core.pathGet(category, ["endpointIcon"]) || Camel.endpointIcon;
        }
        if (!answer.category) {
            answer.category = category;
        }
        return answer;
    }
    Camel.getEndpointConfig = getEndpointConfig;
    function getEndpointCategory(endpointName) {
        return Camel.endpointToCategory[endpointName] || Camel.endpointCategories.core;
    }
    Camel.getEndpointCategory = getEndpointCategory;
    function getConfiguredCamelModel() {
        var schema = Camel._apacheCamelModel;
        var definitions = schema["definitions"];
        if (definitions) {
            angular.forEach(camelModelTabExtensions, function (tabs, name) {
                var model = definitions[name];
                if (model) {
                    if (!model["tabs"]) {
                        model["tabs"] = tabs;
                    }
                }
            });
        }
        return schema;
    }
    Camel.getConfiguredCamelModel = getConfiguredCamelModel;
    function initEndpointChooserScope($scope, $location, localStorage, workspace, jolokia) {
        $scope.selectedComponentName = null;
        $scope.endpointParameters = {};
        $scope.endpointPath = "";
        $scope.schema = {
            definitions: {}
        };
        $scope.jolokia = jolokia;
        $scope.profileWorkspace = workspace;
        var silentOptions = { silent: true };
        $scope.$watch('selectedComponentName', function () {
            if ($scope.selectedComponentName !== $scope.loadedComponentName) {
                $scope.endpointParameters = {};
                $scope.loadEndpointSchema($scope.selectedComponentName);
                $scope.loadedComponentName = $scope.selectedComponentName;
            }
        });
        $scope.endpointCompletions = function (completionText) {
            var answer = null;
            var mbean = findCamelContextMBean();
            var componentName = $scope.selectedComponentName;
            var endpointParameters = {};
            if (mbean && componentName && completionText) {
                answer = $scope.jolokia.execute(mbean, 'completeEndpointPath', componentName, endpointParameters, completionText, Core.onSuccess(null, silentOptions));
            }
            return answer || [];
        };
        $scope.loadEndpointNames = function () {
            $scope.componentNames = null;
            var mbean = findCamelContextMBean();
            if (mbean) {
                $scope.jolokia.execute(mbean, 'findComponentNames', Core.onSuccess(onComponents, silentOptions));
            }
            else {
                console.log('WARNING: No camel context mbean so cannot load component names');
            }
        };
        $scope.loadEndpointSchema = function (componentName) {
            var mbean = findCamelContextMBean();
            if (mbean && componentName && componentName !== $scope.loadedEndpointSchema) {
                $scope.selectedComponentName = componentName;
                $scope.jolokia.execute(mbean, 'componentParameterJsonSchema', componentName, Core.onSuccess(onEndpointSchema, silentOptions));
            }
        };
        function onComponents(response) {
            $scope.componentNames = response;
            Camel.log.info("onComponents: " + response);
            $scope.hasComponentNames = $scope.componentNames ? true : false;
            Core.$apply($scope);
        }
        function onEndpointSchema(response) {
            if (response) {
                try {
                    var json = JSON.parse(response);
                    var endpointName = $scope.selectedComponentName;
                    configureEndpointSchema(endpointName, json);
                    $scope.endpointSchema = json;
                    $scope.schema.definitions[endpointName] = json;
                    $scope.loadedEndpointSchema = endpointName;
                    Core.$apply($scope);
                }
                catch (e) {
                    console.log("Failed to parse JSON " + e);
                    console.log("JSON: " + response);
                }
            }
        }
        function configureEndpointSchema(endpointName, json) {
            var config = Camel.endpointForms[endpointName];
            if (config && json) {
                if (config.tabs) {
                    json.tabs = config.tabs;
                }
            }
        }
        function findCamelContextMBean() {
            var profileWorkspace = $scope.profileWorkspace;
            if (!profileWorkspace) {
                var remoteJolokia = $scope.jolokia;
                if (remoteJolokia) {
                    profileWorkspace = Jmx.createRemoteWorkspace(remoteJolokia, $location, localStorage);
                    $scope.profileWorkspace = profileWorkspace;
                }
            }
            if (!profileWorkspace) {
                Camel.log.info("No profileWorkspace found so defaulting it to workspace for now");
                profileWorkspace = workspace;
            }
            // TODO we need to find the MBean for the CamelContext / Route we are editing!
            var componentName = $scope.selectedComponentName;
            var selectedCamelContextId;
            var selectedRouteId;
            if (angular.isDefined($scope.camelSelectionDetails)) {
                selectedCamelContextId = $scope.camelSelectionDetails.selectedCamelContextId;
                selectedRouteId = $scope.camelSelectionDetails.selectedRouteId;
            }
            var contexts = Camel.camelContextMBeansById(profileWorkspace);
            if (selectedCamelContextId) {
                var context = contexts[selectedCamelContextId];
                if (context) {
                    return context.objectName;
                }
            }
            if (selectedRouteId) {
                var map = Camel.camelContextMBeansByRouteId(profileWorkspace);
                var mbean = Core.pathGet(map, [selectedRouteId, 'mbean']);
                if (mbean) {
                    return mbean;
                }
            }
            if (componentName) {
                var map = Camel.camelContextMBeansByComponentName(profileWorkspace);
                var mbean = Core.pathGet(map, [componentName, 'mbean']);
                if (mbean) {
                    return mbean;
                }
            }
            // NOTE we don't really know which camel context to pick, so lets just find the first one?
            return _.first(_.values(contexts)).objectName;
        }
    }
    Camel.initEndpointChooserScope = initEndpointChooserScope;
})(Camel || (Camel = {}));
/// <reference path="endpointChooser.ts"/>
var Camel;
(function (Camel) {
    Camel.log = Logger.get("Camel");
    Camel.jmxDomain = 'org.apache.camel';
    Camel.defaultMaximumLabelWidth = 34;
    Camel.defaultCamelMaximumTraceOrDebugBodyLength = 5000;
    Camel.defaultCamelTraceOrDebugIncludeStreams = false;
    Camel.defaultCamelRouteMetricMaxSeconds = 10;
    Camel.defaultHideOptionDocumentation = false;
    Camel.defaultHideOptionDefaultValue = false;
    Camel.defaultHideOptionUnusedValue = false;
    Camel._apacheCamelModel = undefined;
    hawtioPluginLoader.registerPreBootstrapTask(function (next) {
        Camel._apacheCamelModel = window['_apacheCamelModel'];
        Camel.log.debug("Setting apache camel model: ", Camel._apacheCamelModel);
        next();
    });
    /**
     * Returns if the given CamelContext has any rest services
     *
     * @param workspace
     * @param jolokia
     * @returns {boolean}
     */
    function hasRestServices(workspace, jolokia) {
        var mbean = getSelectionCamelRestRegistry(workspace);
        if (mbean) {
            var numberOfRestServices = jolokia.getAttribute(mbean, 'NumberOfRestServices');
            return numberOfRestServices > 0;
        }
        return false;
    }
    Camel.hasRestServices = hasRestServices;
    /**
     * Looks up the route XML for the given context and selected route and
     * processes the selected route's XML with the given function
     * @method processRouteXml
     * @param {Workspace} workspace
     * @param {Object} jolokia
     * @param {Folder} folder
     * @param {Function} onRoute
     */
    function processRouteXml(workspace, jolokia, folder, onRoute) {
        var selectedRouteId = getSelectedRouteId(workspace, folder);
        var mbean = getExpandingFolderCamelContextMBean(workspace, folder) || getSelectionCamelContextMBean(workspace);
        var onRouteXml = function (response) {
            var route = null;
            var data = response ? response.value : null;
            if (data) {
                var doc = $.parseXML(data);
                var routes = $(doc).find("route[id='" + selectedRouteId + "']");
                if (routes && routes.length) {
                    route = routes[0];
                }
            }
            onRoute(route);
        };
        if (mbean && selectedRouteId) {
            jolokia.request({ type: 'exec', mbean: mbean, operation: 'dumpRoutesAsXml()' }, Core.onSuccess(onRouteXml, { error: onRouteXml }));
        }
        else {
            if (!selectedRouteId) {
                Camel.log.warn("No selectedRouteId when trying to lazy load the route!");
            }
            onRoute(null);
        }
    }
    Camel.processRouteXml = processRouteXml;
    /**
     * Returns the URI string for the given EIP pattern node or null if it is not applicable
     * @method getRouteNodeUri
     * @param {Object} node
     * @return {String}
     */
    function getRouteNodeUri(node) {
        var uri = null;
        if (node) {
            uri = node.getAttribute("uri");
            if (!uri) {
                var ref = node.getAttribute("ref");
                if (ref) {
                    var method = node.getAttribute("method");
                    if (method) {
                        uri = ref + "." + method + "()";
                    }
                    else {
                        uri = "ref:" + ref;
                    }
                }
            }
        }
        return uri;
    }
    Camel.getRouteNodeUri = getRouteNodeUri;
    /**
     * Returns the JSON data for the camel folder; extracting it from the associated
     * routeXmlNode or using the previously extracted and/or edited JSON
     * @method getRouteFolderJSON
     * @param {Folder} folder
     * @param {Object} answer
     * @return {Object}
     */
    function getRouteFolderJSON(folder, answer) {
        if (answer === void 0) { answer = {}; }
        var nodeData = folder["camelNodeData"];
        if (!nodeData) {
            var routeXmlNode = folder["routeXmlNode"];
            if (routeXmlNode) {
                nodeData = Camel.getRouteNodeJSON(routeXmlNode);
            }
            if (!nodeData) {
                nodeData = answer;
            }
            folder["camelNodeData"] = nodeData;
        }
        return nodeData;
    }
    Camel.getRouteFolderJSON = getRouteFolderJSON;
    function getRouteNodeJSON(routeXmlNode, answer) {
        if (answer === void 0) { answer = {}; }
        if (routeXmlNode) {
            angular.forEach(routeXmlNode.attributes, function (attr) {
                answer[attr.name] = attr.value;
            });
            // lets not iterate into routes/rests or top level tags
            var localName = routeXmlNode.localName;
            if (localName !== "route" && localName !== "routes" && localName !== "camelContext" && localName !== "rests") {
                // lets look for nested elements and convert those
                // explicitly looking for expressions
                $(routeXmlNode).children("*").each(function (idx, element) {
                    var nodeName = element.localName;
                    var langSettings = Camel.camelLanguageSettings(nodeName);
                    if (langSettings) {
                        // TODO the expression key could be anything really; how should we know?
                        answer["expression"] = {
                            language: nodeName,
                            expression: element.textContent
                        };
                    }
                    else {
                        if (!isCamelPattern(nodeName)) {
                            var nested = getRouteNodeJSON(element);
                            if (nested) {
                                // unwrap the nested expression which we do not want to double wrap
                                if (nested["expression"]) {
                                    nested = nested["expression"];
                                }
                                // special for aggregate as it has duplicate option names
                                if (nodeName === "completionSize") {
                                    nodeName = "completionSizeExpression";
                                }
                                else if (nodeName === "completionTimeout") {
                                    nodeName = "completionTimeoutExpression";
                                }
                                answer[nodeName] = nested;
                            }
                        }
                    }
                });
            }
        }
        return answer;
    }
    Camel.getRouteNodeJSON = getRouteNodeJSON;
    function increaseIndent(currentIndent, indentAmount) {
        if (indentAmount === void 0) { indentAmount = "  "; }
        return currentIndent + indentAmount;
    }
    Camel.increaseIndent = increaseIndent;
    function setRouteNodeJSON(routeXmlNode, newData, indent) {
        if (routeXmlNode) {
            var childIndent = increaseIndent(indent);
            function doUpdate(value, key, append) {
                if (append === void 0) { append = false; }
                if (angular.isArray(value)) {
                    // remove previous nodes
                    $(routeXmlNode).children(key).remove();
                    angular.forEach(value, function (item) {
                        doUpdate(item, key, true);
                    });
                }
                else if (angular.isObject(value)) {
                    // convert languages to the right xml
                    var textContent = null;
                    if (key === "expression") {
                        var languageName = value["language"];
                        if (languageName) {
                            key = languageName;
                            textContent = value["expression"];
                            value = angular.copy(value);
                            delete value["expression"];
                            delete value["language"];
                        }
                    }
                    // TODO deal with nested objects...
                    var nested = $(routeXmlNode).children(key);
                    var element = null;
                    if (append || !nested || !nested.length) {
                        var doc = routeXmlNode.ownerDocument || document;
                        routeXmlNode.appendChild(doc.createTextNode("\n" + childIndent));
                        element = doc.createElementNS(routeXmlNode.namespaceURI, key);
                        if (textContent) {
                            element.appendChild(doc.createTextNode(textContent));
                        }
                        routeXmlNode.appendChild(element);
                    }
                    else {
                        element = nested[0];
                    }
                    setRouteNodeJSON(element, value, childIndent);
                    if (textContent) {
                        nested.text(textContent);
                    }
                }
                else {
                    if (value) {
                        if (_.startsWith(key, "_")) {
                            // ignore
                        }
                        else {
                            var text = value.toString();
                            routeXmlNode.setAttribute(key, text);
                        }
                    }
                    else {
                        routeXmlNode.removeAttribute(key);
                    }
                }
            }
            angular.forEach(newData, function (value, key) { return doUpdate(value, key, false); });
        }
    }
    Camel.setRouteNodeJSON = setRouteNodeJSON;
    function getRouteNodeIcon(nodeSettingsOrXmlNode) {
        var nodeSettings = null;
        if (nodeSettingsOrXmlNode) {
            var nodeName = nodeSettingsOrXmlNode.localName;
            if (nodeName) {
                nodeSettings = getCamelSchema(nodeName);
            }
            else {
                nodeSettings = nodeSettingsOrXmlNode;
            }
        }
        if (nodeSettings) {
            var imageName = nodeSettings["icon"] || "generic24.png";
            return UrlHelpers.join("img/icons/camel/", imageName);
        }
        else {
            return null;
        }
    }
    Camel.getRouteNodeIcon = getRouteNodeIcon;
    /**
     * Parse out the currently selected endpoint's name to be used when invoking on a
     * context operation that wants an endpoint name
     * @method getSelectedEndpointName
     * @param {Workspace} workspace
     * @return {any} either a string that is the endpoint name or null if it couldn't be parsed
     */
    function getSelectedEndpointName(workspace) {
        var selection = workspace.selection;
        if (selection && selection['objectName'] && selection['typeName'] && selection['typeName'] === 'endpoints') {
            var mbean = Core.parseMBean(selection['objectName']);
            if (!mbean) {
                return null;
            }
            var attributes = mbean['attributes'];
            if (!attributes) {
                return null;
            }
            if (!('name' in attributes)) {
                return null;
            }
            var uri = attributes['name'];
            uri = uri.replace("\\?", "?");
            if (_.startsWith(uri, "\"")) {
                uri = uri.substr(1);
            }
            if (_.endsWith(uri, "\"")) {
                uri = uri.substr(0, uri.length - 1);
            }
            return uri;
        }
        else {
            return null;
        }
    }
    Camel.getSelectedEndpointName = getSelectedEndpointName;
    /**
     * Escapes the given URI text so it can be used in a JMX name
     */
    function escapeEndpointUriNameForJmx(uri) {
        if (angular.isString(uri)) {
            var answer = uri.replace("?", "\\?");
            // lets ensure that we have a "//" after each ":"
            answer = answer.replace(/\:(\/[^\/])/, "://$1");
            answer = answer.replace(/\:([^\/])/, "://$1");
            return answer;
        }
        else {
            return uri;
        }
    }
    Camel.escapeEndpointUriNameForJmx = escapeEndpointUriNameForJmx;
    /**
     * Returns the mbean for the currently selected camel context and the name of the currently
     * selected endpoint for JMX operations on a context that require an endpoint name.
     * @method
     * @param workspace
     * @return {{uri: string, mbean: string}} either value could be null if there's a parse failure
     */
    function getContextAndTargetEndpoint(workspace) {
        return {
            uri: Camel.getSelectedEndpointName(workspace),
            mbean: Camel.getSelectionCamelContextMBean(workspace)
        };
    }
    Camel.getContextAndTargetEndpoint = getContextAndTargetEndpoint;
    /**
     * Returns the cached Camel XML route node stored in the current tree selection Folder
     * @method
     */
    function getSelectedRouteNode(workspace) {
        var selection = workspace.selection || workspace.getSelectedMBean();
        return (selection && Camel.jmxDomain === selection.domain) ? selection["routeXmlNode"] : null;
    }
    Camel.getSelectedRouteNode = getSelectedRouteNode;
    /**
     * Returns true when the selected node is a Camel XML route node, false otherwise.
     * @method
     */
    function isRouteNode(workspace) {
        var selection = workspace.selection || workspace.getSelectedMBean();
        return selection && Camel.jmxDomain === selection.domain && "routeXmlNode" in selection;
    }
    Camel.isRouteNode = isRouteNode;
    /**
     * Looks up the given node name in the Camel schema
     * @method
     */
    function getCamelSchema(nodeIdOrDefinition) {
        return (angular.isObject(nodeIdOrDefinition)) ? nodeIdOrDefinition : Forms.lookupDefinition(nodeIdOrDefinition, Camel._apacheCamelModel);
    }
    Camel.getCamelSchema = getCamelSchema;
    /**
     * Returns true if the given nodeId is a route, endpoint or pattern
     * (and not some nested type like a data format)
     * @method
     */
    function isCamelPattern(nodeId) {
        return Forms.lookupDefinition(nodeId, Camel._apacheCamelModel) != null;
    }
    Camel.isCamelPattern = isCamelPattern;
    /**
     * Looks up the Camel language settings for the given language name
     * @method
     */
    function camelLanguageSettings(nodeName) {
        return Camel._apacheCamelModel.languages[nodeName];
    }
    Camel.camelLanguageSettings = camelLanguageSettings;
    function isCamelLanguage(nodeName) {
        return (camelLanguageSettings(nodeName) || nodeName === "expression") ? true : false;
    }
    Camel.isCamelLanguage = isCamelLanguage;
    /**
     * Adds the route children to the given folder for each step in the route
     * @method
     */
    function loadRouteChildren(folder, route) {
        folder['routeXmlNode'] = route;
        route.setAttribute('_cid', folder.key);
        var children = [];
        $(route).children('*').each(function (idx, node) {
            children.push(loadRouteChild(folder, node));
        });
        return _.compact(children);
    }
    Camel.loadRouteChildren = loadRouteChildren;
    /**
     * Adds a child to the given folder / route
     * @method
     */
    function loadRouteChild(parent, route) {
        var nodeName = route.localName;
        var nodeSettings = getCamelSchema(nodeName);
        if (nodeSettings) {
            var imageUrl = getRouteNodeIcon(nodeSettings);
            var node = new Jmx.Folder(nodeName);
            node.domain = Camel.jmxDomain;
            node.typeName = 'routeNode';
            updateRouteNodeLabelAndTooltip(node, route, nodeSettings);
            // TODO should maybe auto-generate these?
            node.folderNames = parent.folderNames;
            var id = route.getAttribute('id') || nodeName;
            var key = parent.key + '_' + Core.toSafeDomID(id);
            // lets find the next key thats unique
            var counter = 1;
            var notFound = true;
            while (notFound) {
                var tmpKey = key + counter;
                if (_.find(parent.children, { key: tmpKey })) {
                    counter += 1;
                }
                else {
                    notFound = false;
                    key = tmpKey;
                }
            }
            node.key = key;
            node.image = imageUrl;
            node['routeXmlNode'] = route;
            var children = loadRouteChildren(node, route);
            children.forEach(function (child) { return node.moveChild(child); });
            return node;
        }
    }
    /**
     * Returns the root JMX Folder of the camel mbeans
     */
    function getRootCamelFolder(workspace) {
        var tree = workspace ? workspace.tree : null;
        if (tree) {
            return tree.get(Camel.jmxDomain);
        }
        return null;
    }
    Camel.getRootCamelFolder = getRootCamelFolder;
    /**
     * Returns the JMX folder for the camel context
     */
    function getCamelContextFolder(workspace, camelContextId) {
        var answer = null;
        var root = getRootCamelFolder(workspace);
        if (root && camelContextId) {
            return root.findDescendant(function (node) { return camelContextId === node.text; });
        }
        return answer;
    }
    Camel.getCamelContextFolder = getCamelContextFolder;
    /**
     * Returns the mbean for the given camel context ID or null if it cannot be found
     */
    function getCamelContextMBean(workspace, camelContextId) {
        var contextsFolder = getCamelContextFolder(workspace, camelContextId);
        if (contextsFolder) {
            return contextsFolder.objectName;
        }
        return null;
    }
    Camel.getCamelContextMBean = getCamelContextMBean;
    function getFolderCamelNodeId(folder) {
        var answer = Core.pathGet(folder, ["routeXmlNode", "localName"]);
        return ("from" === answer || "to" === answer) ? "endpoint" : answer;
    }
    Camel.getFolderCamelNodeId = getFolderCamelNodeId;
    /**
     * Rebuilds the DOM tree from the tree node and performs all the various hacks
     * to turn the folder / JSON / model into valid camel XML
     * such as renaming language elements from <language expression="foo" language="bar/>
     * to <bar>foo</bar>
     * and changing <endpoint> into either <from> or <to>
     * @method
     * @param treeNode is either the Node from the tree widget (with the real Folder in the data property) or a Folder
     */
    function createFolderXmlTree(treeNode, xmlNode, indent) {
        if (indent === void 0) { indent = Camel.increaseIndent(""); }
        var folder = treeNode.data || treeNode;
        var count = 0;
        var parentName = getFolderCamelNodeId(folder);
        if (folder) {
            if (!xmlNode) {
                xmlNode = document.createElement(parentName);
                var rootJson = Camel.getRouteFolderJSON(folder);
                if (rootJson) {
                    Camel.setRouteNodeJSON(xmlNode, rootJson, indent);
                }
            }
            var doc = xmlNode.ownerDocument || document;
            var namespaceURI = xmlNode.namespaceURI;
            var from = parentName !== "route";
            var childIndent = Camel.increaseIndent(indent);
            angular.forEach(treeNode.children || treeNode.getChildren(), function (childTreeNode) {
                var childFolder = childTreeNode.data || childTreeNode;
                var name = Camel.getFolderCamelNodeId(childFolder);
                var json = Camel.getRouteFolderJSON(childFolder);
                if (name && json) {
                    var language = false;
                    if (name === "endpoint") {
                        if (from) {
                            name = "to";
                        }
                        else {
                            name = "from";
                            from = true;
                        }
                    }
                    if (name === "expression") {
                        var languageName = json["language"];
                        if (languageName) {
                            name = languageName;
                            language = true;
                        }
                    }
                    // lets create the XML
                    xmlNode.appendChild(doc.createTextNode("\n" + childIndent));
                    var newNode = doc.createElementNS(namespaceURI, name);
                    Camel.setRouteNodeJSON(newNode, json, childIndent);
                    xmlNode.appendChild(newNode);
                    count += 1;
                    createFolderXmlTree(childTreeNode, newNode, childIndent);
                }
            });
            if (count) {
                xmlNode.appendChild(doc.createTextNode("\n" + indent));
            }
        }
        return xmlNode;
    }
    Camel.createFolderXmlTree = createFolderXmlTree;
    function updateRouteNodeLabelAndTooltip(folder, routeXmlNode, nodeSettings) {
        var localName = routeXmlNode.localName;
        var id = routeXmlNode.getAttribute("id");
        var label = nodeSettings["title"] || localName;
        // lets use the ID for routes and other things we give an id
        var tooltip = nodeSettings["tooltip"] || nodeSettings["description"] || label;
        if (id) {
            label = id;
        }
        else {
            var uri = getRouteNodeUri(routeXmlNode);
            if (uri) {
                // Don't use from/to as it gets odd if you drag/drop and reorder
                // label += " " + uri;
                label = uri;
                var split = uri.split("?");
                if (split && split.length > 1) {
                    label = split[0];
                }
                tooltip += " " + uri;
            }
            else {
                var children = $(routeXmlNode).children("*");
                if (children && children.length) {
                    var child = children[0];
                    var childName = child.localName;
                    var expression = null;
                    if (Camel.isCamelLanguage(childName)) {
                        expression = child.textContent;
                        if (!expression) {
                            expression = child.getAttribute("expression");
                        }
                    }
                    if (expression) {
                        label += " " + expression;
                        tooltip += " " + childName + " expression";
                    }
                }
            }
        }
        folder.text = label;
        folder.tooltip = tooltip;
        return label;
    }
    Camel.updateRouteNodeLabelAndTooltip = updateRouteNodeLabelAndTooltip;
    /**
     * Returns the selected camel context object name for the given selection or null if it cannot be found
     * @method
     */
    function getSelectionCamelContextMBean(workspace) {
        var context = getSelectionCamelContext(workspace);
        if (context) {
            return context.objectName;
        }
        return null;
    }
    Camel.getSelectionCamelContextMBean = getSelectionCamelContextMBean;
    /**
     * Returns the selected camel context object name for the given selection or null if it cannot be found
     * @method
     */
    function getSelectionCamelContext(workspace) {
        if (workspace) {
            var contextId_1 = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain_1 = selection.domain;
                if (domain_1 && contextId_1) {
                    return tree.findDescendant(function (node) { return node.typeName === 'context'
                        && node.domain === domain_1
                        && node.text === contextId_1; });
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelContext = getSelectionCamelContext;
    /**
     * When lazy loading route info (using dumpRoutesAsXml() operation) we need MBean name from the folder
     * and *not* from the selection
     * @param {Workspace} workspace
     * @param {Folder} folder
     */
    function getExpandingFolderCamelContextMBean(workspace, folder) {
        if (folder.entries && folder.entries['type'] === 'routes') {
            var context = workspace.tree.findDescendant(function (node) { return node.typeName === 'context'
                && node.domain === 'org.apache.camel'
                && node.text === folder.entries['context']; });
            if (context) {
                return context.objectName;
            }
        }
        return null;
    }
    Camel.getExpandingFolderCamelContextMBean = getExpandingFolderCamelContextMBean;
    function getSelectionCamelContextEndpoints(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    return tree.navigate(domain, 'Camel Contexts', contextId, 'endpoints');
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelContextEndpoints = getSelectionCamelContextEndpoints;
    /**
     * Returns the selected camel trace mbean for the given selection or null if it cannot be found
     * @method
     */
    // TODO Should be a service
    function getSelectionCamelTraceMBean(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    // look for the Camel 2.11 mbean which we prefer
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'tracer');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'BacklogTracer'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelTraceMBean = getSelectionCamelTraceMBean;
    function getSelectionCamelDebugMBean(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'tracer');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'BacklogDebugger'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelDebugMBean = getSelectionCamelDebugMBean;
    function getSelectionCamelTypeConverter(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'DefaultTypeConverter'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelTypeConverter = getSelectionCamelTypeConverter;
    function getSelectionCamelRestRegistry(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'DefaultRestRegistry'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelRestRegistry = getSelectionCamelRestRegistry;
    function getSelectionCamelEndpointRuntimeRegistry(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'DefaultRuntimeEndpointRegistry'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelEndpointRuntimeRegistry = getSelectionCamelEndpointRuntimeRegistry;
    function getSelectionCamelInflightRepository(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'DefaultInflightRepository'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelInflightRepository = getSelectionCamelInflightRepository;
    function getSelectionCamelBlockedExchanges(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'DefaultAsyncProcessorAwaitManager'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelBlockedExchanges = getSelectionCamelBlockedExchanges;
    function getSelectionCamelRouteMetrics(workspace) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'MBeans', 'services');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return _.startsWith(m.text, 'MetricsRegistryService'); });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionCamelRouteMetrics = getSelectionCamelRouteMetrics;
    // TODO should be a service
    function getContextId(workspace) {
        var selection = workspace.selection;
        if (selection) {
            var context = selection.findAncestor(function (ancestor) { return ancestor.typeName === 'context'; });
            if (context) {
                return context.text;
            }
        }
    }
    Camel.getContextId = getContextId;
    function iconClass(state) {
        if (state) {
            switch (state.toLowerCase()) {
                case 'started':
                    return "green fa fa-play-circle";
                case 'suspended':
                    return "fa fa-pause";
            }
        }
        return "orange fa fa-off";
    }
    Camel.iconClass = iconClass;
    function getSelectedRouteId(workspace, folder) {
        var selection = folder || workspace.selection;
        var selectedRouteId = null;
        if (selection) {
            if (selection && selection.entries) {
                var typeName = selection.entries["type"];
                var name = selection.entries["name"];
                if ("routes" === typeName && name) {
                    selectedRouteId = Core.trimQuotes(name);
                }
            }
        }
        return selectedRouteId;
    }
    Camel.getSelectedRouteId = getSelectedRouteId;
    /**
     * Returns the selected camel route mbean for the given route id
     * @method
     */
    // TODO Should be a service
    function getSelectionRouteMBean(workspace, routeId) {
        if (workspace) {
            var contextId = getContextId(workspace);
            var selection = workspace.selection;
            var tree = workspace.tree;
            if (tree && selection) {
                var domain = selection.domain;
                if (domain && contextId) {
                    var result = tree.navigate(domain, 'Camel Contexts', contextId, 'routes');
                    if (result && result.children) {
                        var mbean = _.find(result.children, function (m) { return m.text === routeId; });
                        if (mbean) {
                            return mbean.objectName;
                        }
                    }
                }
            }
        }
        return null;
    }
    Camel.getSelectionRouteMBean = getSelectionRouteMBean;
    function getCamelVersion(workspace, jolokia) {
        var context = getSelectionCamelContext(workspace);
        if (context) {
            // must use onSuccess(null) that means sync as we need the version asap
            var version = jolokia.getAttribute(context.objectName, 'CamelVersion', Core.onSuccess(null));
            // cache version so we do not need to read it again using jolokia
            context.version = version;
            return version;
        }
        return null;
    }
    Camel.getCamelVersion = getCamelVersion;
    function createMessageFromXml(exchange) {
        var exchangeElement = $(exchange);
        var uid = exchangeElement.children("uid").text();
        var timestamp = exchangeElement.children("timestamp").text();
        var messageData = {
            headers: {},
            headerTypes: {},
            id: null,
            uid: uid,
            timestamp: timestamp,
            headerHtml: ""
        };
        var message = exchangeElement.children("message")[0];
        if (!message) {
            message = exchange;
        }
        var messageElement = $(message);
        var headers = messageElement.find("header");
        var headerHtml = "";
        headers.each(function (idx, header) {
            var key = header.getAttribute("key");
            var typeName = header.getAttribute("type");
            var value = header.textContent;
            if (key) {
                if (value)
                    messageData.headers[key] = value;
                if (typeName)
                    messageData.headerTypes[key] = typeName;
                headerHtml += "<tr><td class='property-name'>" + key + "</td>" +
                    "<td class='property-value'>" + (humanizeJavaType(typeName)) + "</td>" +
                    "<td class='property-value'>" + (value || "") + "</td></tr>";
            }
        });
        messageData.headerHtml = headerHtml;
        var id = messageData.headers["breadcrumbId"];
        if (!id) {
            var postFixes = ["MessageID", "ID", "Path", "Name"];
            angular.forEach(postFixes, function (postfix) {
                if (!id) {
                    angular.forEach(messageData.headers, function (value, key) {
                        if (!id && _.endsWith(key, postfix)) {
                            id = value;
                        }
                    });
                }
            });
            // lets find the first header with a name or Path in it
            // if still no value, lets use the first :)
            angular.forEach(messageData.headers, function (value, key) {
                if (!id)
                    id = value;
            });
        }
        messageData.id = id;
        var body = messageElement.children("body")[0];
        if (body) {
            var bodyText = body.textContent;
            var bodyType = body.getAttribute("type");
            messageData["body"] = bodyText;
            messageData["bodyType"] = humanizeJavaType(bodyType);
        }
        return messageData;
    }
    Camel.createMessageFromXml = createMessageFromXml;
    function humanizeJavaType(type) {
        if (!type) {
            return "";
        }
        // skip leading java.lang
        if (_.startsWith(type, "java.lang")) {
            return type.substr(10);
        }
        return type;
    }
    Camel.humanizeJavaType = humanizeJavaType;
    function createBrowseGridOptions() {
        return {
            selectedItems: [],
            data: 'messages',
            displayFooter: false,
            showFilter: false,
            showColumnMenu: true,
            enableColumnResize: true,
            enableColumnReordering: true,
            filterOptions: {
                filterText: ''
            },
            selectWithCheckboxOnly: true,
            showSelectionCheckbox: true,
            maintainColumnRatios: false,
            columnDefs: [
                {
                    field: 'id',
                    displayName: 'ID',
                    // for ng-grid
                    //width: '50%',
                    // for hawtio-datatable
                    // width: "22em",
                    cellTemplate: '<div class="ngCellText"><a href="" ng-click="row.entity.openMessageDialog(row)">{{row.entity.id}}</a></div>'
                }
            ]
        };
    }
    Camel.createBrowseGridOptions = createBrowseGridOptions;
    function loadRouteXmlNodes($scope, doc, selectedRouteId, nodes, links, width) {
        var allRoutes = $(doc).find("route");
        var routeDelta = width / allRoutes.length;
        var rowX = 0;
        allRoutes.each(function (idx, route) {
            var routeId = route.getAttribute("id");
            if (!selectedRouteId || !routeId || selectedRouteId === routeId) {
                Camel.addRouteXmlChildren($scope, route, nodes, links, null, rowX, 0);
                rowX += routeDelta;
            }
        });
    }
    Camel.loadRouteXmlNodes = loadRouteXmlNodes;
    function addRouteXmlChildren($scope, parent, nodes, links, parentId, parentX, parentY, parentNode) {
        if (parentNode === void 0) { parentNode = null; }
        var delta = 150;
        var x = parentX;
        var y = parentY + delta;
        var rid = parent.getAttribute("id");
        var siblingNodes = [];
        var parenNodeName = parent.localName;
        $(parent).children().each(function (idx, route) {
            var id = nodes.length;
            // from acts as a parent even though its a previous sibling :)
            var nodeId = route.localName;
            if (nodeId === "from" && !parentId) {
                parentId = id;
            }
            var nodeSettings = getCamelSchema(nodeId);
            var node = null;
            if (nodeSettings) {
                var label = nodeSettings["title"] || nodeId;
                var uri = getRouteNodeUri(route);
                if (uri) {
                    label += " " + uri.split("?")[0];
                }
                var tooltip = nodeSettings["tooltip"] || nodeSettings["description"] || label;
                if (uri) {
                    tooltip += " " + uri;
                }
                var elementID = route.getAttribute("id");
                var labelSummary = label;
                if (elementID) {
                    var customId = route.getAttribute("customId");
                    if ($scope.camelIgnoreIdForLabel || (!customId || customId === "false")) {
                        labelSummary = "id: " + elementID;
                    }
                    else {
                        label = elementID;
                    }
                }
                // lets check if we need to trim the label
                var labelLimit = $scope.camelMaximumLabelWidth || Camel.defaultMaximumLabelWidth;
                var length = label.length;
                if (length > labelLimit) {
                    labelSummary = label + "\n\n" + labelSummary;
                    label = label.substring(0, labelLimit) + "..";
                }
                var imageUrl = getRouteNodeIcon(nodeSettings);
                if ((nodeId === "from" || nodeId === "to") && uri) {
                    var uriIdx = uri.indexOf(":");
                    if (uriIdx > 0) {
                        var componentScheme = uri.substring(0, uriIdx);
                        //console.log("lets find the endpoint icon for " + componentScheme);
                        if (componentScheme) {
                            var value = Camel.getEndpointIcon(componentScheme);
                            if (value) {
                                imageUrl = Core.url(value);
                            }
                        }
                    }
                }
                //console.log("Image URL is " + imageUrl);
                var cid = route.getAttribute("_cid") || route.getAttribute("id");
                node = { "name": name, "label": label, "labelSummary": labelSummary, "group": 1, "id": id, "elementId": elementID,
                    "x": x, "y:": y, "imageUrl": imageUrl, "cid": cid, "tooltip": tooltip, "type": nodeId, "uri": uri };
                if (rid) {
                    node["rid"] = rid;
                    if (!$scope.routeNodes)
                        $scope.routeNodes = {};
                    $scope.routeNodes[rid] = node;
                }
                if (!cid) {
                    cid = nodeId + (nodes.length + 1);
                }
                if (cid) {
                    node["cid"] = cid;
                    if (!$scope.nodes)
                        $scope.nodes = {};
                    $scope.nodes[cid] = node;
                }
                // only use the route id on the first from node
                rid = null;
                nodes.push(node);
                if (parentId !== null && parentId !== id) {
                    if (siblingNodes.length === 0 || parenNodeName === "choice") {
                        links.push({ "source": parentId, "target": id, "value": 1 });
                    }
                    else {
                        siblingNodes.forEach(function (nodeId) {
                            links.push({ "source": nodeId, "target": id, "value": 1 });
                        });
                        siblingNodes.length = 0;
                    }
                }
            }
            else {
                // ignore non EIP nodes, though we should add expressions...
                var langSettings = Camel.camelLanguageSettings(nodeId);
                if (langSettings && parentNode) {
                    // lets add the language kind
                    var name = langSettings["name"] || nodeId;
                    var text = route.textContent;
                    if (text) {
                        parentNode["tooltip"] = parentNode["label"] + " " + name + " " + text;
                        parentNode["label"] += ": " + appendLabel(route, text, true);
                    }
                    else {
                        parentNode["label"] += ": " + appendLabel(route, name, false);
                    }
                }
            }
            var siblings = addRouteXmlChildren($scope, route, nodes, links, id, x, y, node);
            if (parenNodeName === "choice") {
                siblingNodes = siblingNodes.concat(siblings);
                x += delta;
            }
            else if (nodeId === "choice") {
                siblingNodes = siblings;
                y += delta;
            }
            else {
                siblingNodes = [nodes.length - 1];
                y += delta;
            }
        });
        return siblingNodes;
    }
    Camel.addRouteXmlChildren = addRouteXmlChildren;
    function appendLabel(route, label, text) {
        switch (route.localName) {
            case "method":
                if (!text) {
                    if (route.getAttribute("bean")) {
                        label += " " + route.getAttribute("bean");
                    }
                    else if (route.getAttribute("ref")) {
                        label += " " + route.getAttribute("ref");
                    }
                    else if (route.getAttribute("beanType")) {
                        label += " " + route.getAttribute("beanType");
                    }
                }
                if (route.getAttribute("method")) {
                    label += " " + route.getAttribute("method");
                }
                break;
            default:
        }
        return label;
    }
    /**
     * Returns an object of all the CamelContext MBeans keyed by their id
     * @method
     */
    function camelContextMBeansById(workspace) {
        var answer = {};
        var tree = workspace.tree;
        if (tree) {
            var contexts = tree.navigate(Camel.jmxDomain, 'Camel Contexts');
            if (contexts) {
                angular.forEach(contexts.children, function (context) {
                    var id = Core.pathGet(context, ['entries', 'name']) || context.key;
                    if (id) {
                        answer[id] = context;
                    }
                });
            }
        }
        return answer;
    }
    Camel.camelContextMBeansById = camelContextMBeansById;
    /**
     * Returns an object of all the CamelContext MBeans keyed by the component name
     * @method
     */
    function camelContextMBeansByComponentName(workspace) {
        return camelContextMBeansByRouteOrComponentId(workspace, 'components');
    }
    Camel.camelContextMBeansByComponentName = camelContextMBeansByComponentName;
    /**
     * Returns an object of all the CamelContext MBeans keyed by the route ID
     * @method
     */
    function camelContextMBeansByRouteId(workspace) {
        return camelContextMBeansByRouteOrComponentId(workspace, 'routes');
    }
    Camel.camelContextMBeansByRouteId = camelContextMBeansByRouteId;
    function camelContextMBeansByRouteOrComponentId(workspace, componentsOrRoutes) {
        var answer = {};
        var tree = workspace.tree;
        if (tree) {
            var contexts = tree.navigate(Camel.jmxDomain, 'Camel Contexts');
            if (contexts) {
                angular.forEach(contexts.children, function (context) {
                    var components = context.navigate(componentsOrRoutes);
                    if (context && components && context.children && context.children.length) {
                        var mbean = context.objectName;
                        if (mbean) {
                            var contextValues_1 = {
                                folder: context,
                                mbean: mbean
                            };
                            angular.forEach(components.children, function (componentFolder) {
                                var id = componentFolder.text;
                                if (id) {
                                    answer[id] = contextValues_1;
                                }
                            });
                        }
                    }
                });
            }
        }
        return answer;
    }
    /**
     * Returns true if we should ignore ID values for labels in camel diagrams
     * @method
     */
    function ignoreIdForLabel(localStorage) {
        var value = localStorage["camelIgnoreIdForLabel"];
        return Core.parseBooleanValue(value);
    }
    Camel.ignoreIdForLabel = ignoreIdForLabel;
    /**
     * Returns the maximum width of a label before we start to truncate
     * @method
     */
    function maximumLabelWidth(localStorage) {
        var value = localStorage["camelMaximumLabelWidth"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultMaximumLabelWidth;
        }
        return value;
    }
    Camel.maximumLabelWidth = maximumLabelWidth;
    /**
     * Returns the max body length for tracer and debugger
     * @method
     */
    function maximumTraceOrDebugBodyLength(localStorage) {
        var value = localStorage["camelMaximumTraceOrDebugBodyLength"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultCamelMaximumTraceOrDebugBodyLength;
        }
        return value;
    }
    Camel.maximumTraceOrDebugBodyLength = maximumTraceOrDebugBodyLength;
    /**
     * Returns whether to include streams body for tracer and debugger
     * @method
     */
    function traceOrDebugIncludeStreams(localStorage) {
        var value = localStorage["camelTraceOrDebugIncludeStreams"];
        return Core.parseBooleanValue(value, Camel.defaultCamelTraceOrDebugIncludeStreams);
    }
    Camel.traceOrDebugIncludeStreams = traceOrDebugIncludeStreams;
    /**
     * Returns true if we should show inflight counter in Camel route diagram
     * @method
     */
    function showInflightCounter(localStorage) {
        var value = localStorage["camelShowInflightCounter"];
        // is default enabled
        return Core.parseBooleanValue(value, true);
    }
    Camel.showInflightCounter = showInflightCounter;
    /**
     * Returns the max value for seconds in the route metrics UI
     * @method
     */
    function routeMetricMaxSeconds(localStorage) {
        var value = localStorage["camelRouteMetricMaxSeconds"];
        if (angular.isString(value)) {
            value = parseInt(value);
        }
        if (!value) {
            value = Camel.defaultCamelRouteMetricMaxSeconds;
        }
        return value;
    }
    Camel.routeMetricMaxSeconds = routeMetricMaxSeconds;
    /**
     * Whether to hide the documentation for the options
     * @method
     */
    function hideOptionDocumentation(localStorage) {
        var value = localStorage["camelHideOptionDocumentation"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionDocumentation);
    }
    Camel.hideOptionDocumentation = hideOptionDocumentation;
    /**
     * Whether to hide options which uses default values
     * @method
     */
    function hideOptionDefaultValue(localStorage) {
        var value = localStorage["camelHideOptionDefaultValue"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionDefaultValue);
    }
    Camel.hideOptionDefaultValue = hideOptionDefaultValue;
    /**
     * Whether to hide options which have unused/empty values
     * @method
     */
    function hideOptionUnusedValue(localStorage) {
        var value = localStorage["camelHideOptionUnusedValue"];
        return Core.parseBooleanValue(value, Camel.defaultHideOptionUnusedValue);
    }
    Camel.hideOptionUnusedValue = hideOptionUnusedValue;
    /**
     * Function to highlight the selected toNode in the nodes graph
     *
     * @param nodes the nodes
     * @param toNode the node to highlight
     */
    function highlightSelectedNode(nodes, toNode) {
        // lets clear the selected node first
        nodes.classed("selected", false);
        nodes.filter(function (item) {
            if (item) {
                var cid = item["cid"];
                var rid = item["rid"];
                var type = item["type"];
                var elementId = item["elementId"];
                // if its from then match on rid
                if ("from" === type) {
                    return toNode === rid;
                }
                // okay favor using element id as the cids can become
                // undefined or mangled with mbean object names, causing this to not work
                // where as elementId when present works fine
                if (elementId) {
                    // we should match elementId if defined
                    return toNode === elementId;
                }
                // then fallback to cid
                if (cid) {
                    return toNode === cid;
                }
                else {
                    // and last rid
                    return toNode === rid;
                }
            }
            return null;
        }).classed("selected", true);
    }
    Camel.highlightSelectedNode = highlightSelectedNode;
    /**
     * Is the currently selected Camel version equal or greater than
     *
     * @param major   major version as number
     * @param minor   minor version as number
     */
    function isCamelVersionEQGT(major, minor, workspace, jolokia) {
        var camelVersion = getCamelVersion(workspace, jolokia);
        if (camelVersion) {
            // console.log("Camel version " + camelVersion)
            camelVersion += "camel-";
            var numbers = Core.parseVersionNumbers(camelVersion);
            if (Core.compareVersionNumberArrays(numbers, [major, minor]) >= 0) {
                return true;
            }
            else {
                return false;
            }
        }
        return false;
    }
    Camel.isCamelVersionEQGT = isCamelVersionEQGT;
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    var Context = /** @class */ (function () {
        function Context(name, state, mbean) {
            this.name = name;
            this.state = state;
            this.mbean = mbean;
            this.selected = false;
        }
        Context.prototype.isStarted = function () {
            return this.state === 'Started';
        };
        Context.prototype.isSuspended = function () {
            return this.state === 'Suspended';
        };
        return Context;
    }());
    Camel.Context = Context;
})(Camel || (Camel = {}));
/// <reference path="context.ts"/>
var Camel;
(function (Camel) {
    var ContextsService = /** @class */ (function () {
        ContextsService.$inject = ["$q", "jolokia"];
        function ContextsService($q, jolokia) {
            'ngInject';
            this.$q = $q;
            this.jolokia = jolokia;
            this.log = Logger.get("Camel");
        }
        ContextsService.prototype.getContext = function (mbean) {
            var _this = this;
            var request = {
                type: "read",
                mbean: mbean,
                ignoreErrors: true
            };
            return this.$q(function (resolve, reject) {
                var contexts = [];
                _this.jolokia.request(request, {
                    success: function (response) {
                        var object = response.value;
                        var context = new Camel.Context(object.CamelId, object.State, response.request.mbean);
                        resolve(context);
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('ContextsService.getContext() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        ContextsService.prototype.getContexts = function (mbeans) {
            var _this = this;
            if (mbeans.length === 0) {
                return this.$q.resolve([]);
            }
            var requests = mbeans.map(function (mbean) { return ({
                type: "read",
                mbean: mbean,
                ignoreErrors: true
            }); });
            return this.$q(function (resolve, reject) {
                var contexts = [];
                _this.jolokia.request(requests, {
                    success: function (response) {
                        var object = response.value;
                        var context = new Camel.Context(object.CamelId, object.State, response.request.mbean);
                        contexts.push(context);
                        if (contexts.length === requests.length) {
                            resolve(contexts);
                        }
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('ContextsService.getContexts() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        ContextsService.prototype.startContext = function (context) {
            return this.startContexts([context]);
        };
        ContextsService.prototype.startContexts = function (contexts) {
            return this.executeOperationOnContexts('start()', contexts);
        };
        ContextsService.prototype.suspendContext = function (context) {
            return this.suspendContexts([context]);
        };
        ContextsService.prototype.suspendContexts = function (contexts) {
            return this.executeOperationOnContexts('suspend()', contexts);
        };
        ContextsService.prototype.stopContext = function (context) {
            return this.stopContexts([context]);
        };
        ContextsService.prototype.stopContexts = function (contexts) {
            return this.executeOperationOnContexts('stop()', contexts);
        };
        ContextsService.prototype.executeOperationOnContexts = function (operation, contexts) {
            var _this = this;
            if (contexts.length === 0) {
                return this.$q.resolve('success');
            }
            var requests = contexts.map(function (context) { return ({
                type: 'exec',
                operation: operation,
                mbean: context.mbean
            }); });
            return this.$q(function (resolve, reject) {
                var contexts = [];
                var responseCount = 0;
                _this.jolokia.request(requests, {
                    success: function (response) {
                        responseCount++;
                        if (responseCount === requests.length) {
                            resolve('success');
                        }
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('ContextsService.executeOperationOnContexts() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        return ContextsService;
    }());
    Camel.ContextsService = ContextsService;
})(Camel || (Camel = {}));
/// <reference path="context.ts"/>
/// <reference path="contexts.service.ts"/>
var Camel;
(function (Camel) {
    var ContextsController = /** @class */ (function () {
        ContextsController.$inject = ["$uibModal", "workspace", "contextsService"];
        function ContextsController($uibModal, workspace, contextsService) {
            'ngInject';
            var _this = this;
            this.$uibModal = $uibModal;
            this.workspace = workspace;
            this.contextsService = contextsService;
            this.startAction = {
                name: 'Start',
                actionFn: function (action) {
                    var selectedContexts = _this.getSelectedContexts();
                    _this.contextsService.startContexts(selectedContexts)
                        .then(function (response) { return _this.updateContexts(); });
                },
                isDisabled: true
            };
            this.suspendAction = {
                name: 'Suspend',
                actionFn: function (action) {
                    var selectedContexts = _this.getSelectedContexts();
                    _this.contextsService.suspendContexts(selectedContexts)
                        .then(function (response) { return _this.updateContexts(); });
                },
                isDisabled: true
            };
            this.deleteAction = {
                name: 'Delete',
                actionFn: function (action) {
                    _this.$uibModal.open({
                        templateUrl: 'plugins/camel/html/deleteContextModal.html'
                    })
                        .result.then(function () {
                        var selectedContexts = _this.getSelectedContexts();
                        _this.contextsService.stopContexts(selectedContexts)
                            .then(function (response) { return _this.removeSelectedContexts(); });
                    });
                },
                isDisabled: true
            };
            this.toolbarConfig = {
                actionsConfig: {
                    primaryActions: [
                        this.startAction,
                        this.suspendAction
                    ],
                    moreActions: [
                        this.deleteAction
                    ]
                }
            };
            this.tableConfig = {
                selectionMatchProp: "name",
                onCheckBoxChange: function (item) { return _this.enableDisableActions(); }
            };
            this.tableColummns = [
                { header: "Name", itemField: "name" },
                { header: "State", itemField: "state" }
            ];
            this.tableItems = [{ name: null, state: null }];
        }
        ContextsController.prototype.$onInit = function () {
            this.loadContexts();
        };
        ContextsController.prototype.getSelectedContexts = function () {
            var _this = this;
            return _.map(this.tableItems, function (tableItem, i) { return angular.extend(_this.contexts[i], { selected: tableItem['selected'] }); })
                .filter(function (context) { return context.selected; });
        };
        ContextsController.prototype.enableDisableActions = function () {
            var selectedContexts = this.getSelectedContexts();
            this.startAction.isDisabled = !selectedContexts.some(function (context) { return context.state === 'Suspended'; });
            this.suspendAction.isDisabled = !selectedContexts.some(function (context) { return context.state === 'Started'; });
            this.deleteAction.isDisabled = selectedContexts.length === 0;
        };
        ContextsController.prototype.loadContexts = function () {
            var _this = this;
            if (this.workspace.selection) {
                var typeNames = Jmx.getUniqueTypeNames(this.workspace.selection.children);
                if (typeNames.length > 1) {
                    console.error("Child nodes aren't of the same type. Found types: " + typeNames);
                }
                var mbeans = _.map(this.workspace.selection.children, function (node) { return node.objectName; });
                this.contextsService.getContexts(mbeans)
                    .then(function (contexts) {
                    _this.tableItems = _.map(contexts, function (context) { return ({
                        name: context.name,
                        state: context.state
                    }); });
                    _this.contexts = contexts;
                });
            }
        };
        ContextsController.prototype.updateContexts = function () {
            var _this = this;
            var mbeans = _.map(this.contexts, function (context) { return context.mbean; });
            this.contextsService.getContexts(mbeans)
                .then(function (contexts) {
                _this.contexts = contexts;
                contexts.forEach(function (context, i) { return _this.tableItems[i].state = context.state; });
                _this.enableDisableActions();
            });
        };
        ContextsController.prototype.removeSelectedContexts = function () {
            var _this = this;
            this.tableItems.forEach(function (tableItem, i) { return angular.extend(_this.contexts[i], { selected: tableItem['selected'] }); });
            _.remove(this.contexts, function (context) { return context.selected; });
            _.remove(this.tableItems, function (tableItem) { return tableItem['selected']; });
            this.workspace.loadTree();
            this.enableDisableActions();
        };
        return ContextsController;
    }());
    Camel.ContextsController = ContextsController;
    Camel.contextsComponent = {
        template: "\n      <pf-toolbar config=\"$ctrl.toolbarConfig\"></pf-toolbar>\n      <pf-table-view config=\"$ctrl.tableConfig\" colummns=\"$ctrl.tableColummns\" items=\"$ctrl.tableItems\"></pf-table-view>\n    ",
        controller: ContextsController
    };
})(Camel || (Camel = {}));
/// <reference path="contexts.service.ts"/>
/// <reference path="context.ts"/>
var Camel;
(function (Camel) {
    var ContextActionsController = /** @class */ (function () {
        ContextActionsController.$inject = ["$scope", "$uibModal", "$timeout", "workspace", "contextsService"];
        function ContextActionsController($scope, $uibModal, $timeout, workspace, contextsService) {
            'ngInject';
            var _this = this;
            this.$uibModal = $uibModal;
            this.$timeout = $timeout;
            this.workspace = workspace;
            this.contextsService = contextsService;
            this.context = null;
            $scope.$on('jmxTreeClicked', function (event, selectedNode) {
                if (workspace.isCamelContext()) {
                    contextsService.getContext(selectedNode.objectName)
                        .then(function (context) { return _this.context = context; });
                }
                else {
                    _this.context = null;
                }
            });
        }
        ContextActionsController.prototype.isVisible = function () {
            return this.context !== null;
        };
        ContextActionsController.prototype.start = function () {
            var _this = this;
            this.contextsService.startContext(this.context)
                .then(function (response) {
                _this.contextsService.getContext(_this.context.mbean)
                    .then(function (context) { return _this.context = context; });
            });
        };
        ContextActionsController.prototype.suspend = function () {
            var _this = this;
            this.contextsService.suspendContext(this.context)
                .then(function (response) {
                _this.contextsService.getContext(_this.context.mbean)
                    .then(function (context) { return _this.context = context; });
            });
        };
        ContextActionsController.prototype.delete = function () {
            var _this = this;
            this.$uibModal.open({
                templateUrl: 'plugins/camel/html/deleteContextWarningModal.html'
            })
                .result
                .then(function () {
                _this.contextsService.stopContext(_this.context)
                    .then(function (response) {
                    _this.context = null;
                    _this.workspace.removeAndSelectParentNode();
                });
            });
        };
        return ContextActionsController;
    }());
    Camel.ContextActionsController = ContextActionsController;
    Camel.contextActionsComponent = {
        template: "\n      <div class=\"dropdown camel-main-actions\" ng-show=\"$ctrl.isVisible()\">\n        <button type=\"button\" id=\"dropdownMenu1\" class=\"btn btn-default dropdown-toggle\"\n          data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\">\n          <span class=\"fa\" ng-class=\"{'fa-play': $ctrl.context.isStarted(), 'fa-pause': $ctrl.context.isSuspended()}\"></span>\n          &nbsp;\n          {{$ctrl.context.state}}\n          &nbsp;\n          <span class=\"caret\"></span>\n        </button>\n        <ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n          <li ng-class=\"{disabled: $ctrl.context.state === 'Started'}\">\n            <a href=\"#\" ng-click=\"$ctrl.start()\">Start</a>\n          </li>\n          <li ng-class=\"{disabled: $ctrl.context.state === 'Suspended'}\">\n            <a href=\"#\" ng-click=\"$ctrl.suspend()\">Suspend</a>\n          </li>\n          <li>\n            <a href=\"#\" ng-click=\"$ctrl.delete()\">Delete</a>\n          </li>\n        </ul>\n      </div>\n    ",
        controller: ContextActionsController
    };
})(Camel || (Camel = {}));
/// <reference path="contexts.component.ts"/>
/// <reference path="context-actions.component.ts"/>
/// <reference path="contexts.service.ts"/>
var Camel;
(function (Camel) {
    Camel.contextsModule = angular
        .module('hawtio-camel-contexts', [])
        .component('contexts', Camel.contextsComponent)
        .component('contextActions', Camel.contextActionsComponent)
        .service('contextsService', Camel.ContextsService)
        .name;
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    var Route = /** @class */ (function () {
        function Route(name, state, mbean) {
            this.name = name;
            this.state = state;
            this.mbean = mbean;
            this.selected = false;
        }
        Route.prototype.isStarted = function () {
            return this.state === 'Started';
        };
        Route.prototype.isStopped = function () {
            return this.state === 'Stopped';
        };
        return Route;
    }());
    Camel.Route = Route;
})(Camel || (Camel = {}));
/// <reference path="route.ts"/>
var Camel;
(function (Camel) {
    var RoutesService = /** @class */ (function () {
        RoutesService.$inject = ["$q", "jolokia"];
        function RoutesService($q, jolokia) {
            'ngInject';
            this.$q = $q;
            this.jolokia = jolokia;
            this.log = Logger.get("Camel");
        }
        RoutesService.prototype.getRoute = function (mbean) {
            var _this = this;
            var request = {
                type: "read",
                mbean: mbean,
                ignoreErrors: true
            };
            return this.$q(function (resolve, reject) {
                _this.jolokia.request(request, {
                    success: function (response) {
                        var object = response.value;
                        var route = new Camel.Route(object.RouteId, object.State, response.request.mbean);
                        resolve(route);
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('RoutesService.getRoute() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        RoutesService.prototype.getRoutes = function (mbeans) {
            var _this = this;
            if (mbeans.length === 0) {
                return this.$q.resolve([]);
            }
            var requests = mbeans.map(function (mbean) { return ({
                type: "read",
                mbean: mbean,
                ignoreErrors: true
            }); });
            return this.$q(function (resolve, reject) {
                var routes = [];
                _this.jolokia.request(requests, {
                    success: function (response) {
                        var object = response.value;
                        var route = new Camel.Route(object.RouteId, object.State, object.CamelManagementName);
                        routes.push(route);
                        if (routes.length === requests.length) {
                            resolve(routes);
                        }
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('RoutesService.getRoutes() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        RoutesService.prototype.startRoute = function (route) {
            return this.startRoutes([route]);
        };
        RoutesService.prototype.startRoutes = function (routes) {
            return this.executeOperationOnRoutes('start()', routes);
        };
        RoutesService.prototype.stopRoute = function (route) {
            return this.stopRoutes([route]);
        };
        RoutesService.prototype.stopRoutes = function (routes) {
            return this.executeOperationOnRoutes('stop()', routes);
        };
        RoutesService.prototype.removeRoute = function (route) {
            return this.removeRoutes([route]);
        };
        RoutesService.prototype.removeRoutes = function (routes) {
            return this.executeOperationOnRoutes('remove()', routes);
        };
        RoutesService.prototype.executeOperationOnRoutes = function (operation, routes) {
            var _this = this;
            if (routes.length === 0) {
                return this.$q.resolve('success');
            }
            var requests = routes.map(function (route) { return ({
                type: 'exec',
                operation: operation,
                mbean: route.mbean
            }); });
            return this.$q(function (resolve, reject) {
                var responseCount = 0;
                _this.jolokia.request(requests, {
                    success: function (response) {
                        responseCount++;
                        if (responseCount === requests.length) {
                            resolve('success');
                        }
                    }
                }, {
                    error: function (response) {
                        _this.log.debug('RoutesService.executeOperationOnRoutes() failed: ' + response.error);
                        reject(response.error);
                    }
                });
            });
        };
        return RoutesService;
    }());
    Camel.RoutesService = RoutesService;
})(Camel || (Camel = {}));
/// <reference path="route.ts"/>
/// <reference path="routes.service.ts"/>
var Camel;
(function (Camel) {
    var RoutesController = /** @class */ (function () {
        RoutesController.$inject = ["$uibModal", "workspace", "routesService"];
        function RoutesController($uibModal, workspace, routesService) {
            'ngInject';
            var _this = this;
            this.$uibModal = $uibModal;
            this.workspace = workspace;
            this.routesService = routesService;
            this.startAction = {
                name: 'Start',
                actionFn: function (action) {
                    var selectedRoutes = _this.getSelectedRoutes();
                    _this.routesService.startRoutes(selectedRoutes)
                        .then(function (response) { return _this.updateRoutes(); })
                        .catch(function (error) { return console.error(error); });
                },
                isDisabled: true
            };
            this.stopAction = {
                name: 'Stop',
                actionFn: function (action) {
                    var selectedRoutes = _this.getSelectedRoutes();
                    _this.routesService.stopRoutes(selectedRoutes)
                        .then(function (response) { return _this.updateRoutes(); })
                        .catch(function (error) { return console.error(error); });
                },
                isDisabled: true
            };
            this.deleteAction = {
                name: 'Delete',
                actionFn: function (action) {
                    var selectedRoutes = _this.getSelectedRoutes();
                    _this.$uibModal.open({
                        templateUrl: 'plugins/camel/html/deleteRouteModal.html'
                    })
                        .result.then(function () {
                        _this.routesService.removeRoutes(selectedRoutes)
                            .then(function (response) { return _this.removeSelectedRoutes(); })
                            .catch(function (error) { return console.error(error); });
                    });
                },
                isDisabled: true
            };
            this.toolbarConfig = {
                actionsConfig: {
                    primaryActions: [
                        this.startAction,
                        this.stopAction
                    ],
                    moreActions: [
                        this.deleteAction
                    ]
                }
            };
            this.tableConfig = {
                selectionMatchProp: "name",
                onCheckBoxChange: function (item) { return _this.enableDisableActions(); }
            };
            this.tableColummns = [
                { header: "Name", itemField: "name" },
                { header: "State", itemField: "state" }
            ];
            this.tableItems = [{ name: null, state: null }];
        }
        RoutesController.prototype.$onInit = function () {
            this.loadRoutes();
        };
        RoutesController.prototype.getSelectedRoutes = function () {
            var _this = this;
            return _.map(this.tableItems, function (tableItem, i) { return angular.extend(_this.routes[i], { selected: tableItem['selected'] }); })
                .filter(function (route) { return route.selected; });
        };
        RoutesController.prototype.enableDisableActions = function () {
            var selectedRoutes = this.getSelectedRoutes();
            this.startAction.isDisabled = !selectedRoutes.some(function (route) { return route.state === 'Stopped'; });
            this.stopAction.isDisabled = !selectedRoutes.some(function (route) { return route.state === 'Started'; });
            this.deleteAction.isDisabled = !selectedRoutes.every(function (route) { return route.state === 'Stopped'; });
        };
        RoutesController.prototype.loadRoutes = function () {
            var _this = this;
            if (this.workspace.selection) {
                var typeNames = Jmx.getUniqueTypeNames(this.workspace.selection.children);
                if (typeNames.length > 1) {
                    console.error("Child nodes aren't of the same type. Found types: " + typeNames);
                }
                var mbeans = _.map(this.workspace.selection.children, function (node) { return node.objectName; });
                this.routesService.getRoutes(mbeans)
                    .then(function (routes) {
                    _this.tableItems = _.map(routes, function (route) { return ({
                        name: route.name,
                        state: route.state
                    }); });
                    _this.routes = routes;
                })
                    .catch(function (error) { return console.error(error); });
            }
        };
        RoutesController.prototype.updateRoutes = function () {
            var _this = this;
            var mbeans = _.map(this.routes, function (route) { return route.mbean; });
            this.routesService.getRoutes(mbeans)
                .then(function (routes) {
                _this.routes = routes;
                routes.forEach(function (route, i) { return _this.tableItems[i].state = route.state; });
                _this.enableDisableActions();
            })
                .catch(function (error) { return console.error(error); });
        };
        RoutesController.prototype.removeSelectedRoutes = function () {
            var _this = this;
            this.tableItems.forEach(function (tableItem, i) { return angular.extend(_this.routes[i], { selected: tableItem['selected'] }); });
            _.remove(this.routes, function (route) { return route.selected; });
            _.remove(this.tableItems, function (tableItem) { return tableItem['selected']; });
            this.workspace.loadTree();
            this.enableDisableActions();
        };
        return RoutesController;
    }());
    Camel.RoutesController = RoutesController;
    Camel.routesComponent = {
        template: "\n      <pf-toolbar config=\"$ctrl.toolbarConfig\"></pf-toolbar>\n      <pf-table-view config=\"$ctrl.tableConfig\" colummns=\"$ctrl.tableColummns\" items=\"$ctrl.tableItems\"></pf-table-view>\n    ",
        controller: RoutesController
    };
})(Camel || (Camel = {}));
/// <reference path="routes.service.ts"/>
/// <reference path="route.ts"/>
var Camel;
(function (Camel) {
    var RouteActionsController = /** @class */ (function () {
        RouteActionsController.$inject = ["$scope", "$uibModal", "$timeout", "workspace", "routesService"];
        function RouteActionsController($scope, $uibModal, $timeout, workspace, routesService) {
            'ngInject';
            var _this = this;
            this.$uibModal = $uibModal;
            this.$timeout = $timeout;
            this.workspace = workspace;
            this.routesService = routesService;
            this.route = null;
            $scope.$on('jmxTreeClicked', function (event, selectedNode) {
                if (workspace.isRoute()) {
                    routesService.getRoute(selectedNode.objectName)
                        .then(function (route) { return _this.route = route; });
                }
                else {
                    _this.route = null;
                }
            });
        }
        RouteActionsController.prototype.isVisible = function () {
            return this.route !== null;
        };
        RouteActionsController.prototype.start = function () {
            var _this = this;
            this.routesService.startRoute(this.route)
                .then(function (response) {
                _this.routesService.getRoute(_this.route.mbean)
                    .then(function (route) { return _this.route = route; });
            });
        };
        RouteActionsController.prototype.stop = function () {
            var _this = this;
            this.routesService.stopRoute(this.route)
                .then(function (response) {
                _this.routesService.getRoute(_this.route.mbean)
                    .then(function (route) { return _this.route = route; });
            });
        };
        RouteActionsController.prototype.delete = function () {
            var _this = this;
            this.$uibModal.open({
                templateUrl: 'plugins/camel/html/deleteRouteWarningModal.html'
            })
                .result.then(function () {
                _this.routesService.removeRoute(_this.route)
                    .then(function (response) {
                    _this.route = null;
                    _this.workspace.loadTree();
                });
            });
        };
        return RouteActionsController;
    }());
    Camel.RouteActionsController = RouteActionsController;
    Camel.routeActionsComponent = {
        template: "\n      <div class=\"dropdown camel-main-actions\" ng-show=\"$ctrl.isVisible()\">\n        <button type=\"button\" id=\"dropdownMenu1\" class=\"btn btn-default dropdown-toggle\"\n          data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"true\">\n          <span class=\"fa\" ng-class=\"{'fa-play': $ctrl.route.isStarted(), 'fa-stop': $ctrl.route.isStopped()}\"></span>\n          &nbsp;\n          {{$ctrl.route.state}}\n          &nbsp;\n          <span class=\"caret\"></span>\n        </button>\n        <ul class=\"dropdown-menu\" aria-labelledby=\"dropdownMenu1\">\n          <li ng-class=\"{disabled: $ctrl.route.isStarted()}\">\n            <a href=\"#\" ng-click=\"$ctrl.start()\">Start</a>\n          </li>\n          <li ng-class=\"{disabled: $ctrl.route.isStopped()}\">\n            <a href=\"#\" ng-click=\"$ctrl.stop()\">Stop</a>\n          </li>\n          <li ng-class=\"{disabled: $ctrl.route.isStarted()}\">\n            <a href=\"#\" ng-click=\"$ctrl.delete()\">Delete</a>\n          </li>\n        </ul>\n      </div>\n    ",
        controller: RouteActionsController
    };
})(Camel || (Camel = {}));
/// <reference path="routes.component.ts"/>
/// <reference path="route-actions.component.ts"/>
/// <reference path="routes.service.ts"/>
var Camel;
(function (Camel) {
    Camel.routesModule = angular
        .module('hawtio-camel-routes', [])
        .component('routes', Camel.routesComponent)
        .component('routeActions', Camel.routeActionsComponent)
        .service('routesService', Camel.RoutesService)
        .name;
})(Camel || (Camel = {}));
/// <reference path="camelHelpers.ts"/>
/// <reference path="contexts/contexts.module.ts"/>
/// <reference path="routes/routes.module.ts"/>
var Camel;
(function (Camel) {
    Camel.pluginName = 'camel';
    Camel._module = angular.module(Camel.pluginName, [
        'patternfly',
        'patternfly.table',
        'angularResizable',
        Camel.contextsModule,
        Camel.routesModule
    ]);
    Camel._module.config(["$routeProvider", function ($routeProvider) {
            $routeProvider
                .when('/camel/contexts', { template: '<contexts></contexts>' })
                .when('/camel/routes', { template: '<routes></routes>' })
                .when('/camel/browseEndpoint', { templateUrl: 'plugins/camel/html/browseEndpoint.html' })
                .when('/camel/endpoint/browse/:contextId/*endpointPath', { templateUrl: 'plugins/camel/html/browseEndpoint.html' })
                .when('/camel/createEndpoint', { templateUrl: 'plugins/camel/html/createEndpoint.html' })
                .when('/camel/route/diagram/:contextId/:routeId', { templateUrl: 'plugins/camel/html/routeDiagram.html' })
                .when('/camel/routeDiagram', { templateUrl: 'plugins/camel/html/routeDiagram.html' })
                .when('/camel/typeConverter', { templateUrl: 'plugins/camel/html/typeConverter.html', reloadOnSearch: false })
                .when('/camel/restServices', { templateUrl: 'plugins/camel/html/restServices.html', reloadOnSearch: false })
                .when('/camel/endpointRuntimeRegistry', { templateUrl: 'plugins/camel/html/endpointRuntimeRegistry.html', reloadOnSearch: false })
                .when('/camel/routeMetrics', { templateUrl: 'plugins/camel/html/routeMetrics.html', reloadOnSearch: false })
                .when('/camel/exchanges', { templateUrl: 'plugins/camel/html/exchanges.html', reloadOnSearch: false })
                .when('/camel/sendMessage', { templateUrl: 'plugins/camel/html/sendMessage.html', reloadOnSearch: false })
                .when('/camel/source', { templateUrl: 'plugins/camel/html/source.html' })
                .when('/camel/traceRoute', { templateUrl: 'plugins/camel/html/traceRoute.html' })
                .when('/camel/debugRoute', { templateUrl: 'plugins/camel/html/debug.html' })
                .when('/camel/profileRoute', { templateUrl: 'plugins/camel/html/profileRoute.html' })
                .when('/camel/propertiesRoute', { templateUrl: 'plugins/camel/html/propertiesRoute.html' })
                .when('/camel/propertiesComponent', { templateUrl: 'plugins/camel/html/propertiesComponent.html' })
                .when('/camel/propertiesDataFormat', { templateUrl: 'plugins/camel/html/propertiesDataFormat.html' })
                .when('/camel/propertiesEndpoint', { templateUrl: 'plugins/camel/html/propertiesEndpoint.html' });
        }]);
    Camel._module.factory('tracerStatus', function () {
        return {
            jhandle: null,
            messages: []
        };
    });
    Camel._module.filter('camelIconClass', function () { return Camel.iconClass; });
    Camel._module.factory('activeMQMessage', function () {
        return { 'message': null };
    });
    // service for the codehale metrics
    Camel._module.factory('metricsWatcher', ["$window", function ($window) {
            var answer = $window.metricsWatcher;
            if (!answer) {
                // lets avoid any NPEs
                answer = {};
                $window.metricsWatcher = answer;
            }
            return answer;
        }]);
    Camel._module.run(["HawtioNav", "workspace", "jolokia", "viewRegistry", "layoutFull", "helpRegistry", "preferencesRegistry", "$templateCache", "$location", "$rootScope", function (nav, workspace, jolokia, viewRegistry, layoutFull, helpRegistry, preferencesRegistry, $templateCache, $location, $rootScope) {
            viewRegistry['camel/endpoint/'] = layoutFull;
            viewRegistry['camel/route/'] = layoutFull;
            viewRegistry['{ "main-tab": "camel" }'] = 'plugins/camel/html/layoutCamelTree.html';
            helpRegistry.addUserDoc('camel', 'plugins/camel/doc/help.md', function () {
                return workspace.treeContainsDomainAndProperties(Camel.jmxDomain);
            });
            preferencesRegistry.addTab('Camel', 'plugins/camel/html/preferences.html', function () {
                return workspace.treeContainsDomainAndProperties(Camel.jmxDomain);
            });
            // register default attribute views
            var stateField = 'State';
            var stateTemplate = '<div class="ngCellText pagination-centered" title="{{row.getProperty(col.field)}}"><i class="{{row.getProperty(\'' + stateField + '\') | camelIconClass}}"></i></div>';
            var stateColumn = { field: stateField, displayName: stateField,
                cellTemplate: stateTemplate,
                width: 56,
                minWidth: 56,
                maxWidth: 56,
                resizable: false,
                defaultSort: false
                // we do not want to default sort the state column
            };
            var attributes = workspace.attributeColumnDefs;
            attributes[Camel.jmxDomain + "/context/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'Uptime', displayName: 'Uptime', visible: false },
                { field: 'CamelVersion', displayName: 'Version', visible: false },
                { field: 'ExchangesCompleted', displayName: 'Completed' },
                { field: 'ExchangesFailed', displayName: 'Failed' },
                { field: 'FailuresHandled', displayName: 'Failed Handled', visible: false },
                { field: 'ExchangesTotal', displayName: 'Total', visible: false },
                { field: 'Redeliveries', displayName: 'Redelivery', visible: false },
                { field: 'ExchangesInflight', displayName: 'Inflight' },
                { field: 'OldestInflightDuration', displayName: 'Oldest Inflight Time', visible: false },
                { field: 'MeanProcessingTime', displayName: 'Mean Time' },
                { field: 'MinProcessingTime', displayName: 'Min Time' },
                { field: 'MaxProcessingTime', displayName: 'Max Time' },
                { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
                { field: 'DeltaProcessingTime', displayName: 'Delta Time', visible: false },
                { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
                { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
                { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
                { field: 'ExternalRedeliveries', displayName: 'External Redelivery', visible: false },
                { field: 'StartedRoutes', displayName: 'Started Routes' },
                { field: 'TotalRoutes', displayName: 'Total Routes' }
            ];
            attributes[Camel.jmxDomain + "/routes/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'RouteId', displayName: 'Route' },
                { field: 'ExchangesCompleted', displayName: 'Completed' },
                { field: 'ExchangesFailed', displayName: 'Failed' },
                { field: 'FailuresHandled', displayName: 'Failed Handled', visible: false },
                { field: 'Redeliveries', displayName: 'Redelivery', visible: false },
                { field: 'ExchangesTotal', displayName: 'Total', visible: false },
                { field: 'ExchangesInflight', displayName: 'Inflight' },
                { field: 'OldestInflightDuration', displayName: 'Oldest Inflight Time', visible: false },
                { field: 'MeanProcessingTime', displayName: 'Mean Time' },
                { field: 'MinProcessingTime', displayName: 'Min Time' },
                { field: 'MaxProcessingTime', displayName: 'Max Time' },
                { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
                { field: 'DeltaProcessingTime', displayName: 'Delta Time', visible: false },
                { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
                { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
                { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
                { field: 'Redeliveries', displayName: 'Redelivery', visible: false },
                { field: 'ExternalRedeliveries', displayName: 'External Redelivery', visible: false }
            ];
            attributes[Camel.jmxDomain + "/processors/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'RouteId', displayName: 'Route' },
                { field: 'ProcessorId', displayName: 'Processor' },
                { field: 'ExchangesCompleted', displayName: 'Completed' },
                { field: 'ExchangesFailed', displayName: 'Failed' },
                { field: 'FailuresHandled', displayName: 'Failed Handled', visible: false },
                { field: 'Redeliveries', displayName: 'Redelivery', visible: false },
                { field: 'ExchangesTotal', displayName: 'Total', visible: false },
                { field: 'ExchangesInflight', displayName: 'Inflight' },
                { field: 'OldestInflightDuration', displayName: 'Oldest Inflight Time', visible: false },
                { field: 'MeanProcessingTime', displayName: 'Mean Time' },
                { field: 'MinProcessingTime', displayName: 'Min Time' },
                { field: 'MaxProcessingTime', displayName: 'Max Time' },
                { field: 'TotalProcessingTime', displayName: 'Total Time', visible: false },
                { field: 'DeltaProcessingTime', displayName: 'Delta Time', visible: false },
                { field: 'LastProcessingTime', displayName: 'Last Time', visible: false },
                { field: 'LastExchangeCompletedTimestamp', displayName: 'Last completed', visible: false },
                { field: 'LastExchangeFailedTimestamp', displayName: 'Last failed', visible: false },
                { field: 'ExternalRedeliveries', displayName: 'External Redelivery', visible: false }
            ];
            attributes[Camel.jmxDomain + "/components/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'ComponentName', displayName: 'Name' }
            ];
            attributes[Camel.jmxDomain + "/consumers/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'RouteId', displayName: 'Route' },
                { field: 'EndpointUri', displayName: 'Endpoint URI', width: "**" },
                { field: 'Suspended', displayName: 'Suspended', resizable: false },
                { field: 'InflightExchanges', displayName: 'Inflight' }
            ];
            attributes[Camel.jmxDomain + "/producers/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'RouteId', displayName: 'Route' },
                { field: 'EndpointUri', displayName: 'Endpoint URI', width: "**" },
                { field: 'Suspended', displayName: 'Suspended', resizable: false }
            ];
            attributes[Camel.jmxDomain + "/services/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'RouteId', displayName: 'Route' },
                { field: 'Suspended', displayName: 'Suspended', resizable: false },
                { field: 'SupportsSuspended', displayName: 'Can Suspend', resizable: false }
            ];
            attributes[Camel.jmxDomain + "/endpoints/folder"] = [
                stateColumn,
                { field: 'CamelId', displayName: 'Context' },
                { field: 'EndpointUri', displayName: 'Endpoint URI', width: "***" },
                { field: 'Singleton', displayName: 'Singleton', resizable: false }
            ];
            attributes[Camel.jmxDomain + "/threadpools/folder"] = [
                { field: 'Id', displayName: 'Id', width: "**" },
                { field: 'ActiveCount', displayName: 'Active' },
                { field: 'PoolSize', displayName: 'Pool Size' },
                { field: 'CorePoolSize', displayName: 'Core Pool Size' },
                { field: 'TaskQueueSize', displayName: 'Task Queue Size' },
                { field: 'TaskCount', displayName: 'Task' },
                { field: 'CompletedTaskCount', displayName: 'Completed Task' }
            ];
            attributes[Camel.jmxDomain + "/errorhandlers/folder"] = [
                { field: 'CamelId', displayName: 'Context' },
                { field: 'DeadLetterChannel', displayName: 'Dead Letter' },
                { field: 'DeadLetterChannelEndpointUri', displayName: 'Endpoint URI', width: "**", resizable: true },
                { field: 'MaximumRedeliveries', displayName: 'Max Redeliveries' },
                { field: 'RedeliveryDelay', displayName: 'Redelivery Delay' },
                { field: 'MaximumRedeliveryDelay', displayName: 'Max Redeliveries Delay' }
            ];
            var tab = nav.builder().id('camel')
                .title(function () { return 'Camel'; })
                .defaultPage({
                rank: 20,
                isValid: function (yes, no) { return workspace.treeContainsDomainAndProperties(Camel.jmxDomain) ? yes() : no(); }
            })
                .href(function () { return '/camel/contexts?main-tab=camel'; })
                .isValid(function () { return workspace.treeContainsDomainAndProperties(Camel.jmxDomain); })
                .isSelected(function () { return workspace.isMainTabActive('camel'); })
                .build();
            nav.add(tab);
            workspace.addNamedTreePostProcessor('camel', function (tree) {
                var domainName = Camel.jmxDomain;
                if (tree) {
                    var rootFolder_1 = new Jmx.Folder('Camel Contexts');
                    rootFolder_1.class = 'org-apache-camel-context-folder';
                    rootFolder_1.children = [];
                    rootFolder_1.typeName = 'context';
                    rootFolder_1.key = 'camelContexts';
                    rootFolder_1.domain = domainName;
                    var domain = tree.get(domainName);
                    if (domain) {
                        var children_1 = [];
                        angular.forEach(domain.children, function (child, key) {
                            var contextsFolder = child.get('context');
                            var routesNode = child.get('routes');
                            var endpointsNode = child.get('endpoints');
                            var componentsNode = child.get('components');
                            var dataFormatsNode = child.get('dataformats');
                            if (contextsFolder) {
                                var contextNode_1 = contextsFolder.children[0];
                                if (contextNode_1) {
                                    // fetch the camel version and add it to the tree here to avoid making a blocking call elsewhere
                                    jolokia.request({
                                        'type': 'read',
                                        'mbean': contextNode_1.objectName,
                                        'attribute': 'CamelVersion'
                                    }, Core.onSuccess(function (response) {
                                        contextNode_1.version = response.value;
                                        Core.$apply($rootScope);
                                    }));
                                    if (routesNode) {
                                        contextNode_1.moveChild(routesNode);
                                        routesNode.typeName = 'routes';
                                        routesNode.class = 'org-apache-camel-routes-folder';
                                        angular.forEach(routesNode.children, function (n) { return n.class = 'org-apache-camel-routes'; });
                                    }
                                    if (endpointsNode) {
                                        contextNode_1.moveChild(endpointsNode);
                                        endpointsNode.typeName = 'endpoints';
                                        endpointsNode.class = 'org-apache-camel-endpoints-folder';
                                        angular.forEach(endpointsNode.children, function (n) { return n.class = 'org-apache-camel-endpoints'; });
                                    }
                                    if (componentsNode) {
                                        contextNode_1.moveChild(componentsNode);
                                        componentsNode.typeName = 'components';
                                        componentsNode.class = 'org-apache-camel-components-folder';
                                        angular.forEach(componentsNode.children, function (n) { return n.class = 'org-apache-camel-components'; });
                                    }
                                    if (dataFormatsNode) {
                                        contextNode_1.moveChild(dataFormatsNode);
                                        dataFormatsNode.class = 'org-apache-camel-dataformats-folder';
                                        angular.forEach(dataFormatsNode.children, function (n) { return n.class = 'org-apache-camel-dataformats'; });
                                        dataFormatsNode.typeName = 'dataformats';
                                    }
                                    var jmxNode_1 = new Jmx.Folder('MBeans');
                                    workspace.configureFolder(jmxNode_1, domainName, 'org-apache-camel', _.clone(child.folderNames).concat('mbeans'), 'mbeans');
                                    // lets add all the entries which are not one context/routes/endpoints/components/dataformats as MBeans
                                    child.children
                                        .filter(function (child) { return !(child.text === 'context'
                                        || child.text === 'routes'
                                        || child.text === 'endpoints'
                                        || child.text === 'components'
                                        || child.text === 'dataformats'); })
                                        .forEach(function (child) { return jmxNode_1.moveChild(child); });
                                    if (jmxNode_1.children.length > 0) {
                                        jmxNode_1.sortChildren(false);
                                        contextNode_1.moveChild(jmxNode_1);
                                    }
                                    rootFolder_1.moveChild(contextNode_1);
                                }
                                children_1.push(child);
                            }
                        });
                        children_1.forEach(function (child) { return child.detach(); });
                        domain.children.splice(0, 0, rootFolder_1);
                    }
                }
            });
        }]);
    hawtioPluginLoader.addModule(Camel.pluginName);
    // register the jmx lazy loader here as it won't have been invoked in the run method
    hawtioPluginLoader.registerPreBootstrapTask(function (task) {
        Jmx.registerLazyLoadHandler(Camel.jmxDomain, function (folder) {
            if (Camel.jmxDomain === folder.domain && 'routes' === folder.typeName) {
                return function (workspace, parent, onComplete) {
                    if ('routes' === parent.typeName) {
                        Camel.processRouteXml(workspace, workspace.jolokia, parent, function (route) { return onComplete(route ?
                            Camel.loadRouteChildren(parent, route) :
                            new Array()); });
                    }
                    else {
                        onComplete(new Array());
                    }
                };
            }
            return null;
        });
        task();
    });
})(Camel || (Camel = {}));
/// <reference path="../../activemq/ts/activemqHelpers.ts"/>
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel.BrowseEndpointController = Camel._module.controller("Camel.BrowseEndpointController", ["$scope", "$routeParams", "workspace", "jolokia", "$uibModal", function ($scope, $routeParams, workspace, jolokia, $uibModal) {
            $scope.workspace = workspace;
            $scope.mode = 'text';
            $scope.gridOptions = Camel.createBrowseGridOptions();
            $scope.endpointUri = null;
            $scope.contextId = $routeParams["contextId"];
            $scope.endpointPath = $routeParams["endpointPath"];
            $scope.isJmxTab = !$routeParams["contextId"] || !$routeParams["endpointPath"];
            // TODO can we share these 2 methods from activemq browse / camel browse / came trace?
            $scope.openMessageDialog = function (message) {
                ActiveMQ.selectCurrentMessage(message, "id", $scope);
                if ($scope.row) {
                    $scope.mode = CodeEditor.detectTextFormat($scope.row.body);
                    $uibModal.open({
                        templateUrl: 'camelBrowseEndpointMessageDetails.html',
                        scope: $scope,
                        size: 'lg'
                    });
                }
            };
            $scope.openForwardDialog = function (message) {
                $uibModal.open({
                    templateUrl: 'camelBrowseEndpointForwardMessage.html',
                    scope: $scope
                });
            };
            ActiveMQ.decorate($scope);
            $scope.forwardMessages = function (uri) {
                var mbean = Camel.getSelectionCamelContextMBean(workspace);
                var selectedItems = $scope.gridOptions.selectedItems;
                if (mbean && uri && selectedItems && selectedItems.length) {
                    //console.log("Creating a new endpoint called: " + uri + " just in case!");
                    jolokia.execute(mbean, "createEndpoint(java.lang.String)", uri, Core.onSuccess(intermediateResult));
                    $scope.message = "Forwarded " + Core.maybePlural(selectedItems.length, "message" + " to " + uri);
                    angular.forEach(selectedItems, function (item, idx) {
                        var callback = (idx + 1 < selectedItems.length) ? intermediateResult : operationSuccess;
                        var body = item.body;
                        var headers = item.headers;
                        //console.log("sending to uri " + uri + " headers: " + JSON.stringify(headers) + " body: " + body);
                        jolokia.execute(mbean, "sendBodyAndHeaders(java.lang.String, java.lang.Object, java.util.Map)", uri, body, headers, Core.onSuccess(callback));
                    });
                }
                $scope.endpointUri = null;
            };
            $scope.forwardMessage = function (message, uri) {
                var mbean = Camel.getSelectionCamelContextMBean(workspace);
                if (mbean && message && uri) {
                    jolokia.execute(mbean, "createEndpoint(java.lang.String)", uri, Core.onSuccess(function () {
                        jolokia.execute(mbean, "sendBodyAndHeaders(java.lang.String, java.lang.Object, java.util.Map)", uri, message.body, message.headers, Core.onSuccess(function () {
                            Core.notification("success", "Forwarded message to " + uri);
                            setTimeout(loadData, 50);
                        }));
                    }));
                }
            };
            $scope.endpointUris = function () {
                var endpointFolder = Camel.getSelectionCamelContextEndpoints(workspace);
                return (endpointFolder) ? endpointFolder.children.map(function (n) { return n.text; }) : [];
            };
            $scope.refresh = loadData;
            function intermediateResult() {
            }
            function operationSuccess() {
                $scope.gridOptions.selectedItems.splice(0);
                Core.notification("success", $scope.message);
                setTimeout(loadData, 50);
            }
            function loadData() {
                var mbean = null;
                if ($scope.contextId && $scope.endpointPath) {
                    var node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                        context: $scope.contextId,
                        type: "endpoints",
                        name: $scope.endpointPath
                    });
                    if (node) {
                        mbean = node.objectName;
                    }
                }
                if (!mbean) {
                    mbean = workspace.getSelectedMBeanName();
                }
                if (mbean) {
                    Camel.log.info("MBean: " + mbean);
                    var options = Core.onSuccess(populateTable);
                    jolokia.execute(mbean, 'browseAllMessagesAsXml(java.lang.Boolean)', true, options);
                }
            }
            function populateTable(response) {
                var data = [];
                if (angular.isString(response)) {
                    // lets parse the XML DOM here...
                    var doc = $.parseXML(response);
                    var allMessages = $(doc).find("message");
                    allMessages.each(function (idx, message) {
                        var messageData = Camel.createMessageFromXml(message);
                        // attach the open dialog to make it work
                        messageData.openMessageDialog = $scope.openMessageDialog;
                        data.push(messageData);
                    });
                }
                $scope.messages = data;
                Core.$apply($scope);
            }
        }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    // NOTE this file is code generated by the ide-codegen module in Fuse IDE
    Camel.camelHeaderSchema = {
        definitions: {
            headers: {
                properties: {
                    "CamelAuthentication": {
                        type: "java.lang.String"
                    },
                    "CamelAuthenticationFailurePolicyId": {
                        type: "java.lang.String"
                    },
                    "CamelAcceptContentType": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedSize": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedTimeout": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedCompletedBy": {
                        type: "java.lang.String"
                    },
                    "CamelAggregatedCorrelationKey": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationStrategy": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationCompleteAllGroups": {
                        type: "java.lang.String"
                    },
                    "CamelAggregationCompleteAllGroupsInclusive": {
                        type: "java.lang.String"
                    },
                    "CamelAsyncWait": {
                        type: "java.lang.String"
                    },
                    "CamelBatchIndex": {
                        type: "java.lang.String"
                    },
                    "CamelBatchSize": {
                        type: "java.lang.String"
                    },
                    "CamelBatchComplete": {
                        type: "java.lang.String"
                    },
                    "CamelBeanMethodName": {
                        type: "java.lang.String"
                    },
                    "CamelBeanMultiParameterArray": {
                        type: "java.lang.String"
                    },
                    "CamelBinding": {
                        type: "java.lang.String"
                    },
                    "breadcrumbId": {
                        type: "java.lang.String"
                    },
                    "CamelCharsetName": {
                        type: "java.lang.String"
                    },
                    "CamelCreatedTimestamp": {
                        type: "java.lang.String"
                    },
                    "Content-Encoding": {
                        type: "java.lang.String"
                    },
                    "Content-Length": {
                        type: "java.lang.String"
                    },
                    "Content-Type": {
                        type: "java.lang.String"
                    },
                    "CamelCorrelationId": {
                        type: "java.lang.String"
                    },
                    "CamelDataSetIndex": {
                        type: "java.lang.String"
                    },
                    "org.apache.camel.default.charset": {
                        type: "java.lang.String"
                    },
                    "CamelDestinationOverrideUrl": {
                        type: "java.lang.String"
                    },
                    "CamelDisableHttpStreamCache": {
                        type: "java.lang.String"
                    },
                    "CamelDuplicateMessage": {
                        type: "java.lang.String"
                    },
                    "CamelExceptionCaught": {
                        type: "java.lang.String"
                    },
                    "CamelExceptionHandled": {
                        type: "java.lang.String"
                    },
                    "CamelEvaluateExpressionResult": {
                        type: "java.lang.String"
                    },
                    "CamelErrorHandlerHandled": {
                        type: "java.lang.String"
                    },
                    "CamelExternalRedelivered": {
                        type: "java.lang.String"
                    },
                    "CamelFailureHandled": {
                        type: "java.lang.String"
                    },
                    "CamelFailureEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelFailureRouteId": {
                        type: "java.lang.String"
                    },
                    "CamelFilterNonXmlChars": {
                        type: "java.lang.String"
                    },
                    "CamelFileLocalWorkPath": {
                        type: "java.lang.String"
                    },
                    "CamelFileName": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameOnly": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameProduced": {
                        type: "java.lang.String"
                    },
                    "CamelFileNameConsumed": {
                        type: "java.lang.String"
                    },
                    "CamelFilePath": {
                        type: "java.lang.String"
                    },
                    "CamelFileParent": {
                        type: "java.lang.String"
                    },
                    "CamelFileLastModified": {
                        type: "java.lang.String"
                    },
                    "CamelFileLength": {
                        type: "java.lang.String"
                    },
                    "CamelFilterMatched": {
                        type: "java.lang.String"
                    },
                    "CamelFileLockFileAcquired": {
                        type: "java.lang.String"
                    },
                    "CamelFileLockFileName": {
                        type: "java.lang.String"
                    },
                    "CamelGroupedExchange": {
                        type: "java.lang.String"
                    },
                    "CamelHttpBaseUri": {
                        type: "java.lang.String"
                    },
                    "CamelHttpCharacterEncoding": {
                        type: "java.lang.String"
                    },
                    "CamelHttpMethod": {
                        type: "java.lang.String"
                    },
                    "CamelHttpPath": {
                        type: "java.lang.String"
                    },
                    "CamelHttpProtocolVersion": {
                        type: "java.lang.String"
                    },
                    "CamelHttpQuery": {
                        type: "java.lang.String"
                    },
                    "CamelHttpResponseCode": {
                        type: "java.lang.String"
                    },
                    "CamelHttpUri": {
                        type: "java.lang.String"
                    },
                    "CamelHttpUrl": {
                        type: "java.lang.String"
                    },
                    "CamelHttpChunked": {
                        type: "java.lang.String"
                    },
                    "CamelHttpServletRequest": {
                        type: "java.lang.String"
                    },
                    "CamelHttpServletResponse": {
                        type: "java.lang.String"
                    },
                    "CamelInterceptedEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelInterceptSendToEndpointWhenMatched": {
                        type: "java.lang.String"
                    },
                    "CamelLanguageScript": {
                        type: "java.lang.String"
                    },
                    "CamelLogDebugBodyMaxChars": {
                        type: "java.lang.String"
                    },
                    "CamelLogDebugStreams": {
                        type: "java.lang.String"
                    },
                    "CamelLoopIndex": {
                        type: "java.lang.String"
                    },
                    "CamelLoopSize": {
                        type: "java.lang.String"
                    },
                    "CamelMaximumCachePoolSize": {
                        type: "java.lang.String"
                    },
                    "CamelMaximumEndpointCacheSize": {
                        type: "java.lang.String"
                    },
                    "CamelMessageHistory": {
                        type: "java.lang.String"
                    },
                    "CamelMulticastIndex": {
                        type: "java.lang.String"
                    },
                    "CamelMulticastComplete": {
                        type: "java.lang.String"
                    },
                    "CamelNotifyEvent": {
                        type: "java.lang.String"
                    },
                    "CamelOnCompletion": {
                        type: "java.lang.String"
                    },
                    "CamelOverruleFileName": {
                        type: "java.lang.String"
                    },
                    "CamelParentUnitOfWork": {
                        type: "java.lang.String"
                    },
                    "CamelRecipientListEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelReceivedTimestamp": {
                        type: "java.lang.String"
                    },
                    "CamelRedelivered": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryCounter": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryMaxCounter": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryExhausted": {
                        type: "java.lang.String"
                    },
                    "CamelRedeliveryDelay": {
                        type: "java.lang.String"
                    },
                    "CamelRollbackOnly": {
                        type: "java.lang.String"
                    },
                    "CamelRollbackOnlyLast": {
                        type: "java.lang.String"
                    },
                    "CamelRouteStop": {
                        type: "java.lang.String"
                    },
                    "CamelSoapAction": {
                        type: "java.lang.String"
                    },
                    "CamelSkipGzipEncoding": {
                        type: "java.lang.String"
                    },
                    "CamelSlipEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelSplitIndex": {
                        type: "java.lang.String"
                    },
                    "CamelSplitComplete": {
                        type: "java.lang.String"
                    },
                    "CamelSplitSize": {
                        type: "java.lang.String"
                    },
                    "CamelTimerCounter": {
                        type: "java.lang.String"
                    },
                    "CamelTimerFiredTime": {
                        type: "java.lang.String"
                    },
                    "CamelTimerName": {
                        type: "java.lang.String"
                    },
                    "CamelTimerPeriod": {
                        type: "java.lang.String"
                    },
                    "CamelTimerTime": {
                        type: "java.lang.String"
                    },
                    "CamelToEndpoint": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEvent": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventNodeId": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventTimestamp": {
                        type: "java.lang.String"
                    },
                    "CamelTraceEventExchange": {
                        type: "java.lang.String"
                    },
                    "Transfer-Encoding": {
                        type: "java.lang.String"
                    },
                    "CamelUnitOfWorkExhausted": {
                        type: "java.lang.String"
                    },
                    "CamelUnitOfWorkProcessSync": {
                        type: "java.lang.String"
                    },
                    "CamelXsltFileName": {
                        type: "java.lang.String"
                    }
                }
            }
        }
    };
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.DebugRouteController", ["$scope", "$element", "workspace", "jolokia", "localStorage", "documentBase", function ($scope, $element, workspace, jolokia, localStorage, documentBase) {
            var log = Logger.get("CamelDebugger");
            var breakpointImageUrl = UrlHelpers.join(documentBase, "/img/icons/camel/breakpoint.png");
            // ignore the cached stuff in camel.ts as it seems to bork the node ids for some reason...
            $scope.debugging = false;
            $scope.stopped = false;
            $scope.showDebugPanel = false;
            $scope.ignoreRouteXmlNode = true;
            $scope.messages = [];
            $scope.mode = 'text';
            // always show the message details
            $scope.showMessageDetails = true;
            $scope.startDebugging = function () {
                log.info("Start debugging");
                setDebugging(true);
            };
            $scope.stopDebugging = function () {
                log.info("Stop debugging");
                setDebugging(false);
            };
            $scope.$on("camel.diagram.selectedNodeId", function (event, value) {
                $scope.selectedDiagramNodeId = value;
                updateBreakpointFlag();
            });
            $scope.$on("camel.diagram.layoutComplete", function (event, value) {
                updateBreakpointNodes();
                $($element).find("g.node").dblclick(function (n) {
                    var id = this.getAttribute("data-cid");
                    $scope.toggleBreakpoint(id);
                });
            });
            $scope.toggleBreakpoint = function (id) {
                log.info("Toggle breakpoint");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean && id) {
                    var method = isBreakpointSet(id) ? "removeBreakpoint" : "addBreakpoint";
                    jolokia.execute(mbean, method, id, Core.onSuccess(breakpointsChanged));
                }
            };
            $scope.addBreakpoint = function () {
                log.info("Add breakpoint");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean && $scope.selectedDiagramNodeId) {
                    jolokia.execute(mbean, "addBreakpoint", $scope.selectedDiagramNodeId, Core.onSuccess(breakpointsChanged));
                }
            };
            $scope.removeBreakpoint = function () {
                log.info("Remove breakpoint");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean && $scope.selectedDiagramNodeId) {
                    jolokia.execute(mbean, "removeBreakpoint", $scope.selectedDiagramNodeId, Core.onSuccess(breakpointsChanged));
                }
            };
            $scope.removeBreakpointById = function (id) {
                log.info("Remove breakpoint");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    jolokia.execute(mbean, "removeBreakpoint", id, Core.onSuccess(breakpointsChanged));
                }
            };
            $scope.resume = function () {
                log.info("Resume");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    jolokia.execute(mbean, "resumeAll", Core.onSuccess(clearStoppedAndResume));
                }
            };
            $scope.suspend = function () {
                log.info("Suspend");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    jolokia.execute(mbean, "suspendAll", Core.onSuccess(clearStoppedAndResume));
                }
            };
            $scope.step = function () {
                log.info("Step");
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                var stepNode = getStoppedBreakpointId();
                if (mbean && stepNode) {
                    jolokia.execute(mbean, "stepBreakpoint(java.lang.String)", stepNode, Core.onSuccess(clearStoppedAndResume));
                }
            };
            $scope.shouldDisableAddBreakpoint = function () {
                if (!$scope.selectedDiagramNodeId) {
                    return true;
                }
                var nodes = getDiagramNodes();
                if (!nodes || nodes.length == 0) {
                    return true;
                }
                return nodes[0][0].getAttribute("data-cid") === $scope.selectedDiagramNodeId;
            };
            function onSelectionChanged() {
                Camel.highlightSelectedNode(getDiagramNodes(), getStoppedBreakpointId());
            }
            function reloadData() {
                $scope.debugging = false;
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    $scope.debugging = jolokia.getAttribute(mbean, "Enabled", Core.onSuccess(null));
                    if ($scope.debugging) {
                        jolokia.execute(mbean, "getBreakpoints", Core.onSuccess(onBreakpoints));
                        // get the breakpoints...
                        $scope.graphView = "plugins/camel/html/routeDiagram.html";
                        Core.register(jolokia, $scope, {
                            type: 'exec', mbean: mbean,
                            operation: 'getDebugCounter'
                        }, Core.onSuccess(onBreakpointCounter));
                    }
                    else {
                        $scope.graphView = null;
                        $scope.tableView = null;
                    }
                }
            }
            function onBreakpointCounter(response) {
                var counter = response.value;
                if (counter && counter !== $scope.breakpointCounter) {
                    $scope.breakpointCounter = counter;
                    loadCurrentStack();
                }
            }
            /*
             * lets load current 'stack' of which breakpoints are active
             * and what is the current message content
             */
            function loadCurrentStack() {
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    console.log("getting suspended breakpoints!");
                    jolokia.execute(mbean, "getSuspendedBreakpointNodeIds", Core.onSuccess(onSuspendedBreakpointNodeIds));
                }
            }
            function onSuspendedBreakpointNodeIds(response) {
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                $scope.suspendedBreakpoints = response;
                $scope.stopped = response && response.length;
                $scope.showDebugPanel = !$scope.showDebugPanel ? $scope.stopped : $scope.showDebugPanel;
                var stopNodeId = getStoppedBreakpointId();
                if (mbean && stopNodeId) {
                    jolokia.execute(mbean, 'dumpTracedMessagesAsXml', stopNodeId, Core.onSuccess(onMessages));
                    // lets update the diagram selection to the newly stopped node
                    $scope.selectedDiagramNodeId = stopNodeId;
                }
                updateBreakpointNodes();
                Core.$apply($scope);
            }
            function onMessages(response, stopNodeId) {
                log.debug("onMessage -> " + response);
                $scope.messages = [];
                if (response) {
                    var xml = response;
                    if (angular.isString(xml)) {
                        // lets parse the XML DOM here...
                        var doc = $.parseXML(xml);
                        var allMessages = $(doc).find("fabricTracerEventMessage");
                        if (!allMessages || !allMessages.length) {
                            // lets try find another element name
                            allMessages = $(doc).find("backlogTracerEventMessage");
                        }
                        allMessages.each(function (idx, message) {
                            var messageData = Camel.createMessageFromXml(message);
                            var toNode = $(message).find("toNode").text();
                            if (toNode) {
                                messageData["toNode"] = toNode;
                            }
                            // attach the open dialog to make it work
                            messageData.openMessageDialog = $scope.openMessageDialog;
                            $scope.messages.push(messageData);
                        });
                    }
                }
                else {
                    log.warn("WARNING: dumpTracedMessagesAsXml() returned no results!");
                }
                // lets update the selection and selected row for the message detail view
                updateMessageSelection();
                updateBreakpointNodes();
                onSelectionChanged();
                log.debug("has messages " + $scope.messages.length + " selected row " + $scope.row + " index " + $scope.rowIndex);
                Core.$apply($scope);
            }
            function updateMessageSelection() {
                if ($scope.messages.length > 0) {
                    $scope.row = $scope.messages[0];
                    var body = $scope.row.body;
                    $scope.mode = angular.isString(body) ? CodeEditor.detectTextFormat(body) : "text";
                    // it may detect wrong as javascript, so use text instead
                    if ("javascript" == $scope.mode) {
                        $scope.mode = "text";
                    }
                }
            }
            function clearStoppedAndResume() {
                $scope.row = null;
                $scope.messages = [];
                $scope.suspendedBreakpoints = [];
                $scope.stopped = false;
                updateMessageSelection();
                updateBreakpointNodes();
                onSelectionChanged();
                Core.$apply($scope);
            }
            /*
             * Return the current node id we are stopped at
             */
            function getStoppedBreakpointId() {
                var stepNode = null;
                var stepNodes = $scope.suspendedBreakpoints;
                if (stepNodes && stepNodes.length) {
                    stepNode = stepNodes[0];
                    if (stepNodes.length > 1 && $scope.isSuspendedAt($scope.selectedDiagramNodeId)) {
                        // TODO should consider we stepping from different nodes based on the call thread or selection?
                        stepNode = $scope.selectedDiagramNodeId;
                    }
                }
                return stepNode;
            }
            /*
             * Returns true if the execution is currently suspended at the given node
             */
            $scope.isSuspendedAt = function (nodeId) { return containsNodeId($scope.suspendedBreakpoints, nodeId); };
            function onBreakpoints(response) {
                $scope.breakpoints = response;
                updateBreakpointFlag();
                // update the breakpoint borders...
                var nodes = getDiagramNodes();
                if (nodes.length) {
                    updateBreakpointNodes(nodes);
                }
                Core.$apply($scope);
            }
            /*
             * Returns true if there is a breakpoint set at the given node id
             */
            function isBreakpointSet(nodeId) {
                return containsNodeId($scope.breakpoints, nodeId);
            }
            function updateBreakpointFlag() {
                $scope.hasBreakpoint = isBreakpointSet($scope.selectedDiagramNodeId);
            }
            function containsNodeId(breakpoints, nodeId) {
                return nodeId && breakpoints && breakpoints.indexOf(nodeId) !== -1;
            }
            function getDiagramNodes() {
                var svg = d3.select("svg");
                return svg.selectAll("g .node");
            }
            function updateBreakpointNodes(nodes) {
                if (nodes === void 0) { nodes = getDiagramNodes(); }
                nodes.each(function (object) {
                    var nodeId = object.cid;
                    var thisNode = d3.select(this);
                    var icons = thisNode.selectAll("image.breakpoint");
                    if (isBreakpointSet(nodeId)) {
                        if (!icons.length || !icons[0].length) {
                            thisNode.append("image")
                                .attr("xlink:href", function (d) {
                                return breakpointImageUrl;
                            })
                                .attr("class", "breakpoint")
                                .attr("x", function (d) { return -(d.bbox.width / 2) - 6; })
                                .attr("y", -20)
                                .attr("height", 12)
                                .attr("width", 12);
                        }
                        else {
                            icons.attr("xlink:href", function (d) {
                                return breakpointImageUrl;
                            });
                        }
                    }
                    else {
                        icons.remove();
                    }
                    thisNode.classed('stopped', $scope.isSuspendedAt(nodeId));
                });
            }
            function breakpointsChanged(response) {
                reloadData();
                Core.$apply($scope);
            }
            function setDebugging(flag) {
                var mbean = Camel.getSelectionCamelDebugMBean(workspace);
                if (mbean) {
                    var method = flag ? "enableDebugger" : "disableDebugger";
                    var max = Camel.maximumTraceOrDebugBodyLength(localStorage);
                    var streams = Camel.traceOrDebugIncludeStreams(localStorage);
                    jolokia.setAttribute(mbean, "BodyMaxChars", max);
                    jolokia.setAttribute(mbean, "BodyIncludeStreams", streams);
                    jolokia.setAttribute(mbean, "BodyIncludeFiles", streams);
                    jolokia.execute(mbean, method, Core.onSuccess(breakpointsChanged));
                }
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
/// <reference path="endpointChooser.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.EndpointController", ["$scope", "$location", "localStorage", "workspace", "jolokia", function ($scope, $location, localStorage, workspace, jolokia) {
            Camel.initEndpointChooserScope($scope, $location, localStorage, workspace, jolokia);
            $scope.loadEndpointNames();
            $scope.workspace = workspace;
            $scope.message = "";
            $scope.createEndpoint = function (name) {
                var jolokia = workspace.jolokia;
                if (jolokia) {
                    var mbean = Camel.getSelectionCamelContextMBean(workspace);
                    if (mbean) {
                        $scope.message = name;
                        var operation = "createEndpoint(java.lang.String)";
                        jolokia.execute(mbean, operation, name, Core.onSuccess(operationSuccess));
                    }
                    else {
                        Core.notification("error", "Could not find the CamelContext MBean!");
                    }
                }
            };
            $scope.createEndpointFromData = function () {
                if ($scope.selectedComponentName && $scope.endpointPath) {
                    var name = $scope.selectedComponentName + "://" + $scope.endpointPath;
                    console.log("Have endpoint data " + JSON.stringify($scope.endpointParameters));
                    var params = "";
                    angular.forEach($scope.endpointParameters, function (value, key) {
                        var prefix = params ? "&" : "";
                        params += prefix + key + "=" + value;
                    });
                    if (params) {
                        name += "?" + params;
                    }
                    // TODO use form data too for URIs parameters...
                    $scope.createEndpoint(name);
                }
            };
            $scope.deleteEndpoint = function () {
                var jolokia = workspace.jolokia;
                var selection = workspace.selection;
                var entries = selection.entries;
                if (selection && jolokia && entries) {
                    var domain = selection.domain;
                    var brokerName = entries["BrokerName"];
                    var name = entries["Destination"];
                    var isQueue = "Topic" !== entries["Type"];
                    if (domain && brokerName) {
                        var mbean = "" + domain + ":BrokerName=" + brokerName + ",Type=Broker";
                        $scope.message = "Deleting " + (isQueue ? "queue" : "topic") + " " + name;
                        var operation = "removeEndpoint(java.lang.String)";
                        jolokia.execute(mbean, operation, name, Core.onSuccess(deleteSuccess));
                    }
                }
            };
            function operationSuccess(endpointCreated) {
                $scope.endpointName = "";
                $scope.workspace.operationCounter += 1;
                Core.$apply($scope);
                if (endpointCreated && endpointCreated === true) {
                    Core.notification('success', "Creating endpoint " + $scope.message);
                }
                else {
                    Core.notification('danger', "Failed to create endpoint " + $scope.message);
                }
            }
            function deleteSuccess() {
                // lets set the selection to the parent
                if (workspace.selection) {
                    var parent = Core.pathGet(workspace, ["selection", "parent"]);
                    if (parent) {
                        $scope.workspace.updateSelectionNode(parent);
                    }
                }
                $scope.workspace.operationCounter += 1;
                Core.$apply($scope);
                Core.notification("success", $scope.message);
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.EndpointRuntimeRegistryController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.data = [];
            $scope.selectedMBean = null;
            $scope.mbeanAttributes = {};
            var columnDefs = [
                {
                    field: 'url',
                    displayName: 'URL'
                },
                {
                    field: 'routeId',
                    displayName: 'Route ID'
                },
                {
                    field: 'direction',
                    displayName: 'Direction'
                },
                {
                    field: 'static',
                    displayName: 'Static'
                },
                {
                    field: 'dynamic',
                    displayName: 'Dynamic'
                },
                {
                    field: 'hits',
                    displayName: 'Hits'
                }
            ];
            $scope.gridOptions = {
                data: 'data',
                displayFooter: true,
                displaySelectionCheckbox: false,
                canSelectRows: false,
                enableSorting: true,
                columnDefs: columnDefs,
                selectedItems: [],
                filterOptions: {
                    filterText: ''
                },
                primaryKeyFn: function (entity) { return entity.routeId; }
            };
            function onRestRegistry(response) {
                var obj = response.value;
                if (obj) {
                    // the JMX tabular data has 2 indexes so we need to dive 2 levels down to grab the data
                    var arr = [];
                    for (var key in obj) {
                        var entry = obj[key];
                        arr.push({
                            url: entry.url,
                            routeId: entry.routeId,
                            direction: entry.direction,
                            static: entry.static,
                            dynamic: entry.dynamic,
                            hits: entry.hits
                        });
                    }
                    arr = _.sortBy(arr, "url");
                    $scope.data = arr;
                    // okay we have the data then set the selected mbean which allows UI to display data
                    $scope.selectedMBean = response.request.mbean;
                }
                else {
                    // set the mbean to a value so the ui can get updated
                    $scope.selectedMBean = "true";
                }
                // ensure web page is updated
                Core.$apply($scope);
            }
            $scope.renderIcon = function (state) {
                return Camel.iconClass(state);
            };
            function loadEndpointRegistry() {
                console.log("Loading EndpointRuntimeRegistry data...");
                var mbean = Camel.getSelectionCamelEndpointRuntimeRegistry(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'endpointStatistics' }, Core.onSuccess(onRestRegistry));
                }
            }
            // load data
            loadEndpointRegistry();
        }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    Camel.jmsHeaderSchema = {
        definitions: {
            headers: {
                properties: {
                    JMSCorrelationID: {
                        type: "java.lang.String"
                    },
                    JMSDeliveryMode: {
                        "type": "string",
                        "enum": [
                            "PERSISTENT",
                            "NON_PERSISTENT"
                        ]
                    },
                    JMSDestination: {
                        type: "javax.jms.Destination"
                    },
                    JMSExpiration: {
                        type: "long"
                    },
                    JMSPriority: {
                        type: "int"
                    },
                    JMSReplyTo: {
                        type: "javax.jms.Destination"
                    },
                    JMSType: {
                        type: "java.lang.String"
                    },
                    JMSXGroupId: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_CRON: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_DELAY: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_PERIOD: {
                        type: "java.lang.String"
                    },
                    AMQ_SCHEDULED_REPEAT: {
                        type: "java.lang.String"
                    }
                }
            },
            "javax.jms.Destination": {
                type: "java.lang.String"
            }
        }
    };
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PreferencesController", ["$scope", "localStorage", function ($scope, localStorage) {
            var config = {
                properties: {
                    camelHideOptionDocumentation: {
                        type: 'boolean',
                        default: Camel.defaultHideOptionDocumentation,
                        description: 'Whether to hide documentation in the properties view and Camel route editor'
                    },
                    camelHideOptionDefaultValue: {
                        type: 'boolean',
                        default: Camel.defaultHideOptionDefaultValue,
                        description: 'Whether to hide options that are using a default value in the properties view'
                    },
                    camelHideOptionUnusedValue: {
                        type: 'boolean',
                        default: Camel.defaultHideOptionUnusedValue,
                        description: 'Whether to hide unused/empty options in the properties view'
                    },
                    camelTraceOrDebugIncludeStreams: {
                        type: 'boolean',
                        default: Camel.defaultCamelTraceOrDebugIncludeStreams,
                        description: 'Whether to include stream based message body when using the tracer and debugger'
                    },
                    camelMaximumTraceOrDebugBodyLength: {
                        type: 'number',
                        default: Camel.defaultCamelMaximumTraceOrDebugBodyLength,
                        description: 'The maximum length of the body before its clipped when using the tracer and debugger'
                    },
                    camelMaximumLabelWidth: {
                        type: 'number',
                        description: 'The maximum length of a label in Camel diagrams before it is clipped'
                    },
                    camelIgnoreIdForLabel: {
                        type: 'boolean',
                        default: false,
                        description: 'If enabled then we will ignore the ID value when viewing a pattern in a Camel diagram; otherwise we will use the ID value as the label (the tooltip will show the actual detail)'
                    },
                    camelShowInflightCounter: {
                        type: 'boolean',
                        default: true,
                        description: 'Whether to show inflight counter in route diagram'
                    },
                    camelRouteMetricMaxSeconds: {
                        type: 'number',
                        min: '1',
                        max: '100',
                        description: 'The maximum value in seconds used by the route metrics duration and histogram charts'
                    }
                }
            };
            $scope.entity = $scope;
            $scope.config = config;
            Core.initPreferenceScope($scope, localStorage, {
                'camelIgnoreIdForLabel': {
                    'value': false,
                    'converter': Core.parseBooleanValue,
                    'post': function (newValue) {
                        $scope.$emit('ignoreIdForLabel', newValue);
                    }
                },
                'camelShowInflightCounter': {
                    'value': true,
                    'converter': Core.parseBooleanValue
                },
                'camelMaximumLabelWidth': {
                    'value': Camel.defaultMaximumLabelWidth,
                    'converter': parseInt
                },
                'camelMaximumTraceOrDebugBodyLength': {
                    'value': Camel.defaultCamelMaximumTraceOrDebugBodyLength,
                    'converter': parseInt
                },
                'camelTraceOrDebugIncludeStreams': {
                    'value': Camel.defaultCamelTraceOrDebugIncludeStreams,
                    'converter': Core.parseBooleanValue
                },
                'camelRouteMetricMaxSeconds': {
                    'value': Camel.defaultCamelRouteMetricMaxSeconds,
                    'converter': parseInt
                },
                'camelHideOptionDocumentation': {
                    'value': Camel.defaultHideOptionDocumentation,
                    'converter': Core.parseBooleanValue,
                    'post': function (newValue) {
                        $scope.$emit('hideOptionDocumentation', newValue);
                    }
                },
                'camelHideOptionDefaultValue': {
                    'value': Camel.defaultHideOptionDefaultValue,
                    'converter': Core.parseBooleanValue,
                    'post': function (newValue) {
                        $scope.$emit('hideOptionDefaultValue', newValue);
                    }
                },
                'camelHideOptionUnusedValue': {
                    'value': Camel.defaultHideOptionUnusedValue,
                    'converter': Core.parseBooleanValue,
                    'post': function (newValue) {
                        $scope.$emit('hideOptionUnusedValue', newValue);
                    }
                }
            });
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.ProfileRouteController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.initDone = false;
            $scope.data = [];
            var columnDefs = [
                {
                    field: 'id',
                    displayName: 'ID',
                    cellFilter: null,
                    width: "**",
                    resizable: true
                },
                {
                    field: 'count',
                    displayName: 'Count',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'last',
                    displayName: 'Last',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'delta',
                    displayName: 'Delta',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'mean',
                    displayName: 'Mean',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'min',
                    displayName: 'Min',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'max',
                    displayName: 'Max',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'total',
                    displayName: 'Total',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'self',
                    displayName: 'Self',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                }
            ];
            $scope.clearFilter = function () {
                $scope.gridOptions.filterOptions.filterText = '';
            };
            $scope.rowIcon = function (id) {
                var entry = $scope.icons[id];
                if (entry) {
                    return entry.img + " " + id;
                }
                else {
                    return id;
                }
            };
            $scope.gridOptions = {
                data: 'data',
                selectedItems: [],
                displayFooter: true,
                displaySelectionCheckbox: false,
                canSelectRows: false,
                enableSorting: false,
                columnDefs: columnDefs,
                filterOptions: {
                    filterText: ''
                }
            };
            function onProfile(response) {
                var updatedData = [];
                // its xml structure so we need to parse it
                var xml = response.value;
                if (angular.isString(xml)) {
                    // lets parse the XML DOM here...
                    var doc = $.parseXML(xml);
                    var routeMessages = $(doc).find("routeStat");
                    routeMessages.each(function (idx, message) {
                        var messageData = {
                            id: {},
                            count: {},
                            last: {},
                            delta: {},
                            mean: {},
                            min: {},
                            max: {},
                            total: {},
                            self: {}
                        };
                        // compare counters, as we only update if we have new data
                        messageData.id = message.getAttribute("id");
                        var total = 0;
                        total += +message.getAttribute("exchangesCompleted");
                        total += +message.getAttribute("exchangesFailed");
                        messageData.count = total;
                        messageData.last = message.getAttribute("lastProcessingTime");
                        // delta is only avail from Camel 2.11 onwards
                        var delta = message.getAttribute("deltaProcessingTime");
                        if (delta) {
                            messageData.delta = delta;
                        }
                        else {
                            messageData.delta = 0;
                        }
                        messageData.mean = message.getAttribute("meanProcessingTime");
                        messageData.min = message.getAttribute("minProcessingTime");
                        messageData.max = message.getAttribute("maxProcessingTime");
                        messageData.total = message.getAttribute("totalProcessingTime");
                        messageData.self = message.getAttribute("selfProcessingTime");
                        updatedData.push(messageData);
                    });
                    var processorMessages = $(doc).find("processorStat");
                    processorMessages.each(function (idx, message) {
                        var messageData = {
                            id: {},
                            count: {},
                            last: {},
                            delta: {},
                            mean: {},
                            min: {},
                            max: {},
                            total: {},
                            self: {}
                        };
                        messageData.id = message.getAttribute("id");
                        var total = 0;
                        total += +message.getAttribute("exchangesCompleted");
                        total += +message.getAttribute("exchangesFailed");
                        messageData.count = total;
                        messageData.last = message.getAttribute("lastProcessingTime");
                        // delta is only avail from Camel 2.11 onwards
                        var delta = message.getAttribute("deltaProcessingTime");
                        if (delta) {
                            messageData.delta = delta;
                        }
                        else {
                            messageData.delta = 0;
                        }
                        messageData.mean = message.getAttribute("meanProcessingTime");
                        messageData.min = message.getAttribute("minProcessingTime");
                        messageData.max = message.getAttribute("maxProcessingTime");
                        // total time for processors is pre calculated as accumulated from Camel 2.11 onwards
                        var apt = message.getAttribute("accumulatedProcessingTime");
                        if (apt) {
                            messageData.total = apt;
                        }
                        else {
                            messageData.total = "0";
                        }
                        // self time for processors is their total time
                        messageData.self = message.getAttribute("totalProcessingTime");
                        updatedData.push(messageData);
                    });
                }
                // if we do as below with the forEach then the data does not update
                // replace data with updated data
                $scope.data = updatedData;
                $scope.initDone = true;
                // ensure web page is updated
                Core.$apply($scope);
            }
            ;
            function loadData() {
                console.log("Loading Camel route profile data...");
                var selectedRouteId = Camel.getSelectedRouteId(workspace);
                var routeMBean = Camel.getSelectionRouteMBean(workspace, selectedRouteId);
                // schedule update the profile data, based on the configured interval
                if (routeMBean) {
                    var query = {
                        type: 'exec',
                        mbean: routeMBean,
                        operation: 'dumpRouteStatsAsXml(boolean,boolean)',
                        arguments: [false, true]
                    };
                    Core.scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onProfile, query));
                }
            }
            // load data
            loadData();
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RestServicesController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.data = [];
            $scope.selectedMBean = null;
            $scope.mbeanAttributes = {};
            var columnDefs = [
                {
                    field: 'routeId',
                    displayName: 'Route ID'
                },
                {
                    field: 'url',
                    displayName: 'URL'
                },
                // {
                //   field: 'baseUrl',
                //   displayName: 'Base Url'
                // },
                // {
                //   field: 'basePath',
                //   displayName: 'Base Path'
                // },
                // {
                //   field: 'uriTemplate',
                //   displayName: 'Uri Template'
                // },
                {
                    field: 'method',
                    displayName: 'Method'
                },
                {
                    field: 'consumes',
                    displayName: 'Consumes'
                },
                {
                    field: 'produces',
                    displayName: 'Produces'
                },
            ];
            $scope.gridOptions = {
                data: 'data',
                displayFooter: true,
                displaySelectionCheckbox: false,
                canSelectRows: false,
                enableSorting: true,
                columnDefs: columnDefs,
                selectedItems: [],
                filterOptions: {
                    filterText: ''
                },
                primaryKeyFn: function (entity) { return entity.routeId; }
            };
            function onRestRegistry(response) {
                var obj = response.value;
                if (obj) {
                    // the JMX tabular data has 2 indexes so we need to dive 2 levels down to grab the data
                    var arr = [];
                    for (var key in obj) {
                        var values = obj[key];
                        for (var v in values) {
                            var entry = values[v];
                            arr.push({
                                url: entry.url,
                                // baseUrl: entry.baseUrl,
                                // basePath: entry.basePath,
                                // uriTemplate: entry.uriTemplate,
                                method: entry.method ? entry.method.toUpperCase() : '',
                                consumes: entry.consumes,
                                produces: entry.produces,
                                // inType: entry.inType,
                                // outType: entry.outType,
                                // state: entry.state,
                                routeId: entry.routeId,
                            });
                        }
                    }
                    arr = _.sortBy(arr, "url");
                    $scope.data = arr;
                    // okay we have the data then set the selected mbean which allows UI to display data
                    $scope.selectedMBean = response.request.mbean;
                }
                else {
                    // set the mbean to a value so the ui can get updated
                    $scope.selectedMBean = "true";
                }
                // ensure web page is updated
                Core.$apply($scope);
            }
            $scope.renderIcon = function (state) {
                return Camel.iconClass(state);
            };
            function loadRestRegistry() {
                console.log("Loading RestRegistry data...");
                var mbean = Camel.getSelectionCamelRestRegistry(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'listRestServices' }, Core.onSuccess(onRestRegistry));
                }
            }
            // load data
            loadRestRegistry();
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    function createGraphStates(nodes, links, transitions) {
        var stateKeys = {};
        nodes.forEach(function (node) {
            var idx = node.id;
            if (idx === undefined) {
                console.log("No node found for node " + JSON.stringify(node));
            }
            else {
                if (node.edges === undefined)
                    node.edges = [];
                if (!node.label)
                    node.label = "node " + idx;
                stateKeys[idx] = node;
            }
        });
        var states = d3.values(stateKeys);
        links.forEach(function (d) {
            var source = stateKeys[d.source];
            var target = stateKeys[d.target];
            if (source === undefined || target === undefined) {
                console.log("Bad link!  " + source + " target " + target + " for " + d);
            }
            else {
                var edge = { source: source, target: target };
                transitions.push(edge);
                source.edges.push(edge);
                target.edges.push(edge);
                // TODO should we add the edge to the target?
            }
        });
        return states;
    }
    Camel.createGraphStates = createGraphStates;
    // TODO Export as a service
    function dagreLayoutGraph(nodes, links, svgElement, allowDrag, onClick) {
        var _this = this;
        if (allowDrag === void 0) { allowDrag = false; }
        if (onClick === void 0) { onClick = null; }
        var nodePadding = 10;
        var transitions = [];
        var states = createGraphStates(nodes, links, transitions);
        // Translates all points in the edge using `dx` and `dy`.
        function translateEdge(e, dx, dy) {
            e.points.forEach(function (p) {
                p.x = Math.max(0, Math.min(svgBBox.width, p.x + dx));
                p.y = Math.max(0, Math.min(svgBBox.height, p.y + dy));
            });
        }
        // Now start laying things out
        var svg = svgElement ? d3.select(svgElement) : d3.select("svg");
        // lets remove all the old g elements
        if (svgElement) {
            $(svgElement).children("g").remove();
        }
        $(svg).children("g").remove();
        var svgGroup = svg.append("g");
        // `nodes` is center positioned for easy layout later
        var nodes = svgGroup
            .selectAll("g .node")
            .data(states)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("data-cid", function (d) { return d.cid; })
            .attr("id", function (d) { return "node-" + d.label; });
        // lets add a tooltip
        nodes.append("title").text(function (d) { return d.tooltip || ""; });
        if (onClick != null) {
            nodes.on("click", onClick);
        }
        var edges = svgGroup
            .selectAll("path .edge")
            .data(transitions)
            .enter()
            .append("path")
            .attr("class", "edge")
            .attr("marker-end", "url(#arrowhead)");
        // Append rectangles to the nodes. We do this before laying out the text
        // because we want the text above the rectangle.
        var rects = nodes.append("rect")
            .attr("rx", "4")
            .attr("ry", "4")
            .attr("class", function (d) { return d.type; });
        var images = nodes.append("image")
            .attr("xlink:href", function (d) { return d.imageUrl; })
            .attr("x", -12)
            .attr("y", -20)
            .attr("height", 24)
            .attr("width", 24);
        var counters = nodes
            .append("text")
            .attr("text-anchor", "end")
            .attr("class", "counter")
            .attr("x", 0)
            .attr("dy", 0)
            .text(_counterFunction);
        var inflights = nodes
            .append("text")
            .attr("text-anchor", "middle")
            .attr("class", "inflight")
            .attr("x", 10)
            .attr("dy", -32)
            .text(_inflightFunction);
        // Append text
        var labels = nodes
            .append("text")
            .attr("text-anchor", "middle")
            .attr("x", 0);
        labels
            .append("tspan")
            .attr("x", 0)
            .attr("dy", 28)
            .text(function (d) { return d.label; });
        var labelPadding = 12;
        var minLabelwidth = 80;
        labels.each(function (d) {
            var bbox = this.getBBox();
            d.bbox = bbox;
            if (bbox.width < minLabelwidth) {
                bbox.width = minLabelwidth;
            }
            d.width = bbox.width + 2 * nodePadding;
            d.height = bbox.height + 2 * nodePadding + labelPadding;
        });
        rects
            .attr("x", function (d) { return -(d.bbox.width / 2 + nodePadding); })
            .attr("y", function (d) { return -(d.bbox.height / 2 + nodePadding + (labelPadding / 2)); })
            .attr("width", function (d) { return d.width; })
            .attr("height", function (d) { return d.height; });
        images.attr("x", function (d) { return -(d.bbox.width) / 3; });
        labels
            .attr("x", function (d) { return -d.bbox.width / 2; })
            .attr("y", function (d) { return -d.bbox.height / 2; });
        counters.attr("x", function (d) { return d.bbox.width / 2; });
        var g = new graphlib.Graph({
            multigraph: false,
            compound: false
        })
            .setGraph({
            ranker: 'longest-path',
        });
        states.forEach(function (node) { return g.setNode(node.id, node); });
        transitions.forEach(function (edge) { return g.setEdge(edge.source.id, edge.target.id, edge); });
        dagre.layout(g);
        nodes.attr("transform", function (d) { return 'translate(' + d.x + ',' + d.y + ')'; });
        var line = d3.svg.line()
            .x(function (d) { return d.x; })
            .y(function (d) { return d.y; })
            .interpolate("linear");
        edges
            .attr('id', function (e) { return e.id; })
            .attr("d", function (e) { return line(e.points); });
        var svgNode = svg.node();
        if (svgNode) {
            var svgBBox = svgNode.getBBox();
        }
        // configure dragging if enabled
        if (allowDrag) {
            // Drag handlers
            var nodeDrag = d3.behavior.drag()
                .origin(function (d) { return d.pos ? { x: d.pos.x, y: d.pos.y } : { x: d.x, y: d.y }; })
                .on('drag', function (d, i) {
                var prevX = d.x, prevY = d.y;
                // The node must be inside the SVG area
                d.x = Math.max(d.width / 2, Math.min(svgBBox.width - d.width / 2, d3.event.x));
                d.y = Math.max(d.height / 2, Math.min(svgBBox.height - d.height / 2, d3.event.y));
                d3.select(this).attr('transform', 'translate(' + d.x + ',' + d.y + ')');
                var dx = d.x - prevX, dy = d.y - prevY;
                // Edges position (inside SVG area)
                d.edges.forEach(function (e) {
                    translateEdge(e, dx, dy);
                    d3.select('#' + e.id).attr('d', line(e));
                });
            });
            var edgeDrag = d3.behavior.drag()
                .on('drag', function (d, i) {
                translateEdge(d, d3.event.dx, d3.event.dy);
                d3.select(_this).attr('d', line(d));
            });
            nodes.call(nodeDrag);
            edges.call(edgeDrag);
        }
        return { nodes: states, graph: g };
    }
    Camel.dagreLayoutGraph = dagreLayoutGraph;
    // TODO Export as a service
    function dagreUpdateGraphData() {
        var svg = d3.select("svg");
        svg.selectAll("text.counter").text(_counterFunction);
        svg.selectAll("text.inflight").text(_inflightFunction);
        // add tooltip
        svg.selectAll("g .node title").text(function (d) { return d.tooltip || ""; });
        /*
         TODO can we reuse twitter bootstrap on an svg title?
         .each(function (d) {
         $(d).tooltip({
         'placement': "bottom"
         });
         });
    
         */
    }
    Camel.dagreUpdateGraphData = dagreUpdateGraphData;
    function _counterFunction(d) {
        return d.counter || "";
    }
    function _inflightFunction(d) {
        return d.inflight || "";
    }
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
/// <reference path="routeDiagramHelpers.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RouteController", ["$scope", "$routeParams", "$element", "$timeout", "workspace", "$location", "jolokia", "localStorage", function ($scope, $routeParams, $element, $timeout, workspace, $location, jolokia, localStorage) {
            var log = Logger.get("Camel");
            $scope.routes = [];
            $scope.routeNodes = {};
            // if we are in dashboard then $routeParams may be null
            if ($routeParams != null) {
                $scope.contextId = $routeParams["contextId"];
                $scope.routeId = Core.trimQuotes($routeParams["routeId"]);
                $scope.isJmxTab = !$routeParams["contextId"] || !$routeParams["routeId"];
            }
            $scope.camelIgnoreIdForLabel = Camel.ignoreIdForLabel(localStorage);
            $scope.camelMaximumLabelWidth = Camel.maximumLabelWidth(localStorage);
            $scope.camelShowInflightCounter = Camel.showInflightCounter(localStorage);
            var updateRoutes = _.debounce(doUpdateRoutes, 300, { trailing: true });
            // lets delay a little updating the routes to avoid timing issues where we've not yet
            // fully loaded the workspace and/or the XML model
            var delayUpdatingRoutes = 300;
            $scope.$on('jmxTreeUpdated', function () {
                updateRoutes();
            });
            $scope.$watch('nodeXmlNode', function () {
                if ($scope.isJmxTab && workspace.moveIfViewInvalid())
                    return;
                updateRoutes();
            });
            function doUpdateRoutes() {
                var routeXmlNode = null;
                if (!$scope.ignoreRouteXmlNode) {
                    routeXmlNode = Camel.getSelectedRouteNode(workspace);
                    if (!routeXmlNode) {
                        routeXmlNode = $scope.nodeXmlNode;
                    }
                    if (routeXmlNode && routeXmlNode.localName !== "route") {
                        var wrapper = document.createElement("route");
                        wrapper.appendChild(routeXmlNode.cloneNode(true));
                        routeXmlNode = wrapper;
                    }
                }
                $scope.mbean = Camel.getSelectionCamelContextMBean(workspace);
                if (!$scope.mbean && $scope.contextId) {
                    $scope.mbean = Camel.getCamelContextMBean(workspace, $scope.contextId);
                }
                if (routeXmlNode) {
                    // lets show the remaining parts of the diagram of this route node
                    $scope.nodes = {};
                    var nodes = [];
                    var links = [];
                    Camel.addRouteXmlChildren($scope, routeXmlNode, nodes, links, null, 0, 0);
                    showGraph(nodes, links);
                }
                else if ($scope.mbean) {
                    jolokia.request({ type: 'exec', mbean: $scope.mbean, operation: 'dumpRoutesAsXml()' }, Core.onSuccess(populateTable));
                }
                else {
                    log.info("No camel context bean! Selection: " + workspace.selection);
                }
            }
            var populateTable = function (response) {
                var data = response.value;
                // routes is the xml data of the routes
                $scope.routes = data;
                // nodes and routeNodes is the GUI nodes for the processors and routes shown in the diagram
                $scope.nodes = {};
                $scope.routeNodes = {};
                var nodes = [];
                var links = [];
                var selectedRouteId = $scope.routeId;
                if (!selectedRouteId) {
                    selectedRouteId = Camel.getSelectedRouteId(workspace);
                }
                if (data) {
                    var doc = $.parseXML(data);
                    Camel.loadRouteXmlNodes($scope, doc, selectedRouteId, nodes, links, $element.width());
                    showGraph(nodes, links);
                }
                else {
                    console.log("No data from route XML!");
                }
                Core.$apply($scope);
            };
            var postfix = " selected";
            function isSelected(node) {
                if (node) {
                    var className = node.getAttribute("class");
                    return className && _.endsWith(className, postfix);
                }
                return false;
            }
            function setSelected(node, flag) {
                var answer = false;
                if (node) {
                    var className = node.getAttribute("class");
                    var selected = className && _.endsWith(className, postfix);
                    if (selected) {
                        className = className.substring(0, className.length - postfix.length);
                    }
                    else {
                        if (!flag) {
                            // no need to change!
                            return answer;
                        }
                        className = className + postfix;
                        answer = true;
                    }
                    node.setAttribute("class", className);
                }
                return answer;
            }
            function onClickGraphNode(node) {
                log.debug("Clicked on Camel Route Diagram node: " + node.cid);
                if (workspace.isRoutesFolder()) {
                    // Handle nodes selection from a diagram displaying multiple routes
                    handleGraphNode(node);
                }
                else {
                    updateRouteProperties(node, workspace.selection);
                }
            }
            ;
            function navigateToNodeProperties(cid) {
                $location.path('/camel/propertiesRoute').search({ 'main-tab': 'camel', 'nid': cid });
                Core.$apply($scope);
            }
            function handleGraphNode(node) {
                var cid = node.cid;
                var routes = $scope.routes;
                if (routes) {
                    var route = null;
                    // Find the route associated with the node that was clicked on the diagram
                    var doc = $.parseXML(routes);
                    route = $(doc).find("#" + cid).parents("route") || $(doc).find("[uri='" + cid + "']").parents("route");
                    // Fallback on using rid if no matching route was found
                    if ((!route || !route.length) && node.rid) {
                        route = $(doc).find("[id='" + node.rid + "']");
                    }
                    if (route && route.length) {
                        var routeFolder = null;
                        angular.forEach(workspace.selection.children, function (c) {
                            if (c.text === route[0].id) {
                                routeFolder = c;
                            }
                        });
                        if (routeFolder) {
                            // Populate route folder child nodes for the context tree
                            if (!routeFolder.children || !routeFolder.children.length) {
                                // Ideally, we want to trigger lazy loading via node expansion
                                // though there is no callback to hook into to update the view
                                var plugin = Jmx.findLazyLoadingFunction(workspace, routeFolder);
                                if (plugin) {
                                    var tree_1 = $('#cameltree').treeview(true);
                                    plugin(workspace, routeFolder, function (children) {
                                        tree_1.addNode(children, routeFolder, { silent: true });
                                        updateRouteProperties(node, routeFolder);
                                    });
                                }
                                // We've forced lazy loading so let's turn it off
                                routeFolder.lazyLoad = false;
                            }
                            else {
                                updateRouteProperties(node, routeFolder);
                            }
                        }
                    }
                    else {
                        log.debug("No route found for " + cid);
                    }
                }
            }
            function updateRouteProperties(node, routeFolder) {
                var cid = node.cid;
                // Get the 'real' cid of the selected diagram node
                var routeChild = routeFolder.findDescendant(function (child) {
                    var uri = node.uri;
                    if (uri && uri.indexOf('?') > 0) {
                        uri = uri.substring(0, uri.indexOf('?'));
                    }
                    return child.text === node.cid || (child.routeXmlNode && child.routeXmlNode.nodeName === node.type && child.text === uri);
                });
                if (routeChild) {
                    cid = routeChild.key;
                }
                navigateToNodeProperties(cid);
            }
            function showGraph(nodes, links) {
                var canvasDiv = $element;
                var svg = canvasDiv.children("svg")[0];
                // do not allow clicking on node to show properties if debugging or tracing as that is for selecting the node instead
                var onClick;
                var path = $location.path();
                if (_.startsWith(path, "/camel/debugRoute") || _.startsWith(path, "/camel/traceRoute")) {
                    onClick = null;
                }
                else {
                    onClick = onClickGraphNode;
                }
                var render = Camel.dagreLayoutGraph(nodes, links, svg, false, onClick).graph;
                var container = d3.select(svg);
                var zoom = d3.behavior.zoom()
                    .on('zoom', function () { return container.select('g')
                    .attr('transform', "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")"); });
                container.call(zoom);
                // We want to have the diagram to be uniformally scaled and centered within the SVG viewport
                // TODO: set translate extent
                function viewBox() {
                    // But we don't want smaller diagrams to be scaled up so we set the viewBox to
                    // the diagram bounding box only for diagrams that overflow the SVG viewport,
                    // so that they scale down with preserved aspect ratio
                    var graph = render.graph();
                    if (graph.width > canvasDiv.width() || graph.height > canvasDiv.height()) {
                        container.attr('viewBox', "0 0 " + graph.width + " " + graph.height);
                        // Bound maximum scale to nominal size
                        zoom.scaleExtent([1, 1 / Math.min(canvasDiv.width() / graph.width, canvasDiv.height() / graph.height)]);
                    }
                    else {
                        // For diagrams smaller than the SVG viewport size, we still want them to be centered
                        // with the 'preserveAspectRatio' attribute set to 'xMidYMid'
                        container.attr('viewBox', (graph.width - canvasDiv.width()) / 2 + " " + (graph.height - canvasDiv.height()) / 2 + " " + canvasDiv.width() + " " + canvasDiv.height());
                        // Reset the zoom scale and disable scaling
                        zoom.scale(1);
                        zoom.scaleExtent([1, 1]);
                        // TODO: smooth transitioning from scaled down state
                        container.call(zoom.event);
                    }
                }
                // We need to adapt the viewBox for smaller diagrams as it depends on the SVG viewport size
                var resizeViewBox = _.debounce(viewBox, 10, { leading: true, trailing: true });
                window.addEventListener('resize', resizeViewBox);
                $scope.$on('$destroy', function () { return window.removeEventListener('resize', resizeViewBox); });
                // Lastly, we need to do it once at initialisation
                viewBox();
                // Only apply node selection behavior if debugging or tracing
                if (_.startsWith(path, "/camel/debugRoute") || _.startsWith(path, "/camel/traceRoute")) {
                    var gNodes = canvasDiv.find("g.node");
                    gNodes.click(function () {
                        var selected = isSelected(this);
                        // lets clear all selected flags
                        gNodes.each(function (idx, element) {
                            setSelected(element, false);
                        });
                        var cid = null;
                        if (!selected) {
                            cid = this.getAttribute("data-cid");
                            setSelected(this, true);
                        }
                        $scope.$emit("camel.diagram.selectedNodeId", cid);
                        Core.$apply($scope);
                    });
                }
                if ($scope.mbean) {
                    Core.register(jolokia, $scope, {
                        type: 'exec', mbean: $scope.mbean,
                        operation: 'dumpRoutesStatsAsXml',
                        arguments: [true, true]
                        // the dumpRoutesStatsAsXml is not available in all Camel versions so do not barf on errors
                    }, Core.onSuccess(statsCallback, { silent: true, error: false }));
                }
                $scope.$emit("camel.diagram.layoutComplete");
            }
            function statsCallback(response) {
                var data = response.value;
                if (data) {
                    var doc = $.parseXML(data);
                    var allStats = $(doc).find("routeStat");
                    allStats.each(function (idx, stat) {
                        addTooltipToNode(true, stat);
                    });
                    var allStats = $(doc).find("processorStat");
                    allStats.each(function (idx, stat) {
                        addTooltipToNode(false, stat);
                    });
                    // now lets try update the graph
                    Camel.dagreUpdateGraphData();
                }
                function addTooltipToNode(isRoute, stat) {
                    // we could have used a function instead of the boolean isRoute parameter (but sometimes that is easier)
                    var id = stat.getAttribute("id");
                    var completed = stat.getAttribute("exchangesCompleted");
                    var inflight = stat.hasAttribute("exchangesInflight") ? stat.getAttribute("exchangesInflight") : 0;
                    var tooltip = "";
                    if (id && completed) {
                        var container = isRoute ? $scope.routeNodes : $scope.nodes;
                        var node = container[id];
                        if (!node) {
                            angular.forEach(container, function (value, key) {
                                if (!node && id === value.elementId) {
                                    node = value;
                                }
                            });
                        }
                        if (node) {
                            var total = 0 + parseInt(completed);
                            var failed = stat.getAttribute("exchangesFailed");
                            if (failed) {
                                total += parseInt(failed);
                            }
                            var last = stat.getAttribute("lastProcessingTime");
                            var mean = stat.getAttribute("meanProcessingTime");
                            var min = stat.getAttribute("minProcessingTime");
                            var max = stat.getAttribute("maxProcessingTime");
                            tooltip = "total: " + total + "\ninflight:" + inflight + "\nlast: " + last + " (ms)\nmean: " + mean + " (ms)\nmin: " + min + " (ms)\nmax: " + max + " (ms)";
                            node["counter"] = total;
                            if ($scope.camelShowInflightCounter) {
                                node["inflight"] = inflight;
                            }
                            var labelSummary = node["labelSummary"];
                            if (labelSummary) {
                                tooltip = labelSummary + "\n\n" + tooltip;
                            }
                            node["tooltip"] = tooltip;
                        }
                        else {
                            // we are probably not showing the route for these stats
                        }
                    }
                }
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.RouteMetricsController", ["$scope", "$location", "workspace", "jolokia", "metricsWatcher", function ($scope, $location, workspace, jolokia, metricsWatcher) {
            var log = Logger.get("Camel");
            $scope.maxSeconds = Camel.routeMetricMaxSeconds(localStorage);
            $scope.filterText = null;
            $scope.initDone = false;
            $scope.metricDivs = [];
            $scope.metricVisible = function (metric) {
                log.debug("Filter by route " + metric);
                return Core.matchFilterIgnoreCase(metric.routeId, $scope.filterText);
            };
            function populateRouteStatistics(response) {
                var obj = response.value;
                if (obj) {
                    // turn into json javascript object which metrics watcher requires
                    var json = JSON.parse(obj);
                    if (!$scope.initDone) {
                        // figure out which routes we have
                        var meters = json['timers'];
                        var counter = 0;
                        if (meters != null) {
                            for (var v in meters) {
                                var key = v;
                                var firstDot = key.indexOf(".");
                                var lastDot = key.lastIndexOf(".");
                                var title = key.substring(firstDot + 1, lastDot);
                                var className = key.substr(0, lastDot);
                                var metricsName = key.substr(lastDot + 1);
                                var firstColon = key.indexOf(":");
                                // compute route id from the key, which is text after the 1st colon, and the last dot
                                var routeId = key.substr(firstColon + 1);
                                lastDot = routeId.lastIndexOf(".");
                                if (lastDot > 0) {
                                    routeId = routeId.substr(0, lastDot);
                                }
                                var entry = meters[v];
                                var div = "timer-" + counter;
                                $scope.metricDivs.push({
                                    id: div,
                                    routeId: routeId
                                });
                                counter++;
                                log.info("Added timer: " + div + " (" + className + "." + metricsName + ") for route: " + routeId + " with max seconds: " + $scope.maxSeconds);
                                metricsWatcher.addTimer(div, className, metricsName, $scope.maxSeconds, title, "Histogram", $scope.maxSeconds * 1000);
                            }
                            // ensure web page is updated at this point, as we need the metricDivs in the HTML before we call init graphs later
                            log.info("Pre-init graphs");
                            Core.$apply($scope);
                        }
                        log.info("Init graphs");
                        metricsWatcher.initGraphs();
                    }
                    $scope.initDone = true;
                    // update graphs
                    log.debug("Updating graphs: " + json);
                    metricsWatcher.updateGraphs(json);
                }
                $scope.initDone = true;
                // ensure web page is updated
                Core.$apply($scope);
            }
            // function to trigger reloading page
            $scope.onResponse = function (response) {
                loadData();
            };
            $scope.$watch('workspace.tree', function () {
                // if the JMX tree is reloaded its probably because a new MBean has been added or removed
                // so lets reload, asynchronously just in case
                setTimeout(loadData, 50);
            });
            function loadData() {
                log.info("Loading RouteMetrics data...");
                // pre-select filter if we have selected a route
                var routeId = Camel.getSelectedRouteId(workspace);
                if (routeId != null) {
                    $scope.filterText = routeId;
                }
                var mbean = Camel.getSelectionCamelRouteMetrics(workspace);
                if (mbean) {
                    var query = { type: 'exec', mbean: mbean, operation: 'dumpStatisticsAsJson' };
                    Core.scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(populateRouteStatistics, query));
                }
                else {
                    $scope.initDone = true;
                    // ensure web page is updated
                    Core.$apply($scope);
                }
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
/// <reference path="camelHeaderSchema.ts"/>
/// <reference path="jmsHeaderSchema.ts"/>
var Camel;
(function (Camel) {
    var DELIVERY_PERSISTENT = "2";
    Camel._module.controller("Camel.SendMessageController", ["$route", "$scope", "$element", "$timeout", "workspace", "jolokia", "localStorage", "$location", "activeMQMessage", function ($route, $scope, $element, $timeout, workspace, jolokia, localStorage, $location, activeMQMessage) {
            var log = Logger.get("Camel");
            $scope.noCredentials = false;
            $scope.container = {};
            $scope.message = "";
            $scope.headers = [];
            // bind model values to search params...
            Core.bindModelToSearchParam($scope, $location, "tab", "subtab", "compose");
            Core.bindModelToSearchParam($scope, $location, "searchText", "q", "");
            // only reload the page if certain search parameters change
            Core.reloadWhenParametersChange($route, $scope, $location);
            $scope.checkCredentials = function () {
                $scope.noCredentials = (Core.isBlank(localStorage['activemqUserName']) || Core.isBlank(localStorage['activemqPassword']));
            };
            if ($location.path().indexOf('activemq') > -1) {
                $scope.localStorage = localStorage;
                $scope.$watch('localStorage.activemqUserName', $scope.checkCredentials);
                $scope.$watch('localStorage.activemqPassword', $scope.checkCredentials);
                //prefill if it's a resent
                if (activeMQMessage.message !== null) {
                    $scope.message = activeMQMessage.message.bodyText;
                    if (activeMQMessage.message.PropertiesText !== null) {
                        for (var p in activeMQMessage.message.StringProperties) {
                            $scope.headers.push({ name: p, value: activeMQMessage.message.StringProperties[p] });
                        }
                    }
                }
                // always reset at the end
                activeMQMessage.message = null;
            }
            $scope.openPrefs = function () {
                $location.path('/preferences').search({ 'pref': 'ActiveMQ' });
            };
            var LANGUAGE_FORMAT_PREFERENCE = "defaultLanguageFormat";
            var sourceFormat = workspace.getLocalStorage(LANGUAGE_FORMAT_PREFERENCE) || "javascript";
            $scope.codeMirrorOptions = CodeEditor.createEditorSettings({
                mode: {
                    name: sourceFormat
                }
            });
            $scope.$on('hawtioEditor_default_instance', function (event, codeMirror) {
                $scope.codeMirror = codeMirror;
            });
            $scope.addHeader = function () {
                $scope.headers.push({ name: "", value: "" });
            };
            $scope.removeHeader = function (header) {
                var index = $scope.headers.indexOf(header);
                $scope.headers.splice(index, 1);
            };
            $scope.defaultHeaderNames = function () {
                var answer = [];
                function addHeaderSchema(schema) {
                    angular.forEach(schema.definitions.headers.properties, function (value, name) {
                        answer.push(name);
                    });
                }
                if (isJmsEndpoint()) {
                    addHeaderSchema(Camel.jmsHeaderSchema);
                }
                if (isCamelEndpoint()) {
                    addHeaderSchema(Camel.camelHeaderSchema);
                }
                return answer;
            };
            /* save the sourceFormat in preferences for later
             * Note, this would be controller specific preferences and not the global, overriding, preferences */
            // TODO Use ng-selected="changeSourceFormat()" - Although it seemed to fire multiple times..
            $scope.$watch('codeMirrorOptions.mode.name', function (newValue, oldValue) {
                workspace.setLocalStorage(LANGUAGE_FORMAT_PREFERENCE, newValue);
            });
            var sendWorked = function () {
                $scope.message = "";
                Core.notification("success", "Message sent!");
            };
            $scope.formatMessage = function () {
                CodeEditor.autoFormatEditor($scope.codeMirror);
            };
            $scope.sendMessage = function () {
                var body = $scope.message;
                doSendMessage(body, sendWorked);
            };
            function doSendMessage(body, onSendCompleteFn) {
                var selection = workspace.selection;
                if (selection) {
                    var mbean = selection.objectName;
                    if (mbean) {
                        var headers = null;
                        if ($scope.headers.length) {
                            headers = {};
                            angular.forEach($scope.headers, function (object) {
                                var key = object.name;
                                if (key) {
                                    headers[key] = object.value;
                                }
                            });
                            log.info("About to send headers: " + JSON.stringify(headers));
                        }
                        var callback = Core.onSuccess(onSendCompleteFn);
                        if (selection.domain === "org.apache.camel") {
                            var target = Camel.getContextAndTargetEndpoint(workspace);
                            var uri = target['uri'];
                            mbean = target['mbean'];
                            if (mbean && uri) {
                                // if we are running Camel 2.14 we can check if its possible to send to the endpoint
                                var ok = true;
                                if (Camel.isCamelVersionEQGT(2, 14, workspace, jolokia)) {
                                    var reply = jolokia.execute(mbean, "canSendToEndpoint(java.lang.String)", uri);
                                    if (!reply) {
                                        Core.notification("warning", "Camel does not support sending to this endpoint.");
                                        ok = false;
                                    }
                                }
                                if (ok) {
                                    if (headers) {
                                        jolokia.execute(mbean, "sendBodyAndHeaders(java.lang.String, java.lang.Object, java.util.Map)", uri, body, headers, callback);
                                    }
                                    else {
                                        jolokia.execute(mbean, "sendStringBody(java.lang.String, java.lang.String)", uri, body, callback);
                                    }
                                }
                            }
                            else {
                                if (!mbean) {
                                    Core.notification("error", "Could not find CamelContext MBean!");
                                }
                                else {
                                    Core.notification("error", "Failed to determine endpoint name!");
                                }
                                log.debug("Parsed context and endpoint: ", target);
                            }
                        }
                        else {
                            var user = localStorage["activemqUserName"];
                            var pwd = localStorage["activemqPassword"];
                            // AMQ is sending non persistent by default, so make sure we tell to sent persistent by default
                            if (!headers) {
                                headers = {};
                            }
                            if (!headers["JMSDeliveryMode"]) {
                                headers["JMSDeliveryMode"] = DELIVERY_PERSISTENT;
                            }
                            jolokia.execute(mbean, "sendTextMessage(java.util.Map, java.lang.String, java.lang.String, java.lang.String)", headers, body, user, pwd, callback);
                        }
                    }
                }
            }
            function isCamelEndpoint() {
                // TODO check for the camel or if its an activemq endpoint
                return true;
            }
            function isJmsEndpoint() {
                // TODO check for the jms/activemq endpoint in camel or if its an activemq endpoint
                return true;
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.SourceController", ["$scope", "workspace", function ($scope, workspace) {
            $scope.showUpdateButton = true;
            function getSource(routeXmlNode) {
                function removeCrappyHeaders(idx, e) {
                    var answer = e.getAttribute("customId");
                    if (e.nodeName === 'route') {
                        // always keep id on <route> element
                        answer = "true";
                    }
                    if (!answer || answer !== "true") {
                        e.removeAttribute("id");
                    }
                    // just always remove customId, _cid, and group
                    e.removeAttribute("customId");
                    e.removeAttribute("_cid");
                    e.removeAttribute("group");
                }
                var copy = $(routeXmlNode).clone();
                copy.each(removeCrappyHeaders);
                copy.find("*").each(removeCrappyHeaders);
                var newNode = (copy && copy.length) ? copy[0] : routeXmlNode;
                return Core.xmlNodeToString(newNode);
            }
            function updateRoutes() {
                // did we select a single route
                var routeXmlNode = Camel.getSelectedRouteNode(workspace);
                if (routeXmlNode) {
                    $scope.source = getSource(routeXmlNode);
                    $scope.showUpdateButton = routeXmlNode.nodeName === 'route';
                    Core.$apply($scope);
                }
                else {
                    // no then try to find the camel context and get all the routes code
                    $scope.mbean = Camel.getSelectionCamelContextMBean(workspace);
                    if (!$scope.mbean) {
                        // maybe the parent is the camel context folder (when we have selected the routes folder),
                        // then grab the object name from parent
                        var parent = Core.pathGet(workspace, ["selection", "parent"]);
                        if (parent && parent.title === "context") {
                            $scope.mbean = parent.children[0].objectName;
                        }
                    }
                    if ($scope.mbean) {
                        var jolokia = workspace.jolokia;
                        jolokia.request({ type: 'exec', mbean: $scope.mbean, operation: 'dumpRoutesAsXml()' }, Core.onSuccess(populateTable));
                    }
                }
            }
            var populateTable = function (response) {
                var data = response.value;
                var selectedRouteId = Camel.getSelectedRouteId(workspace);
                if (data && selectedRouteId) {
                    var doc = $.parseXML(data);
                    var routes = $(doc).find('route[id="' + selectedRouteId + '"]');
                    if (routes && routes.length) {
                        var selectedRoute = routes[0];
                        // Copy any XML namespaces over from the routes parent tag to the selected route child node
                        var routeParent = selectedRoute.parentNode;
                        if (routeParent && routeParent.nodeName === 'routes') {
                            if (routeParent.attributes) {
                                angular.forEach(routeParent.attributes, function (attr) {
                                    if (_.startsWith(attr.name, "xmlns")) {
                                        var attrCopy = doc.createAttribute(attr.name);
                                        attrCopy.value = attr.value;
                                        selectedRoute.attributes.setNamedItem(attrCopy);
                                    }
                                });
                            }
                        }
                        // TODO turn into XML?
                        var routeXml = getSource(selectedRoute);
                        if (routeXml) {
                            data = routeXml;
                        }
                    }
                }
                $scope.source = data;
                Core.$apply($scope);
            };
            var saveWorked = function () {
                Core.notification("success", "Route updated!");
                workspace.loadTree();
            };
            $scope.saveRouteXml = function () {
                var routeXml = $scope.source;
                if (routeXml) {
                    var decoded = decodeURIComponent(routeXml);
                    Camel.log.debug("addOrUpdateRoutesFromXml xml decoded: " + decoded);
                    var jolokia = workspace.jolokia;
                    var mbean = Camel.getSelectionCamelContextMBean(workspace);
                    if (mbean) {
                        jolokia.execute(mbean, "addOrUpdateRoutesFromXml(java.lang.String)", decoded, Core.onSuccess(saveWorked));
                    }
                    else {
                        Core.notification("error", "Could not find CamelContext MBean!");
                    }
                }
            };
            updateRoutes();
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TabsController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.tabs = [
                {
                    id: 'jmx-attributes',
                    title: 'Attributes',
                    path: "/jmx/attributes",
                    show: function () { return !isContextsFolder(workspace) && !workspace.isRoutesFolder(); }
                },
                {
                    id: 'camel-contexts',
                    title: 'Contexts',
                    path: "/camel/contexts",
                    show: function () { return isContextsFolder(workspace); }
                },
                {
                    id: 'camel-routes',
                    title: 'Routes',
                    path: "/camel/routes",
                    show: function () { return workspace.isRoutesFolder(); }
                },
                {
                    id: 'camel-route-diagram',
                    title: 'Route Diagram',
                    path: "/camel/routeDiagram",
                    show: function () { return (workspace.isRoute() || workspace.isRoutesFolder())
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelContextMBean(workspace), "dumpRoutesAsXml"); }
                },
                {
                    id: 'camel-route-source',
                    title: 'Source',
                    path: "/camel/source",
                    show: function () { return !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && (workspace.isRoute() || workspace.isRoutesFolder())
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelContextMBean(workspace), "dumpRoutesAsXml"); },
                    isSelected: function () { return workspace.isLinkActive('camel/source'); }
                },
                {
                    id: 'camel-route-properties',
                    title: 'Properties',
                    path: "/camel/propertiesRoute",
                    show: function () { return Camel.isRouteNode(workspace); }
                },
                {
                    id: 'camel-endpoint-properties',
                    title: 'Properties',
                    path: "/camel/propertiesEndpoint",
                    show: function () { return workspace.isEndpoint()
                        && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                        && workspace.hasInvokeRights(workspace.selection, "explainEndpointJson"); }
                },
                {
                    id: 'camel-component-properties',
                    title: 'Properties',
                    path: "/camel/propertiesComponent",
                    show: function () { return workspace.isComponent()
                        && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                        && workspace.hasInvokeRights(workspace.selection, "explainComponentJson"); }
                },
                {
                    id: 'camel-dataformat-properties',
                    title: 'Properties',
                    path: "/camel/propertiesDataFormat",
                    show: function () { return workspace.isDataformat()
                        && Camel.isCamelVersionEQGT(2, 16, workspace, jolokia)
                        && workspace.hasInvokeRights(workspace.selection, "explainDataFormatJson"); }
                },
                {
                    id: 'camel-exchanges',
                    title: 'Exchanges',
                    path: "/camel/exchanges",
                    show: function () { return !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && !workspace.isComponentsFolder() && !workspace.isComponent()
                        && (workspace.isCamelContext() || workspace.isRoutesFolder() || workspace.isRoute())
                        && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelInflightRepository(workspace), "browse"); }
                },
                // {
                //   id: 'camel-blocked-exchanges',
                //   title: 'Blocked',
                //   path: "/camel/blocked",
                //   show: () => !workspace.isEndpointsFolder()
                //     && (workspace.isRoute() || workspace.isRoutesFolder())
                //     && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                //     && workspace.hasInvokeRightsForName(getSelectionCamelBlockedExchanges(workspace), "browse")
                // },
                {
                    id: 'camel-route-metrics',
                    title: 'Route Metrics',
                    path: "/camel/routeMetrics",
                    show: function () { return !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && (workspace.isCamelContext() || workspace.isRoutesFolder())
                        && Camel.isCamelVersionEQGT(2, 14, workspace, jolokia)
                        && Camel.getSelectionCamelRouteMetrics(workspace)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelRouteMetrics(workspace), "dumpStatisticsAsJson"); }
                },
                {
                    id: 'camel-rest-services',
                    title: 'REST Services',
                    path: "/camel/restServices",
                    show: function () { return !Camel.getSelectedRouteNode(workspace)
                        && !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && !workspace.isComponentsFolder() && !workspace.isComponent()
                        && (workspace.isCamelContext() || workspace.isRoutesFolder())
                        && Camel.isCamelVersionEQGT(2, 14, workspace, jolokia)
                        && Camel.getSelectionCamelRestRegistry(workspace)
                        && hasRestServices(workspace, jolokia)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelRestRegistry(workspace), "listRestServices"); }
                },
                {
                    id: 'camel-endpoint-runtime-registry',
                    title: 'Endpoints (in/out)',
                    path: "/camel/endpointRuntimeRegistry",
                    show: function () { return !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && !workspace.isComponentsFolder() && !workspace.isComponent()
                        && (workspace.isCamelContext() || workspace.isRoutesFolder())
                        && Camel.isCamelVersionEQGT(2, 16, workspace, jolokia)
                        && Camel.getSelectionCamelEndpointRuntimeRegistry(workspace)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelEndpointRuntimeRegistry(workspace), "endpointStatistics"); }
                },
                {
                    id: 'camel-type-converters',
                    title: 'Type Converters',
                    path: "/camel/typeConverter",
                    show: function () { return !Camel.getSelectedRouteNode(workspace)
                        && !workspace.isEndpointsFolder() && !workspace.isEndpoint()
                        && !workspace.isComponentsFolder() && !workspace.isComponent()
                        && (workspace.isCamelContext() || workspace.isRoutesFolder())
                        && Camel.isCamelVersionEQGT(2, 13, workspace, jolokia)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTypeConverter(workspace), "listTypeConverters"); }
                },
                {
                    id: 'camel-route-profile',
                    title: 'Profile',
                    path: "/camel/profileRoute",
                    show: function () { return workspace.isRoute()
                        && Camel.getSelectionCamelTraceMBean(workspace)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTraceMBean(workspace), "dumpAllTracedMessagesAsXml"); }
                },
                {
                    id: 'camel-route-debug',
                    title: 'Debug',
                    path: "/camel/debugRoute",
                    show: function () { return workspace.isRoute()
                        && Camel.getSelectionCamelDebugMBean(workspace)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelDebugMBean(workspace), "getBreakpoints"); }
                },
                {
                    id: 'camel-route-trace',
                    title: 'Trace',
                    path: "/camel/traceRoute",
                    show: function () { return workspace.isRoute()
                        && Camel.getSelectionCamelTraceMBean(workspace)
                        && workspace.hasInvokeRightsForName(Camel.getSelectionCamelTraceMBean(workspace), "dumpAllTracedMessagesAsXml"); }
                },
                {
                    id: 'camel-endpoint-browser',
                    title: 'Browse',
                    path: "/camel/browseEndpoint",
                    show: function () { return workspace.isEndpoint()
                        && workspace.hasInvokeRights(workspace.selection, "browseAllMessagesAsXml"); }
                },
                {
                    id: 'camel-endpoint-send',
                    title: 'Send',
                    path: "/camel/sendMessage",
                    show: function () { return workspace.isEndpoint()
                        && workspace.hasInvokeRights(workspace.selection, workspace.selection.domain === "org.apache.camel" ? "sendBodyAndHeaders" : "sendTextMessage"); }
                },
                {
                    id: 'camel-endpoint-create',
                    title: 'Endpoint',
                    path: "/camel/createEndpoint",
                    show: function () { return workspace.isEndpointsFolder()
                        && workspace.hasInvokeRights(workspace.selection, "createEndpoint"); }
                },
                {
                    id: 'jmx-operations',
                    title: 'Operations',
                    path: "/jmx/operations",
                    show: function () { return !isContextsFolder(workspace) && !workspace.isRoutesFolder(); }
                },
                {
                    id: 'jmx-charts',
                    title: 'Chart',
                    path: "/jmx/charts",
                    show: function () { return !isContextsFolder(workspace) && !workspace.isRoutesFolder(); }
                }
            ];
            $scope.isActive = function (tab) { return workspace.isLinkActive(tab.path); };
            $scope.goto = function (path) { return $location.path(path); };
        }]);
    function isContextsFolder(workspace) {
        return workspace.selection && workspace.selection.key === 'camelContexts';
    }
    var _hasRestServices = null;
    function hasRestServices(workspace, jolokia) {
        if (_hasRestServices === null) {
            _hasRestServices = Camel.hasRestServices(workspace, jolokia);
        }
        return _hasRestServices;
    }
})(Camel || (Camel = {}));
/// <reference path="../../activemq/ts/activemqHelpers.ts"/>
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TraceRouteController", ["$scope", "$timeout", "workspace", "jolokia", "localStorage", "tracerStatus",
        function ($scope, $timeout, workspace, jolokia, localStorage, tracerStatus) {
            var log = Logger.get("CamelTracer");
            var MESSAGES_LIMIT = 500;
            $scope.tracing = false;
            $scope.messages = [];
            $scope.message = null;
            $scope.messageIndex = -1;
            $scope.graphView = "plugins/camel/html/routeDiagram.html";
            $scope.gridOptions = Camel.createBrowseGridOptions();
            $scope.gridOptions.selectWithCheckboxOnly = false;
            $scope.gridOptions.showSelectionCheckbox = false;
            $scope.gridOptions.multiSelect = false;
            $scope.gridOptions.afterSelectionChange = onSelectionChanged;
            $scope.gridOptions.columnDefs.push({
                field: 'toNode',
                displayName: 'To Node'
            });
            $scope.startTracing = function () {
                log.info("Start tracing");
                setTracing(true);
            };
            $scope.stopTracing = function () {
                log.info("Stop tracing");
                setTracing(false);
            };
            $scope.clear = function () {
                log.debug("Clear messages");
                tracerStatus.messages = [];
                $scope.messages = [];
                if ($scope.message) {
                    $scope.messageDialog.close();
                }
                Core.$apply($scope);
            };
            // TODO can we share these 2 methods from activemq browse / camel browse / came trace?
            $scope.openMessageDialog = function (message, index) {
                $scope.message = message;
                $scope.messageIndex = index;
                highlightToNode(message.toNode);
            };
            $scope.closeMessageDetails = function () {
                $scope.message = null;
                $scope.messageIndex = -1;
                highlightToNode(null);
            };
            function highlightToNode(toNode) {
                var nodes = d3.select("svg").selectAll("g .node");
                Camel.highlightSelectedNode(nodes, toNode);
            }
            $scope.changeMessage = function (index) {
                if (index >= 0 && index <= $scope.messages.length - 1 && index !== $scope.messageIndex) {
                    $scope.messageIndex = index;
                    $scope.message = $scope.messages[$scope.messageIndex];
                    highlightToNode($scope.message.toNode);
                }
            };
            ActiveMQ.decorate($scope, onSelectionChanged);
            function reloadTracingFlag() {
                $scope.tracing = false;
                // clear any previous polls
                if (tracerStatus.jhandle != null) {
                    log.debug("Unregistering jolokia handle");
                    jolokia.unregister(tracerStatus.jhandle);
                    tracerStatus.jhandle = null;
                }
                var mbean = Camel.getSelectionCamelTraceMBean(workspace);
                if (mbean) {
                    $scope.tracing = jolokia.getAttribute(mbean, "Enabled", Core.onSuccess(null));
                    if ($scope.tracing) {
                        var traceMBean = mbean;
                        if (traceMBean) {
                            // register callback for doing live update of tracing
                            if (tracerStatus.jhandle === null) {
                                log.debug("Registering jolokia handle");
                                tracerStatus.jhandle = jolokia.register(populateRouteMessages, {
                                    type: 'exec', mbean: traceMBean,
                                    operation: 'dumpAllTracedMessagesAsXml()',
                                    ignoreErrors: true,
                                    arguments: []
                                });
                            }
                        }
                    }
                    else {
                        tracerStatus.messages = [];
                        $scope.messages = [];
                    }
                }
            }
            function populateRouteMessages(response) {
                log.debug("Populating response " + response);
                // filter messages due CAMEL-7045 but in camel-core
                // see https://github.com/hawtio/hawtio/issues/292
                var selectedRouteId = Camel.getSelectedRouteId(workspace);
                var xml = response.value;
                if (angular.isString(xml)) {
                    // lets parse the XML DOM here...
                    var doc = $.parseXML(xml);
                    var allMessages = $(doc).find("fabricTracerEventMessage");
                    if (!allMessages || !allMessages.length) {
                        // lets try find another element name
                        allMessages = $(doc).find("backlogTracerEventMessage");
                    }
                    var tableScrolled = isTableScrolled();
                    allMessages.each(function (idx, message) {
                        var routeId = $(message).find("routeId").text();
                        if (routeId === selectedRouteId) {
                            var messageData = Camel.createMessageFromXml(message);
                            var toNode = $(message).find("toNode").text();
                            if (toNode) {
                                messageData["toNode"] = toNode;
                            }
                            log.debug("Adding new message to trace table with id " + messageData["id"]);
                            $scope.messages.push(messageData);
                        }
                    });
                    limitMessagesArray();
                    // keep state of the traced messages on tracerStatus
                    tracerStatus.messages = $scope.messages;
                    if (tableScrolled) {
                        scrollTable();
                    }
                    Core.$apply($scope);
                }
            }
            function limitMessagesArray() {
                // remove messages when the array reaches its limit and the user isn't looking at a message details
                if ($scope.messages.length > MESSAGES_LIMIT && $scope.message === null) {
                    $scope.messages.splice(0, $scope.messages.length - MESSAGES_LIMIT);
                }
            }
            function isTableScrolled() {
                var scrollableTable = document.querySelector('.camel-trace-messages-table-body-container');
                return scrollableTable.scrollHeight - scrollableTable.scrollTop === scrollableTable.clientHeight;
            }
            function scrollTable() {
                var scrollableTable = document.querySelector('.camel-trace-messages-table-body-container');
                $timeout(function () { return scrollableTable.scrollTop = scrollableTable.scrollHeight - scrollableTable.clientHeight; }, 0);
            }
            function onSelectionChanged() {
                angular.forEach($scope.gridOptions.selectedItems, function (selected) {
                    if (selected) {
                        var toNode = selected["toNode"];
                        if (toNode) {
                            // lets highlight the node in the diagram
                            var nodes = d3.select("svg").selectAll("g .node");
                            Camel.highlightSelectedNode(nodes, toNode);
                        }
                    }
                });
            }
            function tracingChanged(response) {
                reloadTracingFlag();
                Core.$apply($scope);
            }
            function setTracing(flag) {
                var mbean = Camel.getSelectionCamelTraceMBean(workspace);
                if (mbean) {
                    // set max only supported on BacklogTracer
                    // (the old fabric tracer does not support max length)
                    if (_.endsWith(mbean.toString(), "BacklogTracer")) {
                        var max = Camel.maximumTraceOrDebugBodyLength(localStorage);
                        var streams = Camel.traceOrDebugIncludeStreams(localStorage);
                        jolokia.setAttribute(mbean, "BodyMaxChars", max);
                        jolokia.setAttribute(mbean, "BodyIncludeStreams", streams);
                        jolokia.setAttribute(mbean, "BodyIncludeFiles", streams);
                    }
                    jolokia.setAttribute(mbean, "Enabled", flag, Core.onSuccess(tracingChanged));
                }
            }
            log.info("Re-activating tracer with " + tracerStatus.messages.length + " existing messages");
            $scope.messages = tracerStatus.messages;
            $scope.tracing = tracerStatus.jhandle != null;
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TreeHeaderController", ["$scope", "$location", function ($scope, $location) {
            // TODO: the tree should ideally be initialised synchronously
            var tree = function () { return $('#cameltree').treeview(true); };
            $scope.expandAll = function () { return tree().expandNode(tree().getNodes(), { levels: 1, silent: true }); };
            $scope.contractAll = function () { return tree().collapseNode(tree().getNodes(), { ignoreChildren: true, silent: true }); };
            var search = _.debounce(function (filter) {
                var result = tree().search(filter, {
                    ignoreCase: true,
                    exactMatch: false,
                    revealResults: true
                });
                $scope.result.length = 0;
                (_a = $scope.result).push.apply(_a, result);
                Core.$apply($scope);
                var _a;
            }, 300, { leading: false, trailing: true });
            $scope.filter = '';
            $scope.result = [];
            $scope.$watch('filter', function (filter, previous) {
                if (filter !== previous) {
                    search(filter);
                }
            });
        }]);
    Camel._module.controller("Camel.TreeController", ["$scope", "$location", "$timeout", "workspace", 'jolokia',
        function ($scope, $location, $timeout, workspace, jolokia) {
            $scope.treeFetched = function () { return workspace.treeFetched; };
            $scope.$on('$routeChangeStart', function () { return Jmx.updateTreeSelectionFromURL($location, $('#cameltree')); });
            $scope.$watch('workspace.tree', function () {
                reloadFunction();
            });
            $scope.$on('jmxTreeUpdated', function () {
                reloadFunction();
            });
            $scope.$on('jmxTreeClicked', function (event, selection) { return navigateToDefaultTab(selection); });
            // TODO: the logic should ideally be factorized with that of the visible tabs
            function navigateToDefaultTab(selection) {
                var path = '/jmx/attributes';
                if (workspace.isRoutesFolder()) {
                    path = '/camel/routes';
                }
                else if (workspace.isRoute()) {
                    if (workspace.hasInvokeRightsForName(Camel.getSelectionCamelContextMBean(workspace), 'dumpRoutesAsXml')) {
                        path = '/camel/routeDiagram';
                    }
                    else {
                        path = '/jmx/attributes';
                    }
                }
                else if (workspace.selection && workspace.selection.key === 'camelContexts') {
                    path = '/camel/contexts';
                }
                else if (Camel.isRouteNode(workspace)) {
                    path = 'camel/propertiesRoute';
                }
                else if (workspace.isComponent()
                    && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                    && workspace.hasInvokeRights(workspace.selection, 'explainComponentJson')) {
                    path = '/camel/propertiesComponent';
                }
                else if (workspace.isEndpoint()
                    && Camel.isCamelVersionEQGT(2, 15, workspace, jolokia)
                    && workspace.hasInvokeRights(workspace.selection, 'explainEndpointJson')) {
                    path = '/camel/propertiesEndpoint';
                }
                else if (workspace.isDataformat()
                    && Camel.isCamelVersionEQGT(2, 16, workspace, jolokia)
                    && workspace.hasInvokeRights(workspace.selection, "explainDataFormatJson")) {
                    path = '/camel/propertiesDataFormat';
                }
                $location.path(path);
            }
            function reloadFunction() {
                var tree = workspace.tree;
                if (tree) {
                    var rootFolder = tree.findDescendant(function (node) { return node.key === 'camelContexts'; });
                    if (rootFolder) {
                        var treeElement = $('#cameltree');
                        Jmx.enableTree($scope, $location, workspace, treeElement, [rootFolder]);
                        updateSelectionFromURL();
                    }
                }
            }
            function updateSelectionFromURL() {
                Jmx.updateTreeSelectionFromURLAndAutoSelect($location, $('#cameltree'), function (first) {
                    // use function to auto select first Camel context routes if there is only one Camel context
                    var contexts = first.children;
                    if (contexts && contexts.length === 1) {
                        var first_1 = contexts[0];
                        var children = first_1.children;
                        if (children && children.length) {
                            var routes = children[0];
                            if (routes.typeName === 'routes') {
                                return routes;
                            }
                        }
                    }
                    return null;
                }, true);
            }
            $scope.$on('$destroy', function () {
                var tree = $('#cameltree').treeview(true);
                tree.clearSearch();
                // Bootstrap tree view leaks the node elements into the data structure
                // so let's clean this up when the user leaves the view
                var cleanTreeFolder = function (node) {
                    delete node['$el'];
                    if (node.nodes)
                        node.nodes.forEach(cleanTreeFolder);
                };
                cleanTreeFolder(workspace.tree);
                // Then call the tree clean-up method
                tree.remove();
            });
            if (workspace.selection) {
                navigateToDefaultTab(workspace.selection);
            }
        }]);
})(Camel || (Camel = {}));
/// <reference path="camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.TypeConverterController", ["$scope", "$location", "$timeout", "workspace", "jolokia", function ($scope, $location, $timeout, workspace, jolokia) {
            $scope.data = [];
            $scope.selectedMBean = null;
            $scope.enableTypeConvertersStats = false;
            $scope.disableTypeConvertersStats = false;
            $scope.defaultTimeout = 5000;
            $scope.mbeanAttributes = {};
            var columnDefs = [
                {
                    field: 'from',
                    displayName: 'From',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'to',
                    displayName: 'To',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                }
            ];
            $scope.gridOptions = {
                data: 'data',
                displayFooter: true,
                displaySelectionCheckbox: false,
                canSelectRows: false,
                enableSorting: true,
                columnDefs: columnDefs,
                selectedItems: [],
                filterOptions: {
                    filterText: ''
                },
                primaryKeyFn: function (entity) { return entity.from + '/' + entity.to; }
            };
            function onAttributes(response) {
                var obj = response.value;
                if (obj) {
                    $scope.mbeanAttributes = obj;
                    // ensure web page is updated
                    Core.$apply($scope);
                }
            }
            function onConverters(response) {
                var obj = response.value;
                if (obj) {
                    // the JMX tabular data has 2 indexes so we need to dive 2 levels down to grab the data
                    var arr = [];
                    for (var key in obj) {
                        var values = obj[key];
                        for (var v in values) {
                            arr.push({ from: key, to: v });
                        }
                    }
                    arr = _.sortBy(arr, "from");
                    $scope.data = arr;
                    // okay we have the data then set the selected mbean which allows UI to display data
                    $scope.selectedMBean = response.request.mbean;
                    // ensure web page is updated
                    Core.$apply($scope);
                }
            }
            $scope.renderIcon = function (state) {
                return Camel.iconClass(state);
            };
            $scope.disableStatistics = function () {
                $scope.disableTypeConvertersStats = true;
                if ($scope.selectedMBean) {
                    jolokia.setAttribute($scope.selectedMBean, "StatisticsEnabled", false);
                }
                $timeout(function () { $scope.disableTypeConvertersStats = false; }, $scope.defaultTimeout);
            };
            $scope.enableStatistics = function () {
                $scope.enableTypeConvertersStats = true;
                if ($scope.selectedMBean) {
                    jolokia.setAttribute($scope.selectedMBean, "StatisticsEnabled", true);
                }
                $timeout(function () { $scope.enableTypeConvertersStats = false; }, $scope.defaultTimeout);
            };
            $scope.resetStatistics = function () {
                if ($scope.selectedMBean) {
                    jolokia.request({ type: 'exec', mbean: $scope.selectedMBean, operation: 'resetTypeConversionCounters' }, Core.onSuccess(null, { silent: true }));
                }
            };
            function loadConverters() {
                console.log("Loading TypeConverter data...");
                var mbean = Camel.getSelectionCamelTypeConverter(workspace);
                if (mbean) {
                    // grab attributes in real time
                    var query = {
                        type: "read",
                        mbean: mbean,
                        attribute: ["AttemptCounter", "FailedCounter", "HitCounter", "MissCounter", "NumberOfTypeConverters", "StatisticsEnabled"]
                    };
                    jolokia.request(query, Core.onSuccess(onAttributes));
                    Core.scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onAttributes, query));
                    // and list of converters
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'listTypeConverters' }, Core.onSuccess(onConverters));
                }
            }
            // load converters
            loadConverters();
        }]);
})(Camel || (Camel = {}));
var Karaf;
(function (Karaf) {
    Karaf.log = Logger.get("Karaf");
    function setSelect(selection, group) {
        if (!angular.isDefined(selection)) {
            return group[0];
        }
        var answer = _.findIndex(group, function (item) { return item.id === selection.id; });
        if (answer !== -1) {
            return group[answer];
        }
        else {
            return group[0];
        }
    }
    Karaf.setSelect = setSelect;
    function installRepository(workspace, jolokia, uri, success, error) {
        Karaf.log.info("installing URI: ", uri);
        jolokia.request({
            type: 'exec', mbean: getSelectionFeaturesMBean(workspace),
            operation: 'addRepository(java.lang.String)',
            arguments: [uri]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.installRepository = installRepository;
    function uninstallRepository(workspace, jolokia, uri, success, error) {
        Karaf.log.info("uninstalling URI: ", uri);
        jolokia.request({
            type: 'exec', mbean: getSelectionFeaturesMBean(workspace),
            operation: 'removeRepository(java.lang.String)',
            arguments: [uri]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.uninstallRepository = uninstallRepository;
    function installFeature(workspace, jolokia, feature, version, success, error) {
        jolokia.request({
            type: 'exec', mbean: getSelectionFeaturesMBean(workspace),
            operation: 'installFeature(java.lang.String, java.lang.String)',
            arguments: [feature, version]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.installFeature = installFeature;
    function uninstallFeature(workspace, jolokia, feature, version, success, error) {
        jolokia.request({
            type: 'exec', mbean: getSelectionFeaturesMBean(workspace),
            operation: 'uninstallFeature(java.lang.String, java.lang.String)',
            arguments: [feature, version]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.uninstallFeature = uninstallFeature;
    // TODO move to core?
    function toCollection(values) {
        var collection = values;
        if (!angular.isArray(values)) {
            collection = [values];
        }
        return collection;
    }
    Karaf.toCollection = toCollection;
    function featureLinks(workspace, name, version) {
        return "<a href='" + Core.url("#/karaf/feature/" + name + "/" + version + workspace.hash()) + "'>" + version + "</a>";
    }
    Karaf.featureLinks = featureLinks;
    function extractFeature(attributes, name, version) {
        var features = [];
        var repos = [];
        populateFeaturesAndRepos(attributes, features, repos);
        return _.find(features, function (feature) { return feature.Name == name && feature.Version == version; });
    }
    Karaf.extractFeature = extractFeature;
    var platformBundlePatterns = [
        "^org.apache.aries",
        "^org.apache.karaf",
        "^activemq-karaf",
        "^org.apache.commons",
        "^org.apache.felix",
        "^io.fabric8",
        "^io.fabric8.fab",
        "^io.fabric8.insight",
        "^io.fabric8.mq",
        "^io.fabric8.patch",
        "^io.fabric8.runtime",
        "^io.fabric8.security",
        "^org.apache.geronimo.specs",
        "^org.apache.servicemix.bundles",
        "^org.objectweb.asm",
        "^io.hawt",
        "^javax.mail",
        "^javax",
        "^org.jvnet",
        "^org.mvel2",
        "^org.apache.mina.core",
        "^org.apache.sshd.core",
        "^org.apache.neethi",
        "^org.apache.servicemix.specs",
        "^org.apache.xbean",
        "^org.apache.santuario.xmlsec",
        "^biz.aQute.bndlib",
        "^groovy-all",
        "^com.google.guava",
        "jackson-\\w+-asl",
        "^com.fasterxml.jackson",
        "^org.ops4j",
        "^org.springframework",
        "^bcprov$",
        "^jline$",
        "scala-library$",
        "^org.scala-lang",
        "^stax2-api$",
        "^woodstox-core-asl",
        "^org.jboss.amq.mq-fabric",
        "^gravia-",
        "^joda-time$",
        "^org.apache.ws",
        "-commands$",
        "patch.patch",
        "org.fusesource.insight",
        "activeio-core",
        "activemq-osgi",
        "^org.eclipse.jetty",
        "org.codehaus.jettison.jettison",
        "org.jledit.core",
        "org.fusesource.jansi",
        "org.eclipse.equinox.region"
    ];
    var platformBundleRegex = new RegExp(platformBundlePatterns.join('|'));
    var camelBundlePatterns = ["^org.apache.camel", "camel-karaf-commands$", "activemq-camel$"];
    var camelBundleRegex = new RegExp(camelBundlePatterns.join('|'));
    var cxfBundlePatterns = ["^org.apache.cxf"];
    var cxfBundleRegex = new RegExp(cxfBundlePatterns.join('|'));
    var activemqBundlePatterns = ["^org.apache.activemq", "activemq-camel$"];
    var activemqBundleRegex = new RegExp(activemqBundlePatterns.join('|'));
    function isPlatformBundle(symbolicName) {
        return platformBundleRegex.test(symbolicName);
    }
    Karaf.isPlatformBundle = isPlatformBundle;
    function isActiveMQBundle(symbolicName) {
        return activemqBundleRegex.test(symbolicName);
    }
    Karaf.isActiveMQBundle = isActiveMQBundle;
    function isCamelBundle(symbolicName) {
        return camelBundleRegex.test(symbolicName);
    }
    Karaf.isCamelBundle = isCamelBundle;
    function isCxfBundle(symbolicName) {
        return cxfBundleRegex.test(symbolicName);
    }
    Karaf.isCxfBundle = isCxfBundle;
    function populateFeaturesAndRepos(attributes, features, repositories) {
        var fullFeatures = attributes["Features"];
        angular.forEach(attributes["Repositories"], function (repo) {
            repositories.push({
                id: repo["Name"],
                uri: repo["Uri"]
            });
            if (!fullFeatures) {
                return;
            }
            angular.forEach(repo["Features"], function (feature) {
                angular.forEach(feature, function (entry) {
                    if (fullFeatures[entry['Name']] !== undefined) {
                        var f = _.cloneDeep(fullFeatures[entry['Name']][entry['Version']]);
                        f["Id"] = entry["Name"] + "/" + entry["Version"];
                        f["RepositoryName"] = repo["Name"];
                        f["RepositoryURI"] = repo["Uri"];
                        features.push(f);
                    }
                });
            });
        });
    }
    Karaf.populateFeaturesAndRepos = populateFeaturesAndRepos;
    function createScrComponentsView(workspace, jolokia, components) {
        var result = [];
        angular.forEach(components, function (component) {
            result.push({
                Name: component,
                State: getComponentStateDescription(getComponentState(workspace, jolokia, component))
            });
        });
        return result;
    }
    Karaf.createScrComponentsView = createScrComponentsView;
    function getComponentStateDescription(state) {
        switch (state) {
            case 2:
                return "Enabled";
            case 4:
                return "Unsatisfied";
            case 8:
                return "Activating";
            case 16:
                return "Active";
            case 32:
                return "Registered";
            case 64:
                return "Factory";
            case 128:
                return "Deactivating";
            case 256:
                return "Destroying";
            case 1024:
                return "Disabling";
            case 2048:
                return "Disposing";
        }
        return "Unknown";
    }
    Karaf.getComponentStateDescription = getComponentStateDescription;
    ;
    function getAllComponents(workspace, jolokia) {
        var scrMBean = getSelectionScrMBean(workspace);
        var response = jolokia.request({
            type: 'read', mbean: scrMBean,
            arguments: []
        });
        //Check if the MBean provides the Components attribute.
        if (!('Components' in response.value)) {
            response = jolokia.request({
                type: 'exec', mbean: scrMBean, operation: 'listComponents()'
            });
            return createScrComponentsView(workspace, jolokia, response.value);
        }
        return response.value['Components'].values;
    }
    Karaf.getAllComponents = getAllComponents;
    function getComponentByName(workspace, jolokia, componentName) {
        var components = getAllComponents(workspace, jolokia);
        return _.find(components, function (c) { return c.Name == componentName; });
    }
    Karaf.getComponentByName = getComponentByName;
    function isComponentActive(workspace, jolokia, component) {
        var response = jolokia.request({
            type: 'exec', mbean: getSelectionScrMBean(workspace),
            operation: 'isComponentActive(java.lang.String)',
            arguments: [component]
        });
        return response.value;
    }
    Karaf.isComponentActive = isComponentActive;
    function getComponentState(workspace, jolokia, component) {
        var response = jolokia.request({
            type: 'exec', mbean: getSelectionScrMBean(workspace),
            operation: 'componentState(java.lang.String)',
            arguments: [component]
        });
        return response.value;
    }
    Karaf.getComponentState = getComponentState;
    function activateComponent(workspace, jolokia, component, success, error) {
        jolokia.request({
            type: 'exec', mbean: getSelectionScrMBean(workspace),
            operation: 'activateComponent(java.lang.String)',
            arguments: [component]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.activateComponent = activateComponent;
    function deactivateComponent(workspace, jolokia, component, success, error) {
        jolokia.request({
            type: 'exec', mbean: getSelectionScrMBean(workspace),
            operation: 'deactivateComponent(java.lang.String)',
            arguments: [component]
        }, Core.onSuccess(success, { error: error }));
    }
    Karaf.deactivateComponent = deactivateComponent;
    function populateDependencies(attributes, dependencies, features) {
        angular.forEach(dependencies, function (feature) {
            angular.forEach(feature, function (entry) {
                var enhancedFeature = extractFeature(attributes, entry["Name"], entry["Version"]);
                enhancedFeature["id"] = entry["Name"] + "/" + entry["Version"];
                //enhancedFeature["repository"] = repo["Name"];
                features.push(enhancedFeature);
            });
        });
    }
    Karaf.populateDependencies = populateDependencies;
    function getSelectionFeaturesMBean(workspace) {
        if (workspace) {
            var featuresStuff = workspace.mbeanTypesToDomain["features"] || workspace.mbeanTypesToDomain['feature'] || {};
            var karaf = featuresStuff["org.apache.karaf"] || {};
            var mbean = karaf.objectName;
            if (mbean) {
                return mbean;
            }
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("org.apache.karaf", "features");
            if (!folder) {
                // sometimes the features mbean is inside the 'root' folder
                folder = workspace.tree.navigate("org.apache.karaf");
                if (folder) {
                    var children = folder.children;
                    folder = null;
                    angular.forEach(children, function (child) {
                        if (!folder) {
                            folder = child.navigate("features");
                        }
                    });
                }
            }
            if (folder) {
                var children = folder.children;
                if (children) {
                    var node = children[0];
                    if (node) {
                        return node.objectName;
                    }
                }
                return folder.objectName;
            }
        }
        return null;
    }
    Karaf.getSelectionFeaturesMBean = getSelectionFeaturesMBean;
    function getSelectionScrMBean(workspace) {
        if (workspace) {
            var scrStuff = workspace.mbeanTypesToDomain["scr"] || {};
            var karaf = scrStuff["org.apache.karaf"] || {};
            var mbean = karaf.objectName;
            if (mbean) {
                return mbean;
            }
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("org.apache.karaf", "scr");
            if (!folder) {
                // sometimes the features mbean is inside the 'root' folder
                folder = workspace.tree.navigate("org.apache.karaf");
                if (folder) {
                    var children = folder.children;
                    folder = null;
                    angular.forEach(children, function (child) {
                        if (!folder) {
                            folder = child.navigate("scr");
                        }
                    });
                }
            }
            if (folder) {
                var children = folder.children;
                if (children) {
                    var node = children[0];
                    if (node) {
                        return node.objectName;
                    }
                }
                return folder.objectName;
            }
        }
        return null;
    }
    Karaf.getSelectionScrMBean = getSelectionScrMBean;
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    var Feature = /** @class */ (function () {
        function Feature(name, version, installed, repositoryName, repositoryUri) {
            this.id = name + "/" + version;
            this.name = name;
            this.version = version;
            this.installed = installed;
            this.repositoryName = repositoryName;
            this.repositoryUri = repositoryUri;
        }
        Feature.prototype.getState = function () {
            return this.installed ? 'installed' : 'uninstalled';
        };
        return Feature;
    }());
    Karaf.Feature = Feature;
})(Karaf || (Karaf = {}));
var Karaf;
(function (Karaf) {
    var FeatureRepository = /** @class */ (function () {
        function FeatureRepository(name, uri) {
            this.name = name;
            this.uri = uri;
            this.features = [];
            this.dependencies = [];
        }
        return FeatureRepository;
    }());
    Karaf.FeatureRepository = FeatureRepository;
})(Karaf || (Karaf = {}));
/// <reference path="feature.ts"/>
/// <reference path="feature-repository.ts"/>
/// <reference path="../karafHelpers.ts"/>
var Karaf;
(function (Karaf) {
    var FeaturesService = /** @class */ (function () {
        FeaturesService.$inject = ["$q", "jolokia", "workspace"];
        function FeaturesService($q, jolokia, workspace) {
            'ngInject';
            this.$q = $q;
            this.jolokia = jolokia;
            this.workspace = workspace;
            this.log = Logger.get("Karaf");
        }
        FeaturesService.prototype.getFeatureRepositories = function () {
            var _this = this;
            return this.execute(Karaf.getSelectionFeaturesMBean(this.workspace), undefined, undefined, 'read')
                .then(function (value) {
                var repositories = [];
                angular.forEach(value['Repositories'], function (repository) {
                    var featureRepository = new Karaf.FeatureRepository(repository.Name, repository.Uri);
                    featureRepository.dependencies = repository['Repositories'];
                    angular.forEach(repository['Features'], function (item) {
                        angular.forEach(item, function (featureInfo, version) {
                            var feature = new Karaf.Feature(featureInfo.Name, featureInfo.Version, value['Features'][featureInfo.Name][version].Installed, repository.Name, repository.Uri);
                            featureRepository.features.push(feature);
                        });
                    });
                    repositories.push(featureRepository);
                });
                return repositories.sort(function (a, b) {
                    return _this.sortByName(a, b);
                });
            });
        };
        FeaturesService.prototype.installFeature = function (feature) {
            var mbean = Karaf.getSelectionFeaturesMBean(this.workspace);
            var args = [feature.name, feature.version];
            return this.execute(mbean, 'installFeature(java.lang.String, java.lang.String)', args)
                .then(this.handleResponse);
        };
        FeaturesService.prototype.uninstallFeature = function (feature) {
            var mbean = Karaf.getSelectionFeaturesMBean(this.workspace);
            var args = [feature.name, feature.version];
            return this.execute(mbean, 'uninstallFeature(java.lang.String, java.lang.String)', args)
                .then(this.handleResponse);
        };
        FeaturesService.prototype.addFeatureRepository = function (repositoryUri) {
            var mbean = Karaf.getSelectionFeaturesMBean(this.workspace);
            var args = [repositoryUri];
            return this.execute(mbean, 'addRepository(java.lang.String)', args)
                .then(this.handleResponse);
        };
        FeaturesService.prototype.removeFeatureRepository = function (repository) {
            var mbean = Karaf.getSelectionFeaturesMBean(this.workspace);
            var args = [repository.uri];
            return this.execute(mbean, 'removeRepository(java.lang.String)', args)
                .then(this.handleResponse);
        };
        FeaturesService.prototype.execute = function (mbean, operation, args, type) {
            var _this = this;
            if (args === void 0) { args = []; }
            if (type === void 0) { type = "exec"; }
            var request = {
                type: type,
                mbean: mbean,
            };
            if (operation) {
                request['operation'] = operation;
            }
            if (args) {
                request['arguments'] = args;
            }
            return this.$q(function (resolve, reject) {
                _this.jolokia.request(request, {
                    method: "post",
                    success: function (response) { return resolve(response.value); },
                    error: function (response) {
                        reject(response.error);
                    }
                });
            });
        };
        FeaturesService.prototype.handleResponse = function (response) {
            if (response && response['Error']) {
                throw response['Error'];
            }
            else {
                return "The operation completed successfully";
            }
        };
        FeaturesService.prototype.sortByName = function (a, b) {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        };
        return FeaturesService;
    }());
    Karaf.FeaturesService = FeaturesService;
})(Karaf || (Karaf = {}));
/// <reference path="feature.ts"/>
/// <reference path="features.service.ts"/>
var Karaf;
(function (Karaf) {
    var FeaturesController = /** @class */ (function () {
        FeaturesController.$inject = ["featuresService", "$uibModal", "$scope"];
        function FeaturesController(featuresService, $uibModal, $scope) {
            'ngInject';
            var _this = this;
            this.featuresService = featuresService;
            this.$uibModal = $uibModal;
            this.$scope = $scope;
            this.features = [];
            this.repositoryFilterValues = [];
            this.listConfig = {
                showSelectBox: false,
                useExpandingRows: false
            };
            this.loading = true;
            this.listItems = null;
            this.listItemActionButtons = [
                {
                    name: 'Install',
                    actionFn: function (action, item) {
                        action.selectedId = item.id;
                        _this.featuresService.installFeature(item)
                            .then(function (response) {
                            Core.notification('success', response);
                            _this.loadFeatureRepositories();
                            action.selectedId = null;
                        })
                            .catch(function (error) {
                            Core.notification('danger', error);
                            action.selectedId = null;
                        });
                    },
                    selectedId: null
                },
                {
                    name: 'Uninstall',
                    actionFn: function (action, item) {
                        action.selectedId = item.id;
                        _this.featuresService.uninstallFeature(item)
                            .then(function (response) {
                            Core.notification('success', response);
                            _this.loadFeatureRepositories();
                            action.selectedId = null;
                        })
                            .catch(function (error) {
                            Core.notification('danger', error);
                            action.selectedId = null;
                        });
                    },
                    selectedId: null
                }
            ];
            this.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'name',
                            title: 'Name',
                            placeholder: 'Filter by name...',
                            filterType: 'text'
                        },
                        {
                            id: 'state',
                            title: 'State',
                            placeholder: 'Filter by state...',
                            filterType: 'select',
                            filterValues: [
                                'Installed',
                                'Uninstalled'
                            ]
                        },
                        {
                            id: 'repository',
                            title: 'Repository',
                            placeholder: 'Filter by repository...',
                            filterType: 'select'
                        }
                    ],
                    onFilterChange: function (filters) {
                        _this.applyFilters(filters);
                    },
                    appliedFilters: [],
                    resultsCount: 0
                },
                actionsConfig: {
                    primaryActions: [
                        {
                            name: 'Add repository',
                            actionFn: function (action) {
                                _this.$uibModal.open({
                                    templateUrl: 'addRepositoryDialog.html',
                                    scope: _this.$scope
                                })
                                    .result
                                    .then(function () {
                                    if (_this.repositoryUri) {
                                        _this.featuresService.addFeatureRepository(_this.repositoryUri)
                                            .then(function (response) {
                                            Core.notification('success', response);
                                            _this.loadFeatureRepositories();
                                        })
                                            .catch(function (error) { return Core.notification('danger', error); });
                                    }
                                    _this.repositoryUri = null;
                                });
                            }
                        },
                        {
                            name: 'Remove repository',
                            actionFn: function (action) {
                                _this.$uibModal.open({
                                    templateUrl: 'removeRepositoryDialog.html',
                                    scope: _this.$scope
                                })
                                    .result
                                    .then(function () {
                                    if (_this.selectedRepository) {
                                        var dependentRepositories_1 = [];
                                        angular.forEach(_this.repositories, function (repository) {
                                            if (repository.name !== _this.selectedRepository.name) {
                                                angular.forEach(repository.dependencies, function (dependency) {
                                                    if (dependency === _this.selectedRepository.uri) {
                                                        dependentRepositories_1.push(repository.name);
                                                    }
                                                });
                                            }
                                        });
                                        if (dependentRepositories_1.length > 0) {
                                            Core.notification('danger', "Unable to remove repository " + _this.selectedRepository.name + ". It is required by " + dependentRepositories_1 + ".");
                                            return;
                                        }
                                        _this.featuresService.removeFeatureRepository(_this.selectedRepository)
                                            .then(function (response) {
                                            Core.notification('success', response);
                                            _this.loadFeatureRepositories();
                                        })
                                            .catch(function (error) { return Core.notification('danger', error); });
                                    }
                                    _this.selectedRepository = null;
                                });
                            }
                        }
                    ]
                },
                isTableView: false
            };
        }
        FeaturesController.prototype.$onInit = function () {
            this.loadFeatureRepositories();
        };
        FeaturesController.prototype.loadFeatureRepositories = function () {
            var _this = this;
            this.featuresService.getFeatureRepositories()
                .then(function (featureRepositories) {
                _this.features = [];
                featureRepositories.forEach(function (repository) {
                    _this.features.push.apply(_this.features, repository.features);
                });
                _this.listItems = _this.features.sort(_this.featuresService.sortByName);
                _this.repositories = featureRepositories.sort(_this.featuresService.sortByName);
                _this.repositoryFilterValues = _this.repositories.map(function (repository) {
                    return repository.name;
                });
                _this.toolbarConfig.filterConfig.fields[2]['filterValues'] = _this.repositoryFilterValues;
                if (_this.toolbarConfig.filterConfig.appliedFilters.length > 0) {
                    _this.applyFilters(_this.toolbarConfig.filterConfig.appliedFilters);
                }
                else {
                    _this.toolbarConfig.filterConfig.resultsCount = _this.features.length;
                }
                _this.loading = false;
            });
        };
        FeaturesController.prototype.applyFilters = function (filters) {
            var filteredFeatures = this.features;
            filters.forEach(function (filter) {
                filteredFeatures = FeaturesController.FILTER_FUNCTIONS[filter.id](filteredFeatures, filter.value);
            });
            this.listItems = filteredFeatures;
            this.toolbarConfig.filterConfig.resultsCount = filteredFeatures.length;
        };
        FeaturesController.prototype.enableButtonForItem = function (action, item) {
            if (action.selectedId && action.selectedId === item.id) {
                return false;
            }
            if (action.name === 'Install') {
                return item.installed === false;
            }
            if (action.name === 'Uninstall') {
                return item.installed === true;
            }
        };
        FeaturesController.FILTER_FUNCTIONS = {
            state: function (features, state) { return features.filter(function (feature) { return feature.installed === (state === 'Installed' ? true : false); }); },
            name: function (features, name) {
                var regExp = new RegExp(name, 'i');
                return features.filter(function (feature) { return regExp.test(feature.name); });
            },
            repository: function (features, repositoryName) {
                return features.filter(function (feature) { return feature.repositoryName === repositoryName; });
            }
        };
        return FeaturesController;
    }());
    Karaf.FeaturesController = FeaturesController;
    Karaf.featuresComponent = {
        templateUrl: 'plugins/karaf/html/features.html',
        controller: FeaturesController
    };
})(Karaf || (Karaf = {}));
/// <reference path="features.component.ts"/>
/// <reference path="features.service.ts"/>
var Karaf;
(function (Karaf) {
    Karaf.featuresModule = angular
        .module('hawtio-karaf-features', [])
        .component('features', Karaf.featuresComponent)
        .service('featuresService', Karaf.FeaturesService)
        .name;
})(Karaf || (Karaf = {}));
/// <reference path="scr-component.ts"/>
/// <reference path="../karafHelpers.ts"/>
var Karaf;
(function (Karaf) {
    var ScrComponentsService = /** @class */ (function () {
        ScrComponentsService.$inject = ["$q", "jolokia", "workspace"];
        function ScrComponentsService($q, jolokia, workspace) {
            'ngInject';
            this.$q = $q;
            this.jolokia = jolokia;
            this.workspace = workspace;
            this.log = Logger.get("Karaf");
        }
        ScrComponentsService.prototype.getComponents = function () {
            return this.execute(Karaf.getSelectionScrMBean(this.workspace), undefined, undefined, 'read')
                .then(function (value) {
                var components = [];
                angular.forEach(value['Components'].values, function (item, key) {
                    var component = {
                        id: item.Id,
                        name: item.Name,
                        state: item.State,
                        properties: item.Properties,
                        references: item.References
                    };
                    components.push(component);
                });
                return components;
            });
        };
        ScrComponentsService.prototype.activateComponents = function (components) {
            var _this = this;
            var mbean = Karaf.getSelectionScrMBean(this.workspace);
            var promises = [];
            angular.forEach(components, function (component) {
                promises.push(_this.execute(mbean, 'activateComponent(java.lang.String)', component.name));
            });
            return this.$q.all(promises).then(this.handleResponse);
        };
        ScrComponentsService.prototype.activateComponent = function (component) {
            return this.activateComponents([component]);
        };
        ScrComponentsService.prototype.deactivateComponents = function (components) {
            var _this = this;
            var mbean = Karaf.getSelectionScrMBean(this.workspace);
            var promises = [];
            angular.forEach(components, function (component) {
                promises.push(_this.execute(mbean, 'deactivateComponent(java.lang.String)', component.name));
            });
            return this.$q.all(promises).then(this.handleResponse);
        };
        ScrComponentsService.prototype.deactivateComponent = function (component) {
            return this.deactivateComponents([component]);
        };
        ScrComponentsService.prototype.execute = function (mbean, operation, args, type) {
            var _this = this;
            if (args === void 0) { args = undefined; }
            if (type === void 0) { type = "exec"; }
            var request = {
                type: type,
                mbean: mbean,
            };
            if (operation) {
                request['operation'] = operation;
            }
            if (args) {
                request['arguments'] = [args];
            }
            else {
                request['arguments'] = [];
            }
            return this.$q(function (resolve, reject) {
                _this.jolokia.request(request, {
                    method: "post",
                    success: function (response) { return resolve(response.value); },
                    error: function (response) {
                        _this.log.error("ScrComponentsService.execute() failed. " + response);
                        reject(response.error);
                    }
                });
            });
        };
        ScrComponentsService.prototype.handleResponse = function (response) {
            if (response && response['Error']) {
                throw response['Error'];
            }
            else {
                return "The operation completed successfully";
            }
        };
        return ScrComponentsService;
    }());
    Karaf.ScrComponentsService = ScrComponentsService;
})(Karaf || (Karaf = {}));
/// <reference path="scr-component.ts"/>
/// <reference path="scr-components.service.ts"/>
var Karaf;
(function (Karaf) {
    var ScrComponentsController = /** @class */ (function () {
        ScrComponentsController.$inject = ["scrComponentsService"];
        function ScrComponentsController(scrComponentsService) {
            'ngInject';
            var _this = this;
            this.scrComponentsService = scrComponentsService;
            this.activateAction = {
                name: 'Activate',
                actionFn: function (action) {
                    var selectedComponents = _this.getSelectedComponents();
                    _this.scrComponentsService.activateComponents(selectedComponents)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadComponents();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.deActivateAction = {
                name: 'Deactivate',
                actionFn: function (action) {
                    var selectedComponents = _this.getSelectedComponents();
                    _this.scrComponentsService.deactivateComponents(selectedComponents)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadComponents();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'name',
                            title: 'Name',
                            placeholder: 'Filter by name...',
                            filterType: 'text'
                        },
                        {
                            id: 'state',
                            title: 'State',
                            placeholder: 'Filter by state...',
                            filterType: 'select',
                            filterValues: [
                                'Enabled',
                                'Unsatisfied',
                                'Activating',
                                'Active',
                                'Registered',
                                'Factory',
                                'Deactivating',
                                'Destroying',
                                'Disabling',
                                'Disposing'
                            ]
                        }
                    ],
                    onFilterChange: function (filters) {
                        _this.applyFilters(filters);
                    },
                    resultsCount: 0
                },
                actionsConfig: {
                    primaryActions: [
                        this.activateAction,
                        this.deActivateAction
                    ]
                },
                isTableView: true
            };
            this.tableConfig = {
                selectionMatchProp: 'name',
                onCheckBoxChange: function (item) { return _this.enableDisableActions(); }
            };
            this.tableColumns = [
                { header: 'Name', itemField: 'name', templateFn: function (value) { return "<a href=\"osgi/scr-components/" + value + "\">" + value + "</a>"; } },
                { header: 'State', itemField: 'state' }
            ];
            this.tableItems = null;
            this.loading = true;
        }
        ScrComponentsController.prototype.$onInit = function () {
            this.loadComponents();
        };
        ScrComponentsController.prototype.loadComponents = function () {
            var _this = this;
            this.scrComponentsService.getComponents()
                .then(function (components) {
                _this.components = components;
                _this.tableItems = components;
                _this.toolbarConfig.filterConfig.resultsCount = components.length;
                _this.enableDisableActions();
                _this.loading = false;
            });
        };
        ScrComponentsController.prototype.applyFilters = function (filters) {
            var filteredComponents = this.components;
            filters.forEach(function (filter) {
                filteredComponents = ScrComponentsController.FILTER_FUNCTIONS[filter.id](filteredComponents, filter.value);
            });
            this.tableItems = filteredComponents;
            this.toolbarConfig.filterConfig.resultsCount = filteredComponents.length;
        };
        ScrComponentsController.prototype.enableDisableActions = function () {
            var selectedComponents = this.getSelectedComponents();
            var noComponentsSelected = selectedComponents.length === 0;
            this.activateAction.isDisabled = noComponentsSelected || selectedComponents.every(function (component) { return component.state === 'Active'; });
            this.deActivateAction.isDisabled = noComponentsSelected || selectedComponents.every(function (component) { return component.state !== 'Active'; });
        };
        ScrComponentsController.prototype.getSelectedComponents = function () {
            var _this = this;
            return this.tableItems
                .map(function (tableItem, i) { return angular.extend(_this.components[i], { selected: tableItem['selected'] }); })
                .filter(function (component) { return component.selected; });
        };
        ScrComponentsController.FILTER_FUNCTIONS = {
            state: function (components, state) { return components.filter(function (component) { return component.state === state; }); },
            name: function (components, name) {
                var regExp = new RegExp(name, 'i');
                return components.filter(function (component) { return regExp.test(component.name); });
            }
        };
        return ScrComponentsController;
    }());
    Karaf.ScrComponentsController = ScrComponentsController;
    Karaf.scrListComponent = {
        template: "\n      <div class=\"table-view\">\n        <h1>Declarative Services</h1>\n        <div ng-if=\"!$ctrl.loading\">\n          <pf-toolbar config=\"$ctrl.toolbarConfig\"></pf-toolbar>\n          <pf-table-view config=\"$ctrl.tableConfig\"\n                         colummns=\"$ctrl.tableColumns\"\n                         items=\"$ctrl.tableItems\"></pf-table-view>\n        </div>\n        <div class=\"spinner spinner-lg loading-page\" ng-if=\"$ctrl.loading\"></div>\n      </div>\n    ",
        controller: ScrComponentsController
    };
})(Karaf || (Karaf = {}));
/// <reference path="scr-component.ts"/>
/// <reference path="scr-components.service.ts"/>
var Karaf;
(function (Karaf) {
    var ScrComponentDetailController = /** @class */ (function () {
        ScrComponentDetailController.$inject = ["scrComponentsService", "$routeParams", "workspace"];
        function ScrComponentDetailController(scrComponentsService, $routeParams, workspace) {
            'ngInject';
            this.scrComponentsService = scrComponentsService;
            this.$routeParams = $routeParams;
            this.workspace = workspace;
            this.srcComponentsUrl = Core.url('/osgi/scr-components' + this.workspace.hash());
            this.loading = true;
        }
        ScrComponentDetailController.prototype.$onInit = function () {
            this.loadComponent();
        };
        ScrComponentDetailController.prototype.loadComponent = function () {
            var _this = this;
            this.scrComponentsService.getComponents().then(function (components) {
                _this.component = components.filter(function (component) {
                    return component.name === _this.$routeParams['name'];
                })[0];
                _this.loading = false;
            });
        };
        ScrComponentDetailController.prototype.disableActivate = function () {
            return this.component == undefined || this.component.state === 'Active';
        };
        ScrComponentDetailController.prototype.activateComponent = function () {
            var _this = this;
            this.scrComponentsService.activateComponent(this.component)
                .then(function (response) {
                Core.notification('success', response);
                _this.loadComponent();
            })
                .catch(function (error) { return Core.notification('danger', error); });
        };
        ScrComponentDetailController.prototype.disableDeactivate = function () {
            return this.component == undefined || this.component.state !== 'Active';
        };
        ScrComponentDetailController.prototype.deactivateComponent = function () {
            var _this = this;
            this.scrComponentsService.deactivateComponent(this.component)
                .then(function (response) {
                Core.notification('success', response);
                _this.loadComponent();
            })
                .catch(function (error) { return Core.notification('danger', error); });
        };
        return ScrComponentDetailController;
    }());
    Karaf.ScrComponentDetailController = ScrComponentDetailController;
    Karaf.scrDetailComponent = {
        templateUrl: 'plugins/karaf/html/scr-component.html',
        controller: ScrComponentDetailController
    };
})(Karaf || (Karaf = {}));
/// <reference path="scr-components.component.ts"/>
/// <reference path="scr-component-detail.component.ts"/>
/// <reference path="scr-components.service.ts"/>
var Karaf;
(function (Karaf) {
    Karaf.scrComponentsModule = angular
        .module('hawtio-karaf-scr-components', [])
        .component('scrListComponents', Karaf.scrListComponent)
        .component('scrComponentDetail', Karaf.scrDetailComponent)
        .service('scrComponentsService', Karaf.ScrComponentsService)
        .name;
})(Karaf || (Karaf = {}));
/// <reference path="karafHelpers.ts"/>
/// <reference path="features/features.module.ts"/>
/// <reference path="scr-components/scr-components.module.ts"/>
/// <reference path="scr-components/scr-component-detail.component.ts"/>
var Karaf;
(function (Karaf) {
    var pluginName = 'karaf';
    Karaf._module = angular.module(pluginName, [
        'patternfly',
        'infinite-scroll',
        Karaf.featuresModule,
        Karaf.scrComponentsModule
    ]);
    Karaf._module.config(["$routeProvider", function ($routeProvider) {
            $routeProvider.
                when('/osgi/server', { templateUrl: 'plugins/karaf/html/server.html' }).
                when('/osgi/features', { template: '<features></features>' }).
                when('/osgi/scr-components', { template: '<scr-list-components></scr-list-components>' }).
                when('/osgi/scr-components/:name', { template: '<scr-component-detail></scr-component-detail>' }).
                when('/osgi/feature/:name/:version', { templateUrl: 'plugins/karaf/html/feature.html' });
        }]);
    Karaf._module.run(["workspace", "viewRegistry", "helpRegistry", function (workspace, viewRegistry, helpRegistry) {
            helpRegistry.addUserDoc('karaf', 'plugins/karaf/doc/help.md', function () {
                return workspace.treeContainsDomainAndProperties('org.apache.karaf');
            });
        }]);
    hawtioPluginLoader.addModule(pluginName);
})(Karaf || (Karaf = {}));
/// <reference path="karafPlugin.ts"/>
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.FeatureController", ["$scope", "jolokia", "workspace", "$routeParams", function ($scope, jolokia, workspace, $routeParams) {
            $scope.name = $routeParams['name'];
            $scope.version = $routeParams['version'];
            $scope.bundlesByLocation = {};
            $scope.props = "properties";
            updateTableContents();
            $scope.install = function () {
                Karaf.installFeature(workspace, jolokia, $scope.name, $scope.version, function () {
                    Core.notification('success', 'Installed feature ' + $scope.name);
                }, function (response) {
                    Core.notification('danger', 'Failed to install feature ' + $scope.name + ' due to ' + response.error);
                });
            };
            $scope.uninstall = function () {
                Karaf.uninstallFeature(workspace, jolokia, $scope.name, $scope.version, function () {
                    Core.notification('success', 'Uninstalled feature ' + $scope.name);
                }, function (response) {
                    Core.notification('danger', 'Failed to uninstall feature ' + $scope.name + ' due to ' + response.error);
                });
            };
            $scope.toProperties = function (elements) {
                var answer = '';
                angular.forEach(elements, function (value, name) {
                    answer += value['Key'] + " = " + value['Value'] + "\n";
                });
                return answer.trim();
            };
            function populateTable(response) {
                $scope.row = Karaf.extractFeature(response.value, $scope.name, $scope.version);
                if ($scope.row) {
                    addBundleDetails($scope.row);
                    var dependencies = [];
                    //TODO - if the version isn't set or is 0.0.0 then maybe we show the highest available?
                    angular.forEach($scope.row.Dependencies, function (version, name) {
                        angular.forEach(version, function (data, version) {
                            dependencies.push({
                                Name: name,
                                Version: version
                            });
                        });
                    });
                    $scope.row.Dependencies = dependencies;
                }
                Core.$apply($scope);
            }
            function setBundles(response) {
                var bundleMap = {};
                Osgi.defaultBundleValues(workspace, $scope, response.values);
                angular.forEach(response.value, function (bundle) {
                    var location = bundle["Location"];
                    $scope.bundlesByLocation[location] = bundle;
                });
            }
            function updateTableContents() {
                var featureMbean = Karaf.getSelectionFeaturesMBean(workspace);
                var bundleMbean = Osgi.getSelectionBundleMBean(workspace);
                var jolokia = workspace.jolokia;
                if (bundleMbean) {
                    setBundles(jolokia.request({ type: 'exec', mbean: bundleMbean, operation: 'listBundles()' }));
                }
                if (featureMbean) {
                    jolokia.request({ type: 'read', mbean: featureMbean }, Core.onSuccess(populateTable));
                }
            }
            function addBundleDetails(feature) {
                var bundleDetails = [];
                angular.forEach(feature["Bundles"], function (bundleLocation) {
                    var bundle = $scope.bundlesByLocation[bundleLocation];
                    if (bundle) {
                        bundle["Installed"] = true;
                        bundleDetails.push(bundle);
                    }
                    else {
                        bundleDetails.push({
                            "Location": bundleLocation,
                            "Installed": false
                        });
                    }
                });
                feature["BundleDetails"] = bundleDetails;
            }
        }]);
})(Karaf || (Karaf = {}));
/// <reference path="karafPlugin.ts"/>
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.FeaturesController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.responseJson = '';
            $scope.filter = '';
            $scope.installedFeatures = [];
            $scope.features = [];
            $scope.repositories = [];
            $scope.selectedRepositoryId = '';
            $scope.selectedRepository = {};
            $scope.newRepositoryURI = '';
            $scope.init = function () {
                var selectedRepositoryId = $location.search()['repositoryId'];
                if (selectedRepositoryId) {
                    $scope.selectedRepositoryId = selectedRepositoryId;
                }
                var filter = $location.search()['filter'];
                if (filter) {
                    $scope.filter = filter;
                }
            };
            $scope.init();
            $scope.$watch('selectedRepository', function (newValue, oldValue) {
                //log.debug("selectedRepository: ", $scope.selectedRepository);
                if (newValue !== oldValue) {
                    if (!newValue) {
                        $scope.selectedRepositoryId = '';
                    }
                    else {
                        $scope.selectedRepositoryId = newValue['repository'];
                    }
                    $location.search('repositoryId', $scope.selectedRepositoryId);
                }
            }, true);
            $scope.$watch('filter', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    $location.search('filter', newValue);
                }
            });
            var featuresMBean = Karaf.getSelectionFeaturesMBean(workspace);
            Karaf.log.debug("Features mbean: ", featuresMBean);
            if (featuresMBean) {
                Core.register(jolokia, $scope, {
                    type: 'read', mbean: featuresMBean
                }, Core.onSuccess(render));
            }
            $scope.inSelectedRepository = function (feature) {
                if (!$scope.selectedRepository || !('repository' in $scope.selectedRepository)) {
                    return "";
                }
                if (!feature || !('RepositoryName' in feature)) {
                    return "";
                }
                if (feature['RepositoryName'] === $scope.selectedRepository['repository']) {
                    return "in-selected-repository";
                }
                return "";
            };
            $scope.isValidRepository = function () {
                return Core.isBlank($scope.newRepositoryURI);
            };
            $scope.installRepository = function () {
                var repoURL = $scope.newRepositoryURI;
                Core.notification('info', 'Adding feature repository URL');
                Karaf.installRepository(workspace, jolokia, repoURL, function () {
                    Core.notification('success', 'Added feature repository URL');
                    $scope.selectedRepository = {};
                    $scope.selectedRepositoryId = '';
                    $scope.responseJson = null;
                    $scope.triggerRefresh();
                }, function (response) {
                    Karaf.log.error('Failed to add feature repository URL ', repoURL, ' due to ', response.error);
                    Karaf.log.info('stack trace: ', response.stacktrace);
                    Core.$apply($scope);
                });
            };
            $scope.uninstallRepository = function () {
                var repoURI = $scope.selectedRepository['uri'];
                Core.notification('info', 'Removing feature repository ' + repoURI);
                Karaf.uninstallRepository(workspace, jolokia, repoURI, function () {
                    Core.notification('success', 'Removed feature repository ' + repoURI);
                    $scope.responseJson = null;
                    $scope.selectedRepositoryId = '';
                    $scope.selectedRepository = {};
                    $scope.triggerRefresh();
                }, function (response) {
                    Karaf.log.error('Failed to remove feature repository ', repoURI, ' due to ', response.error);
                    Karaf.log.info('stack trace: ', response.stacktrace);
                    Core.$apply($scope);
                });
            };
            $scope.triggerRefresh = function () {
                jolokia.request({
                    type: 'read',
                    method: 'POST',
                    mbean: featuresMBean
                }, Core.onSuccess(render));
            };
            $scope.install = function (feature) {
                //$('.popover').remove();
                Core.notification('info', 'Installing feature ' + feature.Name);
                Karaf.installFeature(workspace, jolokia, feature.Name, feature.Version, function () {
                    Core.notification('success', 'Installed feature ' + feature.Name);
                    $scope.installedFeatures.add(feature);
                    $scope.responseJson = null;
                    $scope.triggerRefresh();
                    //Core.$apply($scope);
                }, function (response) {
                    Karaf.log.error('Failed to install feature ', feature.Name, ' due to ', response.error);
                    Karaf.log.info('stack trace: ', response.stacktrace);
                    Core.$apply($scope);
                });
            };
            $scope.uninstall = function (feature) {
                //$('.popover').remove();
                Core.notification('info', 'Uninstalling feature ' + feature.Name);
                Karaf.uninstallFeature(workspace, jolokia, feature.Name, feature.Version, function () {
                    Core.notification('success', 'Uninstalled feature ' + feature.Name);
                    $scope.installedFeatures.remove(feature);
                    $scope.responseJson = null;
                    $scope.triggerRefresh();
                    //Core.$apply($scope);
                }, function (response) {
                    Karaf.log.error('Failed to uninstall feature ', feature.Name, ' due to ', response.error);
                    Karaf.log.info('stack trace: ', response.stacktrace);
                    Core.$apply($scope);
                });
            };
            $scope.filteredRows = ['Bundles', 'Configurations', 'Configuration Files', 'Dependencies'];
            $scope.showRow = function (key, value) {
                if ($scope.filteredRows.indexOf(key) !== -1) {
                    return false;
                }
                if (angular.isArray(value)) {
                    if (value.length === 0) {
                        return false;
                    }
                }
                if (angular.isString(value)) {
                    if (Core.isBlank(value)) {
                        return false;
                    }
                }
                if (angular.isObject(value)) {
                    if (!value || angular.equals(value, {})) {
                        return false;
                    }
                }
                return true;
            };
            $scope.installed = function (installed) {
                var answer = Core.parseBooleanValue(installed);
                return answer;
            };
            $scope.showValue = function (value) {
                if (angular.isArray(value)) {
                    var answer = ['<ul class="zebra-list">'];
                    value.forEach(function (v) { answer.push('<li>' + v + '</li>'); });
                    answer.push('</ul>');
                    return answer.join('\n');
                }
                if (angular.isObject(value)) {
                    var answer = ['<table class="table">', '<tbody>'];
                    angular.forEach(value, function (value, key) {
                        answer.push('<tr>');
                        answer.push('<td>' + key + '</td>');
                        answer.push('<td>' + value + '</td>');
                        answer.push('</tr>');
                    });
                    answer.push('</tbody>');
                    answer.push('</table>');
                    return answer.join('\n');
                }
                return "" + value;
            };
            $scope.getStateStyle = function (feature) {
                if (Core.parseBooleanValue(feature.Installed)) {
                    return "badge badge-success";
                }
                return "badge";
            };
            $scope.filterFeature = function (feature) {
                if (Core.isBlank($scope.filter)) {
                    return true;
                }
                if (feature.Id.has($scope.filter)) {
                    return true;
                }
                return false;
            };
            function render(response) {
                var responseJson = angular.toJson(response.value);
                if ($scope.responseJson !== responseJson) {
                    $scope.responseJson = responseJson;
                    //log.debug("Got response: ", response.value);
                    if (response['value']['Features'] === null) {
                        $scope.featuresError = true;
                    }
                    else {
                        $scope.featuresError = false;
                    }
                    $scope.features = [];
                    $scope.repositories = [];
                    var features = [];
                    var repositories = [];
                    Karaf.populateFeaturesAndRepos(response.value, features, repositories);
                    var installedFeatures = features.filter(function (f) { return Core.parseBooleanValue(f.Installed); });
                    var uninstalledFeatures = features.filter(function (f) { return !Core.parseBooleanValue(f.Installed); });
                    //log.debug("repositories: ", repositories);
                    $scope.installedFeatures = _.sortBy(installedFeatures, function (f) { return f['Name']; });
                    uninstalledFeatures = _.sortBy(uninstalledFeatures, function (f) { return f['Name']; });
                    _.sortBy(repositories, 'id').forEach(function (repo) {
                        $scope.repositories.push({
                            repository: repo['id'],
                            uri: repo['uri'],
                            features: _.filter(uninstalledFeatures, function (f) { return f['RepositoryName'] === repo['id']; })
                        });
                    });
                    if (!Core.isBlank($scope.newRepositoryURI)) {
                        var selectedRepo = _.find(repositories, function (r) { return r['uri'] === $scope.newRepositoryURI; });
                        if (selectedRepo) {
                            $scope.selectedRepositoryId = selectedRepo['id'];
                        }
                        $scope.newRepositoryURI = '';
                    }
                    if (Core.isBlank($scope.selectedRepositoryId)) {
                        $scope.selectedRepository = _.first($scope.repositories);
                    }
                    else {
                        $scope.selectedRepository = _.find($scope.repositories, function (r) { return r.repository === $scope.selectedRepositoryId; });
                    }
                    Core.$apply($scope);
                }
            }
        }]);
})(Karaf || (Karaf = {}));
/// <reference path="karafHelpers.ts"/>
/// <reference path="karafPlugin.ts"/>
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.NavBarController", ["$scope", "$location", "workspace", function ($scope, $location, workspace) {
            $scope.hash = workspace.hash();
            $scope.isKarafEnabled = workspace.treeContainsDomainAndProperties("org.apache.karaf");
            $scope.isFeaturesEnabled = Karaf.getSelectionFeaturesMBean(workspace);
            $scope.isScrEnabled = Karaf.getSelectionScrMBean(workspace);
            $scope.$on('$routeChangeSuccess', function () {
                $scope.hash = workspace.hash();
            });
            $scope.isActive = function (path) { return workspace.isLinkActive(path); };
            $scope.isPrefixActive = function (path) { return workspace.isLinkPrefixActive(path); };
            $scope.goto = function (path) { return $location.path(path); };
        }]);
})(Karaf || (Karaf = {}));
/// <reference path="karafHelpers.ts"/>
/// <reference path="karafPlugin.ts"/>
var Karaf;
(function (Karaf) {
    Karaf._module.controller("Karaf.ServerController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.data = {
                name: "",
                version: "",
                state: "",
                root: "",
                startLevel: "",
                framework: "",
                frameworkVersion: "",
                location: "",
                sshPort: "",
                rmiRegistryPort: "",
                rmiServerPort: "",
                pid: ""
            };
            $scope.$on('jmxTreeUpdated', reloadFunction);
            $scope.$watch('workspace.tree', reloadFunction);
            function reloadFunction() {
                // if the JMX tree is reloaded its probably because a new MBean has been added or removed
                // so lets reload, asynchronously just in case
                setTimeout(loadData, 50);
            }
            function loadData() {
                console.log("Loading Karaf data...");
                jolokia.search("org.apache.karaf:type=instance,*", Core.onSuccess(render));
            }
            function render(response) {
                // grab the first mbean as there should ideally only be one karaf in the JVM
                if (angular.isArray(response)) {
                    var mbean = response[0];
                    if (mbean) {
                        jolokia.getAttribute(mbean, "Instances", Core.onSuccess(function (response) {
                            onInstances(response, mbean);
                        }));
                    }
                }
            }
            function onInstances(instances, mbean) {
                if (instances) {
                    var parsedMBean = Core.parseMBean(mbean);
                    var instanceName = 'root';
                    if ('attributes' in parsedMBean) {
                        if ('name' in parsedMBean['attributes']) {
                            instanceName = parsedMBean['attributes']['name'];
                        }
                    }
                    //log.debug("mbean: ", Core.parseMBean(mbean));
                    //log.debug("Instances: ", instances);
                    // the name is the first child
                    var rootInstance = instances[instanceName];
                    $scope.data.name = rootInstance.Name;
                    $scope.data.state = rootInstance.State;
                    $scope.data.root = rootInstance["Is Root"];
                    $scope.data.location = rootInstance.Location;
                    $scope.data.sshPort = rootInstance["SSH Port"];
                    $scope.data.rmiRegistryPort = rootInstance["RMI Registry Port"];
                    $scope.data.rmiServerPort = rootInstance["RMI Server Port"];
                    $scope.data.pid = rootInstance.Pid;
                    // we need to get these data from the system mbean
                    $scope.data.version = "?";
                    $scope.data.startLevel = "?";
                    $scope.data.framework = "?";
                    $scope.data.frameworkVersion = "?";
                    var systemMbean = "org.apache.karaf:type=system,name=" + rootInstance.Name;
                    // get more data, and its okay to do this synchronously
                    var response = jolokia.request({ type: "read", mbean: systemMbean,
                        attribute: ["StartLevel", "Framework", "Version"] }, Core.onSuccess(null));
                    var obj = response.value;
                    if (obj) {
                        $scope.data.version = obj.Version;
                        $scope.data.startLevel = obj.StartLevel;
                        $scope.data.framework = obj.Framework;
                    }
                    // and the osgi framework version is the bundle version
                    var response2 = jolokia.search("osgi.core:type=bundleState,*", Core.onSuccess(null));
                    if (angular.isArray(response2)) {
                        var mbean = response2[0];
                        if (mbean) {
                            // get more data, and its okay to do this synchronously
                            var response3 = jolokia.request({ type: 'exec', mbean: mbean, operation: 'getVersion(long)', arguments: [0] }, Core.onSuccess(null));
                            var obj3 = response3.value;
                            if (obj3) {
                                $scope.data.frameworkVersion = obj3;
                            }
                        }
                    }
                }
                // ensure web page is updated
                Core.$apply($scope);
            }
        }]);
})(Karaf || (Karaf = {}));
var Osgi;
(function (Osgi) {
    Osgi.log = Logger.get("OSGi");
    function defaultBundleValues(workspace, $scope, values) {
        var allValues = values;
        angular.forEach(values, function (row) {
            row["ImportData"] = parseActualPackages(row["ImportedPackages"]);
            row["ExportData"] = parseActualPackages(row["ExportedPackages"]);
            row["IdentifierLink"] = bundleLinks(workspace, row["Identifier"]);
            row["Hosts"] = labelBundleLinks(workspace, row["Hosts"], allValues);
            row["Fragments"] = labelBundleLinks(workspace, row["Fragments"], allValues);
            row["ImportedPackages"] = _.uniq(row["ImportedPackages"]);
            row["StateStyle"] = getStateStyle("label", row["State"]);
            row["RequiringBundles"] = labelBundleLinks(workspace, row["RequiringBundles"], allValues);
        });
        return values;
    }
    Osgi.defaultBundleValues = defaultBundleValues;
    function getStateStyle(prefix, state) {
        switch (state) {
            case "INSTALLED":
                return prefix + "-important";
            case "RESOLVED":
                return prefix + "-inverse";
            case "STARTING":
                return prefix + "-warning";
            case "ACTIVE":
                return prefix + "-success";
            case "STOPPING":
                return prefix + "-info";
            case "UNINSTALLED":
                return ""; // the default color, which is grey
            default:
                return prefix + "-important";
        }
    }
    Osgi.getStateStyle = getStateStyle;
    function defaultServiceValues(workspace, $scope, values) {
        angular.forEach(values, function (row) {
            row["BundleLinks"] = bundleLinks(workspace, row["BundleIdentifier"]);
        });
        return values;
    }
    Osgi.defaultServiceValues = defaultServiceValues;
    function defaultPackageValues(workspace, $scope, values) {
        var packages = [];
        function onPackageEntry(packageEntry, row) {
            if (!row)
                row = packageEntry;
            var name = packageEntry["Name"];
            var version = packageEntry["Version"];
            if (name && !_.startsWith(name, "#")) {
                var importingBundles = row["ImportingBundles"] || packageEntry["ImportingBundles"];
                var exportingBundles = row["ExportingBundles"] || packageEntry["ExportingBundles"];
                packageEntry["ImportingBundleUrls"] = bundleUrls(workspace, importingBundles);
                packageEntry["ExportingBundleUrls"] = bundleUrls(workspace, exportingBundles);
                packages.push(packageEntry);
            }
        }
        // the values could contain a child 'values' array of objects so use those directly
        var childValues = values.values;
        if (childValues) {
            angular.forEach(childValues, onPackageEntry);
        }
        angular.forEach(values, function (row) {
            angular.forEach(row, function (version) {
                angular.forEach(version, function (packageEntry) {
                    onPackageEntry(packageEntry, row);
                });
            });
        });
        return packages;
    }
    Osgi.defaultPackageValues = defaultPackageValues;
    function defaultConfigurationValues(workspace, $scope, values) {
        var array = [];
        angular.forEach(values, function (row) {
            var map = {};
            map["Pid"] = row[0];
            map["PidLink"] = "<a href='" + Core.url("/osgi/pid/" + row[0] + workspace.hash()) + "'>" + row[0] + "</a>";
            map["Bundle"] = row[1];
            array.push(map);
        });
        return array;
    }
    Osgi.defaultConfigurationValues = defaultConfigurationValues;
    function parseActualPackages(packages) {
        var result = {};
        for (var i = 0; i < packages.length; i++) {
            var pkg = packages[i];
            var idx = pkg.indexOf(";");
            if (idx > 0) {
                var name = pkg.substring(0, idx);
                var ver = pkg.substring(idx + 1);
                var data = result[name];
                if (data === undefined) {
                    data = {};
                    result[name] = data;
                }
                data["ReportedVersion"] = ver;
            }
        }
        return result;
    }
    Osgi.parseActualPackages = parseActualPackages;
    function parseManifestHeader(headers, name) {
        var result = {};
        var data = {};
        var hdr = headers[name];
        if (hdr === undefined) {
            return result;
        }
        var ephdr = hdr.Value;
        var inPkg = true;
        var inQuotes = false;
        var pkgName = "";
        var daDecl = "";
        for (var i = 0; i < ephdr.length; i++) {
            var c = ephdr[i];
            if (c === '"') {
                inQuotes = !inQuotes;
                continue;
            }
            if (inQuotes) {
                daDecl += c;
                continue;
            }
            // from here on we are never inside quotes
            if (c === ';') {
                if (inPkg) {
                    inPkg = false;
                }
                else {
                    handleDADecl(data, daDecl);
                    // reset directive and attribute variable
                    daDecl = "";
                }
                continue;
            }
            if (c === ',') {
                handleDADecl(data, daDecl);
                result[pkgName] = data;
                // reset data
                data = {};
                pkgName = "";
                daDecl = "";
                inPkg = true;
                continue;
            }
            if (inPkg) {
                pkgName += c;
            }
            else {
                daDecl += c;
            }
        }
        handleDADecl(data, daDecl);
        result[pkgName] = data;
        return result;
    }
    Osgi.parseManifestHeader = parseManifestHeader;
    function handleDADecl(data, daDecl) {
        var didx = daDecl.indexOf(":=");
        if (didx > 0) {
            data["D" + daDecl.substring(0, didx)] = daDecl.substring(didx + 2);
            return;
        }
        var aidx = daDecl.indexOf("=");
        if (aidx > 0) {
            data["A" + daDecl.substring(0, aidx)] = daDecl.substring(aidx + 1);
            return;
        }
    }
    function toCollection(values) {
        var collection = values;
        if (!angular.isArray(values)) {
            collection = [values];
        }
        return collection;
    }
    Osgi.toCollection = toCollection;
    function labelBundleLinks(workspace, values, allValues) {
        var answer = [];
        var sorted = toCollection(values).sort(function (a, b) { return a - b; });
        angular.forEach(sorted, function (value, key) {
            answer.push({
                label: allValues[value].SymbolicName,
                url: Core.url("/osgi/bundle/" + value + workspace.hash())
            });
        });
        return answer;
    }
    Osgi.labelBundleLinks = labelBundleLinks;
    function bundleLinks(workspace, values) {
        var answer = "";
        var sorted = toCollection(values).sort(function (a, b) { return a - b; });
        angular.forEach(sorted, function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a href='" + Core.url("/osgi/bundle/" + value + workspace.hash()) + "'>Bundle " + value + "</a>";
        });
        return answer;
    }
    Osgi.bundleLinks = bundleLinks;
    function bundleUrls(workspace, values) {
        var answer = [];
        angular.forEach(values, function (value, key) {
            answer.push(Core.url("/osgi/bundle/" + value + workspace.hash()));
        });
        return answer;
    }
    Osgi.bundleUrls = bundleUrls;
    function pidLinks(workspace, values) {
        var answer = "";
        angular.forEach(toCollection(values), function (value, key) {
            var prefix = "";
            if (answer.length > 0) {
                prefix = " ";
            }
            answer += prefix + "<a href='" + Core.url("/osgi/bundle/" + value + workspace.hash()) + "'>" + value + "</a>";
        });
        return answer;
    }
    Osgi.pidLinks = pidLinks;
    /**
     * Finds a bundle by id
     *
     * @method findBundle
     * @for Osgi
     * @param {String} bundleId
     * @param {Array} values
     * @return {any}
     *
     */
    function findBundle(bundleId, values) {
        var answer = "";
        angular.forEach(values, function (row) {
            var id = row["Identifier"];
            if (bundleId === id.toString()) {
                answer = row;
                return answer;
            }
        });
        return answer;
    }
    Osgi.findBundle = findBundle;
    function getSelectionBundleMBean(workspace) {
        if (workspace) {
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("osgi.core", "bundleState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionBundleMBean = getSelectionBundleMBean;
    /**
     * Walks the tree looking in the first child all the way down until we find an objectName
     * @method findFirstObjectName
     * @for Osgi
     * @param {Folder} node
     * @return {String}
     *
     */
    function findFirstObjectName(node) {
        if (node) {
            var answer = node.objectName;
            if (answer) {
                return answer;
            }
            else {
                var children = node.children;
                if (children && children.length) {
                    return findFirstObjectName(children[0]);
                }
            }
        }
        return null;
    }
    Osgi.findFirstObjectName = findFirstObjectName;
    function getSelectionFrameworkMBean(workspace) {
        if (workspace) {
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("osgi.core", "framework");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionFrameworkMBean = getSelectionFrameworkMBean;
    function getSelectionServiceMBean(workspace) {
        if (workspace) {
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("osgi.core", "serviceState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionServiceMBean = getSelectionServiceMBean;
    function getSelectionPackageMBean(workspace) {
        if (workspace) {
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("osgi.core", "packageState");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionPackageMBean = getSelectionPackageMBean;
    function getSelectionConfigAdminMBean(workspace) {
        if (workspace) {
            // lets navigate to the tree item based on paths
            var folder = workspace.tree.navigate("osgi.compendium", "cm");
            return Osgi.findFirstObjectName(folder);
        }
        return null;
    }
    Osgi.getSelectionConfigAdminMBean = getSelectionConfigAdminMBean;
    function getMetaTypeMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["MetaTypeFacade"] || {};
            var mbeanFolder = typeFolder["io.fabric8"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getMetaTypeMBean = getMetaTypeMBean;
    function getProfileMetadataMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["ProfileMetadata"] || {};
            var mbeanFolder = typeFolder["io.fabric8"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getProfileMetadataMBean = getProfileMetadataMBean;
    function getHawtioOSGiToolsMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var toolsFacades = mbeanTypesToDomain["OSGiTools"] || {};
            var hawtioFolder = toolsFacades["hawtio"] || {};
            return hawtioFolder["objectName"];
        }
        return null;
    }
    Osgi.getHawtioOSGiToolsMBean = getHawtioOSGiToolsMBean;
    function getHawtioConfigAdminMBean(workspace) {
        if (workspace) {
            var mbeanTypesToDomain = workspace.mbeanTypesToDomain;
            var typeFolder = mbeanTypesToDomain["ConfigAdmin"] || {};
            var mbeanFolder = typeFolder["hawtio"] || {};
            return mbeanFolder["objectName"];
        }
        return null;
    }
    Osgi.getHawtioConfigAdminMBean = getHawtioConfigAdminMBean;
    /**
     * Creates a link to the given configuration pid and/or factoryPid
     */
    function createConfigPidLink($scope, workspace, pid, isFactory) {
        if (isFactory === void 0) { isFactory = false; }
        return createConfigPidPath($scope, pid, isFactory) + workspace.hash();
    }
    Osgi.createConfigPidLink = createConfigPidLink;
    /**
     * Creates a path to the given configuration pid and/or factoryPid
     */
    function createConfigPidPath($scope, pid, isFactory) {
        if (isFactory === void 0) { isFactory = false; }
        var link = pid;
        var versionId = $scope.versionId;
        var profileId = $scope.profileId;
        if (versionId && versionId) {
            var configPage = isFactory ? "/newConfiguration/" : "/configuration/";
            return "/wiki/branch/" + versionId + configPage + link + "/" + $scope.pageId;
        }
        else {
            return "osgi/pid/" + link;
        }
    }
    Osgi.createConfigPidPath = createConfigPidPath;
    function getConfigurationProperties(workspace, jolokia, pid, onDataFn) {
        var mbean = getSelectionConfigAdminMBean(workspace);
        var answer = null;
        if (jolokia && mbean) {
            answer = jolokia.execute(mbean, 'getProperties', pid, Core.onSuccess(onDataFn));
        }
        return answer;
    }
    Osgi.getConfigurationProperties = getConfigurationProperties;
    /**
     * For a pid of the form "foo.generatedId" for a pid "foo" or "foo.bar" remove the "foo." prefix
     */
    function removeFactoryPidPrefix(pid, factoryPid) {
        if (pid && factoryPid) {
            if (_.startsWith(pid, factoryPid)) {
                return pid.substring(factoryPid.length + 1);
            }
            var idx = factoryPid.lastIndexOf(".");
            if (idx > 0) {
                var prefix = factoryPid.substring(0, idx + 1);
                return Core.trimLeading(pid, prefix);
            }
        }
        return pid;
    }
    Osgi.removeFactoryPidPrefix = removeFactoryPidPrefix;
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    var OsgiDataService = /** @class */ (function () {
        function OsgiDataService(workspace, jolokia) {
            this.jolokia = jolokia;
            this.workspace = workspace;
        }
        OsgiDataService.prototype.getBundles = function () {
            var bundles = {};
            // TODO make this async,especially given this returns lots of data
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionBundleMBean(this.workspace),
                operation: 'listBundles()'
            }, Core.onSuccess(null));
            angular.forEach(response.value, function (value, key) {
                var obj = {
                    Identifier: value.Identifier,
                    Name: "",
                    SymbolicName: value.SymbolicName,
                    Fragment: value.Fragment,
                    State: value.State,
                    Version: value.Version,
                    LastModified: new Date(Number(value.LastModified)),
                    Location: value.Location,
                    StartLevel: undefined,
                    RegisteredServices: value.RegisteredServices,
                    ServicesInUse: value.ServicesInUse
                };
                if (value.Headers['Bundle-Name']) {
                    obj.Name = value.Headers['Bundle-Name']['Value'];
                }
                bundles[value.Identifier] = obj;
            });
            return bundles;
        };
        OsgiDataService.prototype.getServices = function () {
            var services = {};
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionServiceMBean(this.workspace),
                operation: 'listServices()'
            }, Core.onSuccess(null));
            var answer = response.value;
            angular.forEach(answer, function (value, key) {
                services[value.Identifier] = value;
            });
            return services;
        };
        OsgiDataService.prototype.getPackages = function () {
            var packages = {};
            var response = this.jolokia.request({
                type: 'exec',
                mbean: Osgi.getSelectionPackageMBean(this.workspace),
                operation: 'listPackages()'
            }, Core.onSuccess(null));
            var answer = response.value.values;
            answer.forEach(function (value) {
                packages[value.Name + "-" + value.Version] = value;
            });
            return packages;
        };
        return OsgiDataService;
    }());
    Osgi.OsgiDataService = OsgiDataService;
})(Osgi || (Osgi = {}));
/// <reference path="../osgiHelpers.ts"/>
/// <reference path="bundle.ts"/>
var Osgi;
(function (Osgi) {
    var BundlesService = /** @class */ (function () {
        BundlesService.$inject = ["$q", "jolokia", "workspace"];
        function BundlesService($q, jolokia, workspace) {
            'ngInject';
            this.$q = $q;
            this.jolokia = jolokia;
            this.workspace = workspace;
            this.log = Logger.get("Osgi");
        }
        BundlesService.prototype.getBundles = function () {
            return this.execute(Osgi.getSelectionBundleMBean(this.workspace), 'listBundles()')
                .then(function (value) {
                var bundles = [];
                angular.forEach(value, function (item, key) {
                    var bundle = {
                        id: item.Identifier,
                        name: item.Headers['Bundle-Name'] ? item.Headers['Bundle-Name']['Value'] : '',
                        symbolicName: item.SymbolicName,
                        state: item.State.toLowerCase(),
                        version: item.Version
                    };
                    bundles.push(bundle);
                });
                return bundles;
            });
        };
        BundlesService.prototype.startBundles = function (bundles) {
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            var ids = bundles.map(function (bundle) { return bundle.id; });
            return this.execute(mbean, 'startBundles([J)', ids)
                .then(this.handleResponse);
        };
        BundlesService.prototype.stopBundles = function (bundles) {
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            var ids = bundles.map(function (bundle) { return bundle.id; });
            return this.execute(mbean, 'stopBundles([J)', ids)
                .then(this.handleResponse);
        };
        BundlesService.prototype.updateBundles = function (bundles) {
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            var ids = bundles.map(function (bundle) { return bundle.id; });
            return this.execute(mbean, 'updateBundles([J)', ids)
                .then(this.handleResponse);
        };
        BundlesService.prototype.refreshBundles = function (bundles) {
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            var ids = bundles.map(function (bundle) { return bundle.id; });
            return this.execute(mbean, 'refreshBundles([J)', ids)
                .then(this.handleResponse);
        };
        BundlesService.prototype.uninstallBundles = function (bundles) {
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            var ids = bundles.map(function (bundle) { return bundle.id; });
            return this.execute(mbean, 'uninstallBundles([J)', ids)
                .then(this.handleResponse);
        };
        BundlesService.prototype.installBundle = function (bundleUrl) {
            var _this = this;
            var mbean = Osgi.getSelectionFrameworkMBean(this.workspace);
            return this.execute(mbean, 'installBundle(java.lang.String)', bundleUrl)
                .then(function (response) { return _this.execute(mbean, 'startBundles([J)', response); })
                .then(this.handleResponse);
        };
        BundlesService.prototype.execute = function (mbean, operation, args) {
            var _this = this;
            if (args === void 0) { args = undefined; }
            var request = {
                type: 'exec',
                mbean: mbean,
                operation: operation
            };
            if (args) {
                request['arguments'] = [args];
            }
            return this.$q(function (resolve, reject) {
                _this.jolokia.request(request, {
                    method: "post",
                    success: function (response) { return resolve(response.value); },
                    error: function (response) {
                        _this.log.error("BundlesService.execute() failed. " + response);
                        reject(response.error);
                    }
                });
            });
        };
        BundlesService.prototype.handleResponse = function (response) {
            console.log(response);
            if (response && response['Error']) {
                throw response['Error'];
            }
            else {
                return "The operation completed successfully";
            }
        };
        return BundlesService;
    }());
    Osgi.BundlesService = BundlesService;
})(Osgi || (Osgi = {}));
/// <reference path="bundle.ts"/>
/// <reference path="bundles-service.ts"/>
var Osgi;
(function (Osgi) {
    var BundlesController = /** @class */ (function () {
        BundlesController.$inject = ["bundlesService"];
        function BundlesController(bundlesService) {
            'ngInject';
            var _this = this;
            this.bundlesService = bundlesService;
            this.startAction = {
                name: 'Start',
                actionFn: function (action) {
                    var selectedBundles = _this.getSelectedBundles();
                    _this.bundlesService.startBundles(selectedBundles)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadBundles();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.stopAction = {
                name: 'Stop',
                actionFn: function (action) {
                    var selectedBundles = _this.getSelectedBundles();
                    _this.bundlesService.stopBundles(selectedBundles)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadBundles();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.refreshAction = {
                name: 'Refresh',
                actionFn: function (action) {
                    var selectedBundles = _this.getSelectedBundles();
                    _this.bundlesService.refreshBundles(selectedBundles)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadBundles();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.updateAction = {
                name: 'Update',
                actionFn: function (action) {
                    var selectedBundles = _this.getSelectedBundles();
                    _this.bundlesService.updateBundles(selectedBundles)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadBundles();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.uninstallAction = {
                name: 'Uninstall',
                actionFn: function (action) {
                    var selectedBundles = _this.getSelectedBundles();
                    _this.bundlesService.uninstallBundles(selectedBundles)
                        .then(function (response) {
                        Core.notification('success', response);
                        _this.loadBundles();
                    })
                        .catch(function (error) { return Core.notification('danger', error); });
                },
                isDisabled: true
            };
            this.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'state',
                            title: 'State',
                            placeholder: 'Filter by state...',
                            filterType: 'select',
                            filterValues: [
                                'active',
                                'installed',
                                'resolved',
                                'signers_all',
                                'signers_trusted',
                                'start_activation_policy',
                                'start_transient',
                                'starting',
                                'stop_transient',
                                'stopping',
                                'uninstalled'
                            ]
                        },
                        {
                            id: 'name',
                            title: 'Name',
                            placeholder: 'Filter by name...',
                            filterType: 'text'
                        },
                        {
                            id: 'symbolicName',
                            title: 'Symbolic Name',
                            placeholder: 'Filter by symbolic name...',
                            filterType: 'text'
                        },
                        {
                            id: 'version',
                            title: 'Version',
                            placeholder: 'Filter by version...',
                            filterType: 'text'
                        }
                    ],
                    onFilterChange: function (filters) {
                        _this.applyFilters(filters);
                    },
                    resultsCount: 0
                },
                actionsConfig: {
                    primaryActions: [
                        this.startAction,
                        this.stopAction,
                        this.refreshAction,
                        this.updateAction,
                        this.uninstallAction
                    ]
                },
                isTableView: true
            };
            this.tableConfig = {
                selectionMatchProp: 'id',
                onCheckBoxChange: function (item) { return _this.enableDisableActions(); }
            };
            this.tableColumns = [
                { header: 'ID', itemField: 'id', templateFn: function (value) { return "<a href=\"osgi/bundle/" + value + "\">" + value + "</a>"; } },
                { header: 'State', itemField: 'state' },
                { header: 'Name', itemField: 'name' },
                { header: 'Symbolic Name', itemField: 'symbolicName' },
                { header: 'Version', itemField: 'version' }
            ];
            this.tableItems = null;
            this.loading = true;
        }
        BundlesController.prototype.$onInit = function () {
            this.loadBundles();
        };
        BundlesController.prototype.loadBundles = function () {
            var _this = this;
            this.bundlesService.getBundles()
                .then(function (bundles) {
                _this.bundles = bundles;
                _this.tableItems = bundles;
                _this.toolbarConfig.filterConfig.resultsCount = bundles.length;
                _this.enableDisableActions();
                _this.loading = false;
            });
        };
        BundlesController.prototype.applyFilters = function (filters) {
            var filteredBundles = this.bundles;
            filters.forEach(function (filter) {
                filteredBundles = BundlesController.FILTER_FUNCTIONS[filter.id](filteredBundles, filter.value);
            });
            this.tableItems = filteredBundles;
            this.toolbarConfig.filterConfig.resultsCount = filteredBundles.length;
        };
        BundlesController.prototype.getSelectedBundles = function () {
            var _this = this;
            return this.tableItems
                .map(function (tableItem, i) { return angular.extend(_this.bundles[i], { selected: tableItem['selected'] }); })
                .filter(function (bundle) { return bundle.selected; });
        };
        BundlesController.prototype.enableDisableActions = function () {
            var selectedBundles = this.getSelectedBundles();
            var noBundlesSelected = selectedBundles.length === 0;
            this.startAction.isDisabled = noBundlesSelected || selectedBundles.every(function (bundle) { return bundle.state === 'active'; });
            this.stopAction.isDisabled = noBundlesSelected || selectedBundles.every(function (bundle) { return bundle.state !== 'active'; });
            this.refreshAction.isDisabled = noBundlesSelected;
            this.updateAction.isDisabled = noBundlesSelected;
            this.uninstallAction.isDisabled = noBundlesSelected;
        };
        BundlesController.FILTER_FUNCTIONS = {
            state: function (bundles, state) { return bundles.filter(function (bundle) { return bundle.state === state; }); },
            name: function (bundles, name) {
                var regExp = new RegExp(name, 'i');
                return bundles.filter(function (bundle) { return regExp.test(bundle.name); });
            },
            symbolicName: function (bundles, symbolicName) {
                var regExp = new RegExp(symbolicName, 'i');
                return bundles.filter(function (bundle) { return regExp.test(bundle.symbolicName); });
            },
            version: function (bundles, version) {
                var regExp = new RegExp(version, 'i');
                return bundles.filter(function (bundle) { return regExp.test(bundle.version); });
            }
        };
        return BundlesController;
    }());
    Osgi.BundlesController = BundlesController;
    Osgi.bundlesComponent = {
        template: "\n      <div class=\"table-view\">\n        <h1>Bundles</h1>\n        <div ng-if=\"!$ctrl.loading\">\n          <install-bundle on-install=\"$ctrl.loadBundles()\"></install-bundle>\n          <pf-toolbar config=\"$ctrl.toolbarConfig\"></pf-toolbar>\n          <pf-table-view config=\"$ctrl.tableConfig\"\n                         colummns=\"$ctrl.tableColumns\"\n                         items=\"$ctrl.tableItems\"></pf-table-view>\n        </div>\n        <div class=\"spinner spinner-lg loading-page\" ng-if=\"$ctrl.loading\"></div>\n      </div>\n    ",
        controller: BundlesController
    };
})(Osgi || (Osgi = {}));
/// <reference path="bundle.ts"/>
var Osgi;
(function (Osgi) {
    var InstallBundleController = /** @class */ (function () {
        InstallBundleController.$inject = ["bundlesService"];
        function InstallBundleController(bundlesService) {
            'ngInject';
            this.bundlesService = bundlesService;
        }
        InstallBundleController.prototype.install = function (bundleUrl) {
            var _this = this;
            this.bundlesService.installBundle(bundleUrl)
                .then(function (response) {
                Core.notification('success', response);
                _this['onInstall']();
            })
                .catch(function (error) { return Core.notification('danger', error); });
        };
        return InstallBundleController;
    }());
    Osgi.InstallBundleController = InstallBundleController;
    Osgi.installBundleComponent = {
        template: "\n      <div class=\"row install-bundle\">\n        <div class=\"col-lg-6\">\n        </div>\n        <div class=\"col-lg-6\">\n          <div class=\"input-group\">\n            <input type=\"text\" class=\"form-control\" placeholder=\"Bundle URL...\" ng-model=\"bundleUrl\">\n            <span class=\"input-group-btn\">\n              <button type=\"button\" class=\"btn btn-default\" ng-click=\"$ctrl.install(bundleUrl)\">\n                Install\n              </button>\n            </span>\n          </div>\n        </div>\n      </div>\n    ",
        controller: InstallBundleController,
        bindings: {
            onInstall: '&'
        }
    };
})(Osgi || (Osgi = {}));
/// <reference path="bundles-component.ts"/>
/// <reference path="install-bundle-component.ts"/>
/// <reference path="bundles-service.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.bundlesModule = angular
        .module('hawtio-osgi-bundles', [])
        .component('bundles', Osgi.bundlesComponent)
        .component('installBundle', Osgi.installBundleComponent)
        .service('bundlesService', Osgi.BundlesService)
        .name;
})(Osgi || (Osgi = {}));
/// <reference path="osgiData.ts"/>
/// <reference path="osgiHelpers.ts"/>
/// <reference path="../../karaf/ts/karafHelpers.ts"/>
/// <reference path="bundles/bundles.module.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.pluginName = 'osgi';
    Osgi._module = angular.module(Osgi.pluginName, [
        'patternfly',
        'infinite-scroll',
        Osgi.bundlesModule
    ]);
    Osgi._module.config(["$routeProvider", function ($routeProvider) {
            $routeProvider
                .when('/osgi', { redirectTo: '/osgi/bundles' })
                .when('/osgi/bundles', { template: '<bundles></bundles>' })
                .when('/osgi/bundle/:bundleId', { templateUrl: 'plugins/osgi/html/bundle.html' })
                .when('/osgi/services', { templateUrl: 'plugins/osgi/html/services.html' })
                .when('/osgi/packages', { templateUrl: 'plugins/osgi/html/packages.html' })
                .when('/osgi/configurations', { templateUrl: 'plugins/osgi/html/configurations.html' })
                .when('/osgi/pid/:pid/:factoryPid', { templateUrl: 'plugins/osgi/html/pid.html' })
                .when('/osgi/pid/:pid', { templateUrl: 'plugins/osgi/html/pid.html' })
                .when('/osgi/fwk', { templateUrl: 'plugins/osgi/html/framework.html' });
        }]);
    Osgi._module.run(["HawtioNav", "workspace", "viewRegistry", "helpRegistry", function (nav, workspace, viewRegistry, helpRegistry) {
            viewRegistry['osgi'] = "plugins/osgi/html/layoutOsgi.html";
            helpRegistry.addUserDoc('osgi', 'plugins/osgi/doc/help.md', function () {
                return workspace.treeContainsDomainAndProperties("osgi.core");
            });
            var builder = nav.builder();
            var tab = builder.id('osgi')
                .title(function () { return 'OSGi'; })
                .href(function () { return '/osgi'; })
                .isValid(function () { return workspace.treeContainsDomainAndProperties("osgi.core"); })
                .isSelected(function () { return workspace.isLinkActive('osgi'); })
                .build();
            nav.add(tab);
        }]);
    Osgi._module.factory('osgiDataService', ["workspace", "jolokia", function (workspace, jolokia) {
            return new Osgi.OsgiDataService(workspace, jolokia);
        }]);
    hawtioPluginLoader.addModule(Osgi.pluginName);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.BundleListController", ["$scope", "workspace", "jolokia", "localStorage", "$location", function ($scope, workspace, jolokia, localStorage, $location) {
            var ACTIVEMQ_SERVICE = { id: 'ACTIVEMQ', name: 'ActiveMQ' };
            var CAMEL_SERVICE = { id: 'CAMEL', name: 'Camel' };
            var CXF_SERVICE = { id: 'CXF', name: 'CXF' };
            var PLATFORM_SERVICE = { id: 'PLATFORM', name: 'Platform' };
            $scope.availableServices = [
                ACTIVEMQ_SERVICE,
                CAMEL_SERVICE,
                CXF_SERVICE,
                PLATFORM_SERVICE
            ];
            $scope.result = {};
            $scope.bundles = [];
            $scope.bundleUrl = "";
            $scope.display = {
                bundleField: "Name",
                sortField: "Identifier",
                bundleFilter: "",
                startLevelFilter: 0,
                showBundleGroups: []
            };
            $scope.listViewUrl = Core.url('/osgi/bundle-list' + workspace.hash());
            $scope.tableViewUrl = Core.url('/osgi/bundles' + workspace.hash());
            if ('bundleList' in localStorage) {
                $scope.display = angular.fromJson(localStorage['bundleList']);
                if ($scope.display.showBundleGroups === undefined) {
                    $scope.display.showBundleGroups = [];
                }
            }
            $scope.$watch('display', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    localStorage['bundleList'] = angular.toJson(newValue);
                }
            }, true);
            $scope.installDisabled = function () {
                return $scope.bundleUrl === "";
            };
            $scope.install = function () {
                jolokia.request({
                    type: 'exec',
                    mbean: Osgi.getSelectionFrameworkMBean(workspace),
                    operation: "installBundle(java.lang.String)",
                    arguments: [$scope.bundleUrl]
                }, {
                    success: function (response) {
                        var bundleID = response.value;
                        jolokia.request({
                            type: 'exec',
                            mbean: Osgi.getSelectionBundleMBean(workspace),
                            operation: "isFragment(long)",
                            arguments: [bundleID]
                        }, {
                            success: function (response) {
                                var isFragment = response.value;
                                if (isFragment) {
                                    Core.notification("success", "Fragment installed successfully.");
                                    $scope.bundleUrl = "";
                                    Core.$apply($scope);
                                }
                                else {
                                    jolokia.request({
                                        type: 'exec',
                                        mbean: Osgi.getSelectionFrameworkMBean(workspace),
                                        operation: "startBundle(long)",
                                        arguments: [bundleID]
                                    }, {
                                        success: function (response) {
                                            Core.notification("success", "Bundle installed and started successfully.");
                                            $scope.bundleUrl = "";
                                            Core.$apply($scope);
                                        },
                                        error: function (response) {
                                            Core.notification("error", response.error);
                                        }
                                    });
                                }
                            },
                            error: function (response) {
                                Core.notification("error", response.error);
                            }
                        });
                    },
                    error: function (response) {
                        Core.notification("error", response.error);
                    }
                });
            };
            $scope.$watch('display.sortField', function (newValue, oldValue) {
                if (newValue !== oldValue) {
                    $scope.bundles = _.sortBy($scope.bundles, newValue);
                }
            });
            $scope.getStateStyle = function (state) {
                return Osgi.getStateStyle("badge", state);
            };
            $scope.getLabel = function (bundleObject) {
                var labelText;
                if ($scope.display.bundleField === "Name") {
                    labelText = bundleObject.Name;
                    if (labelText === "") {
                        labelText = bundleObject.SymbolicName;
                    }
                }
                else {
                    labelText = bundleObject.SymbolicName;
                }
                return labelText;
            };
            $scope.filterBundle = function (bundle) {
                if ($scope.display.startLevelFilter > 0 && bundle.StartLevel < $scope.display.startLevelFilter) {
                    return false;
                }
                var labelText = $scope.getLabel(bundle);
                if ($scope.display.bundleFilter) {
                    if (labelText.toLowerCase().indexOf($scope.display.bundleFilter.toLowerCase()) === -1) {
                        return false;
                    }
                    else {
                        return $scope.display.showBundleGroups.length === 0 ||
                            ($scope.display.showBundleGroups.length > 0 && matchesCheckedBundle(bundle));
                    }
                }
                else {
                    return $scope.display.showBundleGroups.length === 0 ||
                        ($scope.display.showBundleGroups.length > 0 && matchesCheckedBundle(bundle));
                }
            };
            $scope.showDetails = function (bundle) {
                $location.path(bundle.Url);
            };
            function matchesCheckedBundle(bundle) {
                return (shouldShowBundleGroup(ACTIVEMQ_SERVICE) && Karaf.isActiveMQBundle(bundle['SymbolicName'])) ||
                    (shouldShowBundleGroup(CAMEL_SERVICE) && Karaf.isCamelBundle(bundle['SymbolicName'])) ||
                    (shouldShowBundleGroup(CXF_SERVICE) && Karaf.isCxfBundle(bundle['SymbolicName'])) ||
                    (shouldShowBundleGroup(PLATFORM_SERVICE) && Karaf.isPlatformBundle(bundle['SymbolicName']));
            }
            function shouldShowBundleGroup(bundleGroup) {
                for (var i = 0; i < $scope.display.showBundleGroups.length; i++) {
                    if ($scope.display.showBundleGroups[i].id === bundleGroup.id) {
                        return true;
                    }
                }
                return false;
            }
            function processResponse(response) {
                var value = response['value'];
                var responseJson = angular.toJson(value);
                if ($scope.responseJson !== responseJson) {
                    $scope.responseJson = responseJson;
                    var bundles_1 = [];
                    angular.forEach(value, function (value, key) {
                        var obj = {
                            Identifier: value.Identifier,
                            Name: "",
                            SymbolicName: value.SymbolicName,
                            Fragment: value.Fragment,
                            State: value.State,
                            Version: value.Version,
                            LastModified: new Date(Number(value.LastModified)),
                            Location: value.Location,
                            StartLevel: undefined,
                            Url: Core.url("/osgi/bundle/" + value.Identifier)
                        };
                        if (value.Headers['Bundle-Name']) {
                            obj.Name = value.Headers['Bundle-Name']['Value'];
                        }
                        bundles_1.push(obj);
                    });
                    $scope.bundles = _.sortBy(bundles_1, $scope.display.sortField);
                    Core.$apply($scope);
                    // Obtain start level information for all the bundles, let's do this async though
                    setTimeout(function () {
                        var requests = [];
                        for (var i = 0; i < $scope.bundles.length; i++) {
                            var b = $scope.bundles[i];
                            requests.push({
                                type: 'exec', mbean: Osgi.getSelectionBundleMBean(workspace),
                                operation: 'getStartLevel(long)',
                                arguments: [b.Identifier]
                            });
                        }
                        var outstanding = requests.length;
                        jolokia.request(requests, Core.onSuccess(function (response) {
                            var id = response['request']['arguments'][0];
                            if (angular.isDefined(id)) {
                                var bundle = $scope.bundles[id];
                                if (bundle) {
                                    Osgi.log.debug("Setting bundle: ", bundle['Identifier'], " start level to: ", response['value']);
                                    bundle['StartLevel'] = response['value'];
                                }
                            }
                            outstanding = outstanding - 1;
                            Osgi.log.debug("oustanding responses: ", outstanding);
                            if (outstanding === 0) {
                                Osgi.log.debug("Updating page...");
                                Core.$apply($scope);
                            }
                        }, { error: function (response) {
                                // let's ignore the error - maybe the bundle is no longer available?
                            } }));
                    }, 500);
                }
            }
            Core.register(jolokia, $scope, {
                type: 'exec', mbean: Osgi.getSelectionBundleMBean(workspace),
                operation: 'listBundles()'
            }, Core.onSuccess(processResponse));
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    function formatServiceName(objClass) {
        if (angular.isArray(objClass)) {
            return formatServiceNameArray(objClass);
        }
        var name = objClass.toString();
        var idx = name.lastIndexOf('.');
        return name.substring(idx + 1);
    }
    Osgi.formatServiceName = formatServiceName;
    function formatServiceNameArray(objClass) {
        var rv = [];
        for (var i = 0; i < objClass.length; i++) {
            rv.push(formatServiceName(objClass[i]));
        }
        rv = _.filter(rv, function (elem, pos, self) { return self.indexOf(elem) === pos; });
        rv.sort();
        return rv.toString();
    }
    Osgi._module.controller("Osgi.BundleController", ["$scope", "$location", "workspace", "$routeParams", "jolokia", function ($scope, $location, workspace, $routeParams, jolokia) {
            $scope.bundleId = $routeParams.bundleId;
            $scope.classLoadingAlert = null;
            updateTableContents();
            $scope.showValue = function (key) {
                switch (key) {
                    case "Bundle-Name":
                    case "Bundle-SymbolicName":
                    case "Bundle-Version":
                    case "Export-Package":
                    case "Import-Package":
                        return false;
                    default:
                        return true;
                }
            };
            $scope.unsatisfiedPackages = {};
            $scope.thereAreUnsatisfiedPackages = function () { return Object.keys($scope.unsatisfiedPackages).length > 0; };
            $scope.dismissClassLoadingAlert = function () { return $scope.classLoadingAlert = null; };
            $scope.executeLoadClass = function (clazz) {
                var mbean = Osgi.getHawtioOSGiToolsMBean(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'getLoadClassOrigin', arguments: [$scope.bundleId, clazz] }, {
                        success: function (response) {
                            var resultBundle = response.value;
                            if (resultBundle === -1) {
                                $scope.classLoadingAlert = {
                                    type: 'warning',
                                    icon: 'pficon-warning-triangle-o',
                                    message: "Loading class <strong>" + clazz + "</strong> in Bundle " + $scope.bundleId + ".\n                                  Class can not be loaded from this bundle."
                                };
                            }
                            else {
                                $scope.classLoadingAlert = {
                                    type: 'success',
                                    icon: 'pficon-ok',
                                    message: "Loading class <strong>" + clazz + "</strong> in Bundle " + $scope.bundleId + ".\n                                  Class is served from Bundle " + Osgi.bundleLinks(workspace, resultBundle)
                                };
                            }
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            inspectReportError(response);
                            Core.$apply($scope);
                        }
                    });
                }
                else {
                    inspectReportNoMBeanFound();
                }
            };
            $scope.executeFindResource = function (resource) {
                var mbean = Osgi.getHawtioOSGiToolsMBean(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'getResourceURL', arguments: [$scope.bundleId, resource] }, {
                        success: function (response) {
                            var resultURL = response.value;
                            if (resultURL === null) {
                                $scope.classLoadingAlert = {
                                    type: 'warning',
                                    icon: 'pficon-warning-triangle-o',
                                    message: "Finding resource <strong>" + resource + "</strong> in Bundle " + $scope.bundleId + ".\n                                  Resource can not be found from this bundle."
                                };
                            }
                            else {
                                $scope.classLoadingAlert = {
                                    type: 'success',
                                    icon: 'pficon-ok',
                                    message: "Finding resource <strong>" + resource + "</strong> in Bundle " + $scope.bundleId + ".\n                                  Resource is available from: " + resultURL
                                };
                            }
                            Core.$apply($scope);
                        },
                        error: function (response) {
                            inspectReportError(response);
                            Core.$apply($scope);
                        }
                    });
                }
                else {
                    inspectReportNoMBeanFound();
                }
            };
            $scope.startBundle = function (bundleId) {
                jolokia.request([
                    { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'startBundle', arguments: [bundleId] }
                ], Core.onSuccess(updateTableContents));
            };
            $scope.stopBundle = function (bundleId) {
                jolokia.request([
                    { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'stopBundle', arguments: [bundleId] }
                ], Core.onSuccess(updateTableContents));
            };
            $scope.updatehBundle = function (bundleId) {
                jolokia.request([
                    { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'updateBundle', arguments: [bundleId] }
                ], Core.onSuccess(updateTableContents));
            };
            $scope.refreshBundle = function (bundleId) {
                jolokia.request([
                    { type: 'exec', mbean: Osgi.getSelectionFrameworkMBean(workspace), operation: 'refreshBundle', arguments: [bundleId] }
                ], Core.onSuccess(updateTableContents));
            };
            $scope.uninstallBundle = function (bundleId) {
                jolokia.request([{
                        type: 'exec',
                        mbean: Osgi.getSelectionFrameworkMBean(workspace),
                        operation: 'uninstallBundle',
                        arguments: [bundleId]
                    }], Core.onSuccess(function () {
                    $location.path("/osgi/bundles");
                    Core.$apply($scope);
                }));
            };
            function inspectReportNoMBeanFound() {
                $scope.classLoadingAlert = {
                    type: 'danger',
                    icon: 'pficon-error-circle-o',
                    message: "The hawtio.OSGiTools MBean is not available. Please contact technical support."
                };
            }
            function inspectReportError(response) {
                $scope.classLoadingAlert = {
                    type: 'danger',
                    icon: 'pficon-error-circle-o',
                    message: "<strong>Problem invoking hawtio.OSGiTools MBean:</strong> " + response.error
                };
            }
            function populateTable(response) {
                var values = response.value;
                $scope.bundles = values;
                // now find the row based on the selection ui
                Osgi.defaultBundleValues(workspace, $scope, values);
                $scope.row = Osgi.findBundle($scope.bundleId, values);
                createImportPackageSection();
                createExportPackageSection();
                populateServicesSection();
                Core.$apply($scope);
            }
            function createImportPackageSection() {
                var importPackageHeaders = Osgi.parseManifestHeader($scope.row.Headers, "Import-Package");
                for (var pkg in $scope.row.ImportData) {
                    var data = importPackageHeaders[pkg];
                    if (data !== undefined) {
                        $scope.row.ImportData[pkg].headers = data;
                    }
                    else {
                        var reason = $scope.row.Headers["DynamicImport-Package"];
                        if (reason !== undefined) {
                            reason = reason.Value;
                            $scope.row.ImportData[pkg].headers = { reason: 'Imported due to ' + reason.Value };
                        }
                    }
                    // Delete data so we can see whether there are any unbound optional imports left...
                    delete importPackageHeaders[pkg];
                }
                for (var pkg_1 in importPackageHeaders) {
                    // Ignore imported packages that are also exported because they are satisfied from the bundle
                    // itself and should not be listed as unsatisfied.
                    if ($scope.row.ExportData[pkg_1] === undefined) {
                        $scope.unsatisfiedPackages[pkg_1] = importPackageHeaders[pkg_1];
                    }
                }
            }
            function createExportPackageSection() {
                var exportPackageHeaders = Osgi.parseManifestHeader($scope.row.Headers, "Export-Package");
                for (var pkg in $scope.row.ExportData) {
                    // replace commas with comma + whitespace so names wrap nicely in the UI
                    if (exportPackageHeaders[pkg] && exportPackageHeaders[pkg].Duses) {
                        exportPackageHeaders[pkg].Duses = exportPackageHeaders[pkg].Duses.replace(/,/g, ', ');
                    }
                    $scope.row.ExportData[pkg].headers = exportPackageHeaders[pkg];
                }
            }
            function populateServicesSection() {
                if (($scope.row.RegisteredServices === undefined || $scope.row.RegisteredServices.length === 0) &&
                    ($scope.row.ServicesInUse === undefined || $scope.row.ServicesInUse === 0)) {
                    // no services for this bundle
                    return;
                }
                var mbean = Osgi.getSelectionServiceMBean(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'listServices()' }, Core.onSuccess(updateServices));
                }
            }
            function updateServices(result) {
                var data = result.value;
                for (var id in data) {
                    var reg = document.getElementById("registers.service." + id);
                    var uses = document.getElementById("uses.service." + id);
                    if ((reg === undefined || reg === null) && (uses === undefined || uses === null)) {
                        continue;
                    }
                    jolokia.request({
                        type: 'exec', mbean: Osgi.getSelectionServiceMBean(workspace),
                        operation: 'getProperties', arguments: [id]
                    }, Core.onSuccess(function (svcId, regEl, usesEl) {
                        return function (resp) {
                            var props = resp.value;
                            var sortedKeys = Object.keys(props).sort();
                            var po = "<small><table>";
                            for (var i = 0; i < sortedKeys.length; i++) {
                                var value = props[sortedKeys[i]];
                                if (value !== undefined) {
                                    var fval = value.Value;
                                    if (fval.length > 15) {
                                        fval = fval.replace(/[,]/g, ",<br/>&nbsp;&nbsp;");
                                    }
                                    po += "<tr><td valign='top'>" + sortedKeys[i] + "</td><td>" + fval + "</td></tr>";
                                }
                            }
                            var regBID = data[svcId].BundleIdentifier;
                            po += "<tr><td>Registered&nbsp;by</td><td>Bundle " + regBID + " <div class='less-big label'>" + $scope.bundles[regBID].SymbolicName
                                + "</div></td></tr>";
                            po += "</table></small>";
                            if (regEl !== undefined && regEl !== null) {
                                regEl.innerText = " " + formatServiceName(data[svcId].objectClass);
                                $(regEl).popover({ title: "service properties", content: po, trigger: "hover", html: true });
                            }
                            if (usesEl !== undefined && usesEl !== null) {
                                usesEl.innerText = " " + formatServiceName(data[svcId].objectClass);
                                $(usesEl).popover({ title: "service properties", content: po, trigger: "hover", html: true });
                            }
                        };
                    }(id, reg, uses)));
                }
            }
            function updateTableContents() {
                //console.log("Loading the bundles");
                var mbean = Osgi.getSelectionBundleMBean(workspace);
                if (mbean) {
                    jolokia.request({ type: 'exec', mbean: mbean, operation: 'listBundles()' }, Core.onSuccess(populateTable));
                }
            }
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.ConfigurationsController", ["$scope", "$routeParams", "$location", "workspace", "jolokia",
        "$uibModal", function ($scope, $routeParams, $location, workspace, jolokia, $uibModal) {
            $scope.configurations = null;
            $scope.filteredConfigurations = [];
            /** the kinds of config */
            var configKinds = {
                factory: {
                    class: "fa fa-cubes",
                    title: "Configuration factory used to create separate instances of the configuration"
                },
                pid: {
                    class: "fa fa-check list-view-pf-icon-success",
                    title: "Configuration which has a set of properties associated with it"
                },
                pidNoValue: {
                    class: "fa fa-exclamation list-view-pf-icon-warning",
                    title: "Configuration which does not yet have any bound values"
                }
            };
            $scope.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'name',
                            title: 'Name',
                            placeholder: 'Filter by name...',
                            filterType: 'text'
                        },
                        {
                            id: 'description',
                            title: 'Description',
                            placeholder: 'Filter by description...',
                            filterType: 'text'
                        }
                    ],
                    resultsCount: 0,
                    totalCount: 0,
                    appliedFilters: [],
                    onFilterChange: function (filters) {
                        applyFilters(filters);
                        updateResultCount();
                    }
                },
                actionsConfig: {
                    primaryActions: [
                        {
                            name: 'Add configuration',
                            actionFn: openAddPidDialog
                        }
                    ]
                }
            };
            $scope.listViewConfig = {
                showSelectBox: false
            };
            $scope.listViewMenuItems = [
                {
                    name: 'Delete',
                    actionFn: function (action, item) {
                        var modalScope = $scope.$new(true);
                        modalScope.item = item;
                        $uibModal.open({
                            templateUrl: 'deletePidDialog.html',
                            scope: modalScope
                        })
                            .result.then(function () {
                            var mbean = Osgi.getSelectionConfigAdminMBean(workspace);
                            if (mbean) {
                                jolokia.request({
                                    type: "exec",
                                    mbean: mbean,
                                    operation: 'delete',
                                    arguments: [item.pid]
                                }, {
                                    success: function (response) {
                                        var i = $scope.configurations.indexOf(item);
                                        $scope.configurations.splice(i, 1);
                                        Core.notification("success", "Successfully deleted pid: " + item.pid);
                                    },
                                    error: function (response) { return Core.notification("error", response.error); }
                                });
                            }
                        })
                            .catch(function () { return undefined; });
                    }
                }
            ];
            function applyFilters(filters) {
                var filteredConfigurations = $scope.configurations;
                filters.forEach(function (filter) {
                    var regExp = new RegExp(filter.value, 'i');
                    if (filter.id === 'name') {
                        filteredConfigurations = filteredConfigurations.filter(function (configuration) { return regExp.test(configuration.name); });
                    }
                    else if (filter.id === 'description') {
                        filteredConfigurations = filteredConfigurations.filter(function (configuration) { return regExp.test(configuration.description); });
                    }
                });
                $scope.filteredConfigurations = filteredConfigurations;
            }
            function updateResultCount() {
                $scope.toolbarConfig.filterConfig.totalCount = $scope.configurations.length;
                $scope.toolbarConfig.filterConfig.resultsCount = $scope.filteredConfigurations.length;
            }
            function openAddPidDialog() {
                $uibModal.open({
                    templateUrl: 'addPidDialog.html',
                    scope: $scope
                })
                    .result.then(function (newPid) {
                    if ($scope.configurations.some(function (c) { return c['pid'] == newPid; })) {
                        Core.notification("error", "pid \"" + newPid + "\" already exists.");
                        return;
                    }
                    var mbean = Osgi.getHawtioConfigAdminMBean(workspace);
                    if (mbean && newPid) {
                        var json = JSON.stringify({});
                        jolokia.execute(mbean, "configAdminUpdate", newPid, json, Core.onSuccess(function (response) {
                            Core.notification("success", "Successfully created pid: " + newPid);
                            updateTableContents();
                        }));
                    }
                })
                    .catch(function () { return undefined; });
            }
            function onConfigPids(response) {
                var pids = {};
                angular.forEach(response, function (row) {
                    var pid = row[0];
                    var bundle = row[1];
                    var config = createPidConfig(pid, bundle);
                    if (!ignorePid(pid)) {
                        config["hasValue"] = true;
                        config["kind"] = configKinds.pid;
                        pids[pid] = config;
                    }
                });
                $scope.pids = pids;
                // lets load the factory pids
                var mbean = Osgi.getSelectionConfigAdminMBean(workspace);
                if (mbean) {
                    jolokia.execute(mbean, 'getConfigurations', '(service.factoryPid=*)', Core.onSuccess(onConfigFactoryPids, errorHandler("Failed to load factory PID configurations: ")));
                }
                loadMetaType();
            }
            /**
             * For each factory PID lets find the underlying PID to use to edit it, then lets make a link between them
             */
            function onConfigFactoryPids(response) {
                var mbean = Osgi.getSelectionConfigAdminMBean(workspace);
                var pids = $scope.pids;
                if (pids && mbean) {
                    angular.forEach(response, function (row) {
                        var pid = row[0];
                        var bundle = row[1];
                        if (pid && !ignorePid(pid)) {
                            var config = pids[pid];
                            if (config) {
                                config["isFactoryInstance"] = true;
                                jolokia.execute(mbean, 'getFactoryPid', pid, Core.onSuccess(function (factoryPid) {
                                    config["factoryPid"] = factoryPid;
                                    config["name"] = Osgi.removeFactoryPidPrefix(pid, factoryPid);
                                    if (factoryPid) {
                                        var factoryConfig = getOrCreatePidConfig(factoryPid, bundle, pids);
                                        if (factoryConfig) {
                                            configureFactoryPidConfig(pid, factoryConfig, config);
                                            if ($scope.inFabricProfile) {
                                                Osgi.getConfigurationProperties(workspace, jolokia, pid, function (configValues) {
                                                    var zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
                                                    if (zkPid) {
                                                        config["name"] = Osgi.removeFactoryPidPrefix(zkPid, factoryPid);
                                                        config["zooKeeperPid"] = zkPid;
                                                        Core.$apply($scope);
                                                    }
                                                });
                                            }
                                            updateConfigurations();
                                        }
                                    }
                                }));
                            }
                        }
                    });
                }
                updateMetaType();
            }
            function onMetaType(response) {
                $scope.metaType = response;
                updateMetaType();
            }
            function updateConfigurations() {
                var configurations = [];
                // add parent configurations to array
                angular.forEach($scope.pids, function (config, pid) {
                    if (!config.isFactoryInstance) {
                        configurations.push(config);
                    }
                });
                // sort configurations by name        
                configurations = _.sortBy(configurations, function (configuration) { return configuration.name.toLowerCase(); });
                var _loop_1 = function (i) {
                    var config_1 = configurations[i];
                    if (config_1.isFactory) {
                        angular.forEach(config_1.children, function (child) {
                            configurations.splice(i + 1, 0, child);
                        });
                    }
                };
                // add children under their parents in array
                for (var i = configurations.length - 1; i > -1; i--) {
                    _loop_1(i);
                }
                // update UI
                $scope.configurations = configurations;
                applyFilters($scope.toolbarConfig.filterConfig.appliedFilters);
                updateResultCount();
                Core.$apply($scope);
            }
            function updateMetaType(lazilyCreateConfigs) {
                if (lazilyCreateConfigs === void 0) { lazilyCreateConfigs = true; }
                var metaType = $scope.metaType;
                if (metaType) {
                    var pidMetadata = Osgi.configuration.pidMetadata;
                    var pids = $scope.pids || {};
                    angular.forEach(metaType.pids, function (value, pid) {
                        var bundle = null;
                        var config = lazilyCreateConfigs ? getOrCreatePidConfig(pid, bundle) : pids[pid];
                        if (config) {
                            var factoryPidBundleIds = value.factoryPidBundleIds;
                            if (factoryPidBundleIds && factoryPidBundleIds.length) {
                                setFactoryPid(config);
                            }
                            config["name"] = Core.pathGet(pidMetadata, [pid, "name"]) || trimUnnecessaryPrefixes(value.name) || pid;
                            var description = Core.pathGet(pidMetadata, [pid, "description"]) || value.description;
                            /*
                                        if (description) {
                                          description = description + "\n" + pidBundleDescription(pid, config.bundle);
                                        }
                            */
                            config["description"] = description;
                        }
                    });
                }
                updateConfigurations();
            }
            function loadMetaType() {
                if ($scope.pids) {
                    if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                        jolokia.execute($scope.profileMetadataMBean, "metaTypeSummary", $scope.versionId, $scope.profileId, Core.onSuccess(onMetaType));
                    }
                    else {
                        var metaTypeMBean = Osgi.getMetaTypeMBean(workspace);
                        if (metaTypeMBean) {
                            jolokia.execute(metaTypeMBean, "metaTypeSummary", Core.onSuccess(onMetaType));
                        }
                    }
                }
            }
            function updateTableContents() {
                $scope.configurations = [];
                if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                    jolokia.execute($scope.profileMetadataMBean, "metaTypeSummary", $scope.versionId, $scope.profileId, Core.onSuccess(onProfileMetaType, { silent: true }));
                }
                else {
                    if (jolokia) {
                        var mbean = Osgi.getSelectionConfigAdminMBean(workspace);
                        if (mbean) {
                            jolokia.execute(mbean, 'getConfigurations', '(service.pid=*)', Core.onSuccess(onConfigPids, errorHandler("Failed to load PID configurations: ")));
                        }
                    }
                }
            }
            function onProfileMetaType(response) {
                var metaType = response;
                if (metaType) {
                    var pids = {};
                    angular.forEach(metaType.pids, function (value, pid) {
                        if (value && !ignorePid(pid)) {
                            // TODO we don't have a bundle ID
                            var bundle = "mvn:" + pid;
                            var config = {
                                pid: pid,
                                name: value.name,
                                class: 'pid',
                                description: value.description,
                                bundle: bundle,
                                kind: configKinds.pid,
                                pidLink: createPidLink(pid)
                            };
                            pids[pid] = config;
                        }
                    });
                    angular.forEach(pids, function (config, pid) {
                        var idx = pid.indexOf('-');
                        if (idx > 0) {
                            var factoryPid = pid.substring(0, idx);
                            var name = pid.substring(idx + 1, pid.length);
                            var factoryConfig = pids[factoryPid];
                            if (!factoryConfig) {
                                var bundle = config['bundle'];
                                factoryConfig = getOrCreatePidConfig(factoryPid, bundle, pids);
                            }
                            if (factoryConfig) {
                                configureFactoryPidConfig(pid, factoryConfig, config, factoryPid);
                                config['name'] = name;
                                pids[factoryPid] = factoryConfig;
                                // lets remove the pid instance as its now a child of the factory
                                delete pids[pid];
                            }
                        }
                    });
                    $scope.pids = pids;
                }
                // now lets process the response and replicate the getConfigurations / getProperties API
                // calls on the OSGi API
                // to get the tree of factory pids or pids
                $scope.metaType = metaType;
                updateMetaType(false);
            }
            function trimUnnecessaryPrefixes(name) {
                angular.forEach(["Fabric8 ", "Apache "], function (prefix) {
                    if (name && _.startsWith(name, prefix) && name.length > prefix.length) {
                        name = name.substring(prefix.length);
                    }
                });
                return name;
            }
            function pidBundleDescription(pid, bundle) {
                var pidMetadata = Osgi.configuration.pidMetadata;
                return Core.pathGet(pidMetadata, [pid, "description"]) || "pid: " + pid + "\nbundle: " + bundle;
            }
            function createPidConfig(pid, bundle) {
                var pidMetadata = Osgi.configuration.pidMetadata;
                var config = {
                    pid: pid,
                    name: Core.pathGet(pidMetadata, [pid, "name"]) || pid,
                    class: 'pid',
                    description: Core.pathGet(pidMetadata, [pid, "description"]) || pidBundleDescription(pid, bundle),
                    bundle: bundle,
                    kind: configKinds.pidNoValue,
                    pidLink: createPidLink(pid)
                };
                return config;
            }
            function ignorePid(pid) {
                var answer = false;
                angular.forEach(Osgi.configuration.ignorePids, function (pattern) {
                    if (_.startsWith(pid, pattern)) {
                        answer = true;
                    }
                });
                return answer;
            }
            function getOrCreatePidConfig(pid, bundle, pids) {
                if (pids === void 0) { pids = null; }
                if (ignorePid(pid)) {
                    Osgi.log.info("ignoring pid " + pid);
                    return null;
                }
                else {
                    if (!pids) {
                        pids = $scope.pids;
                    }
                    var factoryConfig = pids[pid];
                    if (!factoryConfig) {
                        factoryConfig = createPidConfig(pid, bundle);
                        pids[pid] = factoryConfig;
                        updateConfigurations();
                    }
                    return factoryConfig;
                }
            }
            function configureFactoryPidConfig(pid, factoryConfig, config, factoryPid) {
                if (factoryPid === void 0) { factoryPid = null; }
                setFactoryPid(factoryConfig, factoryPid, pid);
                //config["pidLink"] = createPidLink(pid, factoryPid);
                var children = factoryConfig.children;
                if (factoryPid) {
                    factoryConfig.pidLink = createPidLink(factoryPid, true);
                }
                if (!children) {
                    children = {};
                    factoryConfig["children"] = children;
                }
                children[pid] = config;
            }
            function setFactoryPid(factoryConfig, factoryPid, pid) {
                if (factoryPid === void 0) { factoryPid = null; }
                if (pid === void 0) { pid = null; }
                factoryConfig["isFactory"] = true;
                factoryConfig["class"] = "factoryPid";
                factoryConfig["kind"] = configKinds.factory;
                if (!factoryPid) {
                    factoryPid = factoryConfig["factoryPid"] || "";
                }
                if (!pid) {
                    pid = factoryConfig["pid"] || "";
                }
                if (!factoryPid) {
                    factoryPid = pid;
                    pid = null;
                }
                factoryConfig["pidLink"] = createPidLink(factoryPid);
            }
            function createPidLink(pid, isFactory) {
                if (isFactory === void 0) { isFactory = false; }
                return Osgi.createConfigPidLink($scope, workspace, pid, isFactory);
            }
            function errorHandler(message) {
                return {
                    error: function (response) {
                        Core.notification("error", message + response['error'] || response);
                        Core.defaultJolokiaErrorHandler(response);
                    }
                };
            }
            $scope.goTo = function (pidLink) {
                $location.path(pidLink);
            };
            // load the data
            updateTableContents();
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.FrameworkController", ["$scope", "workspace", function ($scope, workspace) {
            var showNotification;
            $scope.save = function () {
                if (parseInt($scope.config.startLevel) < parseInt($scope.config.initialBundleStartLevel)) {
                    Core.notification("error", "Can't set Framework Start Level below Initial Bundle Start Level");
                }
                else {
                    var mbean = Osgi.getSelectionFrameworkMBean(workspace);
                    if (mbean) {
                        showNotification = true;
                        workspace.jolokia.request([
                            { type: 'write', mbean: mbean, attribute: 'FrameworkStartLevel', value: $scope.config.startLevel },
                            { type: 'write', mbean: mbean, attribute: 'InitialBundleStartLevel', value: $scope.config.initialBundleStartLevel }
                        ], {
                            error: function (response) {
                                if (showNotification) {
                                    Core.notification("error", response.error);
                                    showNotification = false;
                                }
                            },
                            success: function (response) {
                                if (showNotification) {
                                    Core.notification("success", "Configuration updated");
                                    showNotification = false;
                                }
                            }
                        });
                    }
                }
            };
            function updateContents() {
                var mbean = Osgi.getSelectionFrameworkMBean(workspace);
                if (mbean) {
                    var jolokia = workspace.jolokia;
                    jolokia.request({ type: 'read', mbean: mbean }, { success: function (response) {
                            $scope.config = {
                                startLevel: response.value.FrameworkStartLevel,
                                initialBundleStartLevel: response.value.InitialBundleStartLevel
                            };
                            Core.$apply($scope);
                        }
                    });
                }
            }
            updateContents();
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.configuration = {
        // extra metadata per config admin PID
        pidMetadata: {
            "io.fabric8.container.java": {
                name: "Java Container"
            },
            "io.fabric8.container.process": {
                name: "Process Container"
            },
            "io.fabric8.container.process.overlay.resources": {
                name: "Container Overlay Resources",
                description: "The resources overlaid over the distribution of the process",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.dosgi": {
                name: "Fabric8 DOSGi",
                description: "The configuration for the Distributed OSGi implementation in Fabric8"
            },
            "io.fabric8.environment": {
                name: "Environment Variables",
                description: "The operating system Environment Variables which are exported into any child processes",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.fab.osgi.url": {
                name: "FAB URL",
                description: "Configures the 'fab:' URL handler for deploying JARs as bundles"
            },
            "io.fabric8.mq.fabric.server": {
                name: "ActiveMQ Broker",
                description: "The configuration of the Apache ActiveMQ server configured via the fabric"
            },
            "io.fabric8.openshift": {
                name: "OpenShift"
            },
            "io.fabric8.ports": {
                name: "Ports",
                description: "The network ports exported by the container",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.system": {
                name: "System Properties",
                description: "The Java System Properties which are exported into any child Java processes",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "io.fabric8.version": {
                name: "Versions",
                schemaExtensions: {
                    disableHumanizeLabel: true
                }
            },
            "org.ops4j.pax.logging": {
                name: "Logging",
                description: "The configuration of the logging subsystem"
            },
            "org.ops4j.pax.url.mvn": {
                name: "Maven URL",
                description: "Configures the Maven 'mvn:' URL handler for referencing maven artifacts"
            },
            "org.ops4j.pax.url.war": {
                name: "WAR URL",
                description: "Configures the 'war:' URL handler for referencing WAR deployments"
            },
            "org.ops4j.pax.url.wrap": {
                name: "Wrap URL",
                description: "Configures the 'wrap:' URL handler for wrapping JARs as bundles"
            }
        },
        // pids to ignore from the config UI
        ignorePids: [
            "jmx.acl",
            "io.fabric8.agent",
            "io.fabric8.git",
            "io.fabric8.mq.fabric.template",
            "io.fabric8.openshift.agent",
            "io.fabric8.service.ZkDataStoreImpl",
            "org.apache.felix.fileinstall",
            "org.apache.karaf.command.acl.",
            "org.apache.karaf.service.acl."
        ],
        // UI tabs
        tabs: {
            "fabric8": {
                label: "Fabric8",
                description: "Configuration options for the Fabric8 services",
                pids: ["io.fabric8"]
            },
            "karaf": {
                label: "Karaf",
                description: "Configuration options for the Apache Karaf container and subsystem",
                pids: ["org.apache.karaf"]
            }
        }
    };
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.TopLevelController = Osgi._module.controller("Osgi.TopLevelController", ["$scope", "workspace", function ($scope, workspace) {
            $scope.frameworkMBean = Osgi.getSelectionFrameworkMBean(workspace);
            $scope.bundleMBean = Osgi.getSelectionBundleMBean(workspace);
            $scope.serviceMBean = Osgi.getSelectionServiceMBean(workspace);
            $scope.packageMBean = Osgi.getSelectionPackageMBean(workspace);
            $scope.configAdminMBean = Osgi.getSelectionConfigAdminMBean(workspace);
            $scope.metaTypeMBean = Osgi.getMetaTypeMBean(workspace);
            $scope.osgiToolsMBean = Osgi.getHawtioOSGiToolsMBean(workspace);
            $scope.hawtioConfigAdminMBean = Osgi.getHawtioConfigAdminMBean(workspace);
            $scope.scrMBean = Karaf.getSelectionScrMBean(workspace);
            $scope.featuresMBean = Karaf.getSelectionFeaturesMBean(workspace);
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.PackagesController = Osgi._module.controller("Osgi.PackagesController", ["$scope", "workspace", function ($scope, workspace) {
            var INFINITE_SCROLL_INITIAL_SIZE = 50;
            var INFINITE_SCROLL_APPEND_SIZE = 10;
            $scope.packages = null;
            $scope.filteredPackages = [];
            $scope.scrollablePackages = [];
            $scope.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'name',
                            title: 'Name',
                            placeholder: 'Filter by name...',
                            filterType: 'text'
                        },
                        {
                            id: 'version',
                            title: 'Version',
                            placeholder: 'Filter by version...',
                            filterType: 'text'
                        },
                        {
                            id: 'exporting-bundle',
                            title: 'Exporting Bundle',
                            placeholder: 'Filter by exporting bundle...',
                            filterType: 'text'
                        },
                        {
                            id: 'importing-bundle',
                            title: 'Importing Bundle',
                            placeholder: 'Filter by importing bundle...',
                            filterType: 'text'
                        }
                    ],
                    resultsCount: 0,
                    totalCount: 0,
                    appliedFilters: [],
                    onFilterChange: filterChange
                }
            };
            $scope.appendItems = function () {
                var numRemainingItems = $scope.filteredPackages.length - $scope.scrollablePackages.length;
                if (numRemainingItems > 0) {
                    var startIndex = $scope.scrollablePackages.length;
                    var appendItems = $scope.filteredPackages.slice(startIndex, startIndex + INFINITE_SCROLL_APPEND_SIZE);
                    (_a = $scope.scrollablePackages).push.apply(_a, appendItems);
                }
                var _a;
            };
            function populateTable(response) {
                var packages = Osgi.defaultPackageValues(workspace, $scope, response.value);
                augmentPackagesInfo(packages);
            }
            function augmentPackagesInfo(packages) {
                var bundleMap = {};
                var createBundleMap = function (response) {
                    angular.forEach(response.value, function (value, key) {
                        var obj = {
                            Identifier: value.Identifier,
                            Name: "",
                            SymbolicName: value.SymbolicName,
                            State: value.State,
                            Version: value.Version,
                            LastModified: value.LastModified,
                            Location: value.Location,
                            Url: Core.url("/osgi/bundle/" + value.Identifier + workspace.hash())
                        };
                        if (value.Headers['Bundle-Name']) {
                            obj.Name = value.Headers['Bundle-Name']['Value'];
                        }
                        bundleMap[obj.Identifier] = obj;
                    });
                    angular.forEach(packages, function (p, key) {
                        angular.forEach(p["ExportingBundles"], function (b, key) {
                            p["ExportingBundles"][key] = bundleMap[b];
                        });
                        angular.forEach(p["ImportingBundles"], function (b, key) {
                            p["ImportingBundles"][key] = bundleMap[b];
                        });
                        p["ExportingBundles"].sort(sortBy('SymbolicName'));
                        p["ImportingBundles"].sort(sortBy('SymbolicName'));
                    });
                    packages.sort(sortBy('Name'));
                    $scope.packages = packages;
                    $scope.toolbarConfig.filterConfig.totalCount = packages.length;
                    applyFilters($scope.toolbarConfig.filterConfig.appliedFilters);
                    updateResultCount();
                    initScrollableItems();
                    Core.$apply($scope);
                };
                workspace.jolokia.request({
                    type: 'exec',
                    mbean: Osgi.getSelectionBundleMBean(workspace),
                    operation: 'listBundles()'
                }, {
                    success: createBundleMap,
                    error: createBundleMap
                });
            }
            function sortBy(fieldName) {
                return function (a, b) {
                    var valueA = a[fieldName].toLowerCase();
                    var valueB = b[fieldName].toLowerCase();
                    if (valueA < valueB) {
                        return -1;
                    }
                    if (valueA > valueB) {
                        return 1;
                    }
                    return 0;
                };
            }
            function filterChange(filters) {
                applyFilters(filters);
                updateResultCount();
                initScrollableItems();
            }
            function applyFilters(filters) {
                var filteredPackages = $scope.packages;
                filters.forEach(function (filter) {
                    var regExp = new RegExp(filter.value, 'i');
                    if (filter.id === 'name') {
                        filteredPackages = filteredPackages.filter(function (package) { return regExp.test(package.Name); });
                    }
                    else if (filter.id === 'version') {
                        filteredPackages = filteredPackages.filter(function (package) { return regExp.test(package.Version); });
                    }
                    else if (filter.id === 'exporting-bundle') {
                        filteredPackages = filteredPackages.filter(function (package) { return package.ExportingBundles.some(function (bundle) { return regExp.test(bundle.SymbolicName); }); });
                    }
                    else if (filter.id === 'importing-bundle') {
                        filteredPackages = filteredPackages.filter(function (package) { return package.ImportingBundles.some(function (bundle) { return regExp.test(bundle.SymbolicName); }); });
                    }
                });
                $scope.filteredPackages = filteredPackages;
            }
            function updateResultCount() {
                $scope.toolbarConfig.filterConfig.resultsCount = $scope.filteredPackages.length;
            }
            function initScrollableItems() {
                $scope.scrollablePackages = $scope.filteredPackages.slice(0, INFINITE_SCROLL_INITIAL_SIZE);
            }
            function loadTableContents() {
                var mbean = Osgi.getSelectionPackageMBean(workspace);
                if (mbean) {
                    var jolokia = workspace.jolokia;
                    // bundles first:
                    jolokia.request({
                        type: 'exec',
                        mbean: mbean,
                        operation: 'listPackages'
                    }, {
                        success: populateTable,
                        error: function (response) {
                            Osgi.log.debug('Osgi.PackagesController.loadTableContents() failed: ' + response.error);
                        }
                    });
                }
            }
            loadTableContents();
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
/// <reference path="metadata.ts"/>
var Osgi;
(function (Osgi) {
    Osgi._module.controller("Osgi.PidController", ["$scope", "$timeout", "$routeParams", "$location", "workspace", "jolokia", "$uibModal", function ($scope, $timeout, $routeParams, $location, workspace, jolokia, $uibModal) {
            var uibModalInstance = null;
            $scope.configurationUrl = Core.url('/osgi/configurations' + workspace.hash());
            $scope.factoryPid = $routeParams['factoryPid'];
            $scope.pid = $routeParams['pid'];
            $scope.createForm = {
                pidInstanceName: null
            };
            $scope.newPid = $scope.factoryPid && !$scope.pid;
            if ($scope.newPid) {
                $scope.editMode = true;
            }
            if ($scope.pid && !$scope.factoryPid) {
                var idx = $scope.pid.indexOf("-");
                if (idx > 0) {
                    $scope.factoryPid = $scope.pid.substring(0, idx);
                    $scope.factoryInstanceName = $scope.pid.substring(idx + 1, $scope.pid.length);
                }
            }
            $scope.selectValues = {};
            $scope.modelLoaded = false;
            $scope.canSave = false;
            var addPropertyAction = {
                name: 'Add property',
                actionFn: function (action) {
                    uibModalInstance = $uibModal.open({
                        templateUrl: 'addPropertyDialog.html',
                        scope: $scope
                    });
                }
            };
            var editPropertiesAction = {
                name: 'Edit properties',
                actionFn: function (action) {
                    if (Object.keys($scope.entity).length > 0) {
                        $scope.editMode = true;
                    }
                },
                isDisabled: true
            };
            $scope.toolbarConfig = {
                actionsConfig: {
                    primaryActions: [
                        addPropertyAction,
                        editPropertiesAction
                    ]
                }
            };
            var startInEditMode = $scope.factoryPid && !$routeParams['pid'];
            $scope.editMode = startInEditMode;
            $scope.$on("hawtio.form.modelChange", function () {
                if ($scope.modelLoaded) {
                    // TODO lets check if we've really changed the values!
                    enableCanSave();
                    Core.$apply($scope);
                }
            });
            function updatePid(mbean, pid, data) {
                var completeFn = function (response) {
                    Core.notification("success", "Successfully updated pid: " + pid);
                    if (pid && $scope.factoryPid && $scope.newPid) {
                        // we've just created a new pid so lets move to the full pid URL
                        var newPath = Osgi.createConfigPidPath($scope, pid);
                        $location.path(newPath);
                    }
                    else {
                        $scope.editMode = false;
                        $scope.canSave = false;
                        $scope.saved = true;
                    }
                };
                var callback = Core.onSuccess(completeFn, errorHandler("Failed to update: " + pid));
                var json = JSON.stringify(data);
                jolokia.execute(mbean, "configAdminUpdate", pid, json, callback);
            }
            $scope.pidSave = function () {
                var data = {};
                angular.forEach($scope.entity, function (value, key) {
                    var text = undefined;
                    if (angular.isString(value)) {
                        text = value;
                    }
                    else if (angular.isDefined(value)) {
                        text = value.toString();
                    }
                    if (angular.isDefined(text)) {
                        data[decodeKey(key, $scope.pid)] = text;
                    }
                });
                //log.info("about to update value " + angular.toJson(data));
                var mbean = Osgi.getHawtioConfigAdminMBean(workspace);
                if (mbean || $scope.inFabricProfile) {
                    var pidMBean = Osgi.getSelectionConfigAdminMBean(workspace);
                    var pid = $scope.pid;
                    var zkPid = $scope.zkPid;
                    var factoryPid = $scope.factoryPid;
                    if (!$scope.inFabricProfile && factoryPid && pidMBean && !zkPid) {
                        // lets generate a new pid
                        jolokia.execute(pidMBean, "createFactoryConfiguration", factoryPid, Core.onSuccess(function (response) {
                            pid = response;
                            if (pid) {
                                updatePid(mbean, pid, data);
                            }
                        }, errorHandler("Failed to create new PID: ")));
                    }
                    else {
                        if ($scope.newPid) {
                            var pidInstanceName = $scope.createForm.pidInstanceName;
                            if (!pidInstanceName || !factoryPid) {
                                return;
                            }
                            pid = factoryPid + "-" + pidInstanceName;
                        }
                        else if (zkPid) {
                            pid = zkPid;
                        }
                        updatePid(mbean, pid, data);
                    }
                }
                $scope.editMode = false;
            };
            $scope.cancelSave = function () {
                updateSchema();
                $scope.editMode = false;
            };
            function errorHandler(message) {
                return {
                    error: function (response) {
                        Core.notification("error", message + "\n" + response['error'] || response);
                        Core.defaultJolokiaErrorHandler(response);
                    }
                };
            }
            function enableCanSave() {
                if ($scope.editMode) {
                    $scope.canSave = true;
                }
            }
            $scope.openAddPropertyDialog = function () {
                uibModalInstance = $uibModal.open({
                    templateUrl: 'addPropertyDialog.html',
                    scope: $scope
                });
            };
            $scope.addPropertyConfirmed = function (key, value) {
                uibModalInstance.close();
                $scope.configValues[key] = {
                    Key: key,
                    Value: value,
                    Type: "String"
                };
                updateSchema();
                $scope.pidSave();
            };
            $scope.deletePidProp = function (e) {
                $scope.deleteKey = e.Key;
                uibModalInstance = $uibModal.open({
                    templateUrl: 'deletePropDialog.html',
                    scope: $scope
                });
            };
            $scope.deletePidPropConfirmed = function () {
                uibModalInstance.close();
                var cell = document.getElementById("pid." + $scope.deleteKey);
                cell.parentElement.remove();
                enableCanSave();
            };
            $scope.goToConfigurationsPage = function () { return $location.path('/osgi/configurations'); };
            function populateTable(response) {
                $scope.modelLoaded = true;
                var configValues = response || {};
                $scope.configValues = configValues;
                $scope.zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
                if ($scope.zkPid && $scope.saved) {
                    // lets load the current properties direct from git
                    // in case we have just saved them into git and config admin hasn't yet
                    // quite caught up yet (to avoid freaking the user out that things look like
                    // changes got reverted ;)
                    function onProfileProperties(gitProperties) {
                        angular.forEach(gitProperties, function (value, key) {
                            var configProperty = configValues[key];
                            if (configProperty) {
                                configProperty.Value = value;
                            }
                        });
                        updateSchemaAndLoadMetaType();
                        Core.$apply($scope);
                    }
                }
                else {
                    updateSchemaAndLoadMetaType();
                }
            }
            function updateSchemaAndLoadMetaType() {
                updateSchema();
                var configValues = $scope.configValues;
                if (configValues) {
                    if ($scope.profileNotRunning && $scope.profileMetadataMBean && $scope.versionId && $scope.profileId) {
                        var pid = $scope.factoryPid || $scope.pid;
                        jolokia.execute($scope.profileMetadataMBean, "getPidMetaTypeObject", $scope.versionId, $scope.profileId, pid, Core.onSuccess(onMetaType));
                    }
                    else {
                        var locale = null;
                        var pid = null;
                        var factoryId = configValues["service.factoryPid"];
                        if (factoryId && !pid) {
                            pid = factoryId["Value"];
                        }
                        var metaTypeMBean = Osgi.getMetaTypeMBean(workspace);
                        if (metaTypeMBean) {
                            jolokia.execute(metaTypeMBean, "getPidMetaTypeObject", pid, locale, Core.onSuccess(onMetaType));
                        }
                    }
                }
                Core.$apply($scope);
            }
            function onMetaType(response) {
                $scope.metaType = response;
                updateSchema();
                Core.$apply($scope);
            }
            /**
             * Updates the JSON schema model
             */
            function updateSchema() {
                var properties = {};
                var required = [];
                $scope.defaultValues = {};
                var schema = {
                    type: "object",
                    required: required,
                    properties: properties
                };
                var inputClass = "form-control";
                var labelClass = "col-sm-2 control-label";
                //var inputClassArray = "span11";
                var inputClassArray = "";
                var labelClassArray = labelClass;
                var metaType = $scope.metaType;
                if (metaType) {
                    var pidMetadata = Osgi.configuration.pidMetadata;
                    var pid = metaType.id;
                    schema["id"] = pid;
                    schema["name"] = Core.pathGet(pidMetadata, [pid, "name"]) || metaType.name;
                    schema["description"] = Core.pathGet(pidMetadata, [pid, "description"]) || metaType.description;
                    var disableHumanizeLabel = Core.pathGet(pidMetadata, [pid, "schemaExtensions", "disableHumanizeLabel"]);
                    angular.forEach(metaType.attributes, function (attribute) {
                        var id = attribute.id;
                        if (isValidProperty(id)) {
                            var key = encodeKey(id, pid);
                            var typeName = asJsonSchemaType(attribute.typeName, attribute.id);
                            var attributeProperties = {
                                title: attribute.name,
                                tooltip: attribute.description,
                                'input-attributes': {
                                    class: inputClass
                                },
                                'label-attributes': {
                                    class: labelClass
                                },
                                type: typeName
                            };
                            if (disableHumanizeLabel) {
                                attributeProperties.title = id;
                            }
                            if (attribute.typeName === "char") {
                                attributeProperties["maxLength"] = 1;
                                attributeProperties["minLength"] = 1;
                            }
                            var cardinality = attribute.cardinality;
                            if (cardinality) {
                                // lets clear the span on arrays to fix layout issues
                                attributeProperties['input-attributes']['class'] = null;
                                attributeProperties.type = "array";
                                attributeProperties["items"] = {
                                    'input-attributes': {
                                        class: inputClassArray
                                    },
                                    'label-attributes': {
                                        class: labelClassArray
                                    },
                                    "type": typeName
                                };
                            }
                            if (attribute.required) {
                                required.push(id);
                            }
                            var defaultValue = attribute.defaultValue;
                            if (defaultValue) {
                                if (angular.isArray(defaultValue) && defaultValue.length === 1) {
                                    defaultValue = defaultValue[0];
                                }
                                //attributeProperties["default"] = defaultValue;
                                // TODO convert to boolean / number?
                                $scope.defaultValues[key] = defaultValue;
                            }
                            var optionLabels = attribute.optionLabels;
                            var optionValues = attribute.optionValues;
                            if (optionLabels && optionLabels.length && optionValues && optionValues.length) {
                                var enumObject = {};
                                for (var i = 0; i < optionLabels.length; i++) {
                                    var label = optionLabels[i];
                                    var value = optionValues[i];
                                    enumObject[value] = label;
                                }
                                $scope.selectValues[key] = enumObject;
                                Core.pathSet(attributeProperties, ['input-element'], "select");
                                Core.pathSet(attributeProperties, ['input-attributes', "ng-options"], "key as value for (key, value) in selectValues." + key);
                            }
                            properties[key] = attributeProperties;
                        }
                    });
                    // now lets override anything from the custom metadata
                    var schemaExtensions = Core.pathGet(Osgi.configuration.pidMetadata, [pid, "schemaExtensions"]);
                    if (schemaExtensions) {
                        // now lets copy over the schema extensions
                        overlayProperties(schema, schemaExtensions);
                    }
                }
                // now add all the missing properties...
                var entity = {};
                angular.forEach($scope.configValues, function (value, rawKey) {
                    if (isValidProperty(rawKey)) {
                        var key = encodeKey(rawKey, pid);
                        var attrValue = value;
                        var attrType = "string";
                        if (angular.isObject(value)) {
                            attrValue = value.Value;
                            attrType = asJsonSchemaType(value.Type, rawKey);
                        }
                        var property = properties[key];
                        if (!property) {
                            property = {
                                'input-attributes': {
                                    class: inputClass
                                },
                                'label-attributes': {
                                    class: labelClass
                                },
                                type: attrType
                            };
                            properties[key] = property;
                            if (rawKey == 'org.osgi.service.http.port') {
                                properties[key]['input-attributes']['disabled'] = 'disabled';
                                properties[key]['input-attributes']['title'] = 'Changing port of OSGi http service is not possible from Hawtio';
                            }
                        }
                        else {
                            var propertyType = property["type"];
                            if ("array" === propertyType) {
                                if (!angular.isArray(attrValue)) {
                                    attrValue = attrValue ? attrValue.split(",") : [];
                                }
                            }
                        }
                        if (disableHumanizeLabel) {
                            property.title = rawKey;
                        }
                        //comply with Forms.safeIdentifier in 'forms/js/formHelpers.ts'
                        key = key.replace(/-/g, "_");
                        entity[key] = attrValue;
                    }
                });
                // add default values for missing values
                angular.forEach($scope.defaultValues, function (value, key) {
                    var current = entity[key];
                    if (!angular.isDefined(current)) {
                        //log.info("updating entity " + key + " with default: " + value + " as was: " + current);
                        entity[key] = value;
                    }
                });
                editPropertiesAction.isDisabled = Object.keys(entity).length === 0;
                //log.info("default values: " + angular.toJson($scope.defaultValues));
                $scope.entity = entity;
                $scope.schema = schema;
                $scope.fullSchema = schema;
            }
            /**
             * Recursively overlays the properties in the overlay into the object; so any atttributes are added into the object
             * and any nested objects in the overlay are inserted into the object at the correct path.
             */
            function overlayProperties(object, overlay) {
                if (angular.isObject(object)) {
                    if (angular.isObject(overlay)) {
                        angular.forEach(overlay, function (value, key) {
                            if (angular.isObject(value)) {
                                var child = object[key];
                                if (!child) {
                                    child = {};
                                    object[key] = child;
                                }
                                overlayProperties(child, value);
                            }
                            else {
                                object[key] = value;
                            }
                        });
                    }
                }
            }
            var ignorePropertyIds = ["service.pid", "service.factoryPid", "fabric.zookeeper.pid"];
            function isValidProperty(id) {
                return id && ignorePropertyIds.indexOf(id) < 0;
            }
            function encodeKey(key, pid) {
                return key.replace(/\./g, "__");
            }
            function decodeKey(key, pid) {
                return key.replace(/__/g, ".");
            }
            function asJsonSchemaType(typeName, id) {
                if (typeName) {
                    var lower = typeName.toLowerCase();
                    if (_.startsWith(lower, "int") || lower === "long" || lower === "short" || lower === "byte" || _.endsWith(lower, "int")) {
                        return "integer";
                    }
                    if (lower === "double" || lower === "float" || lower === "bigdecimal") {
                        return "number";
                    }
                    if (lower === "string") {
                        // TODO hack to try force password type on dodgy metadata such as pax web
                        if (id && _.endsWith(id, "password")) {
                            return "password";
                        }
                        return "string";
                    }
                    return typeName;
                }
                else {
                    return "string";
                }
            }
            function onProfilePropertiesLoaded(response) {
                $scope.modelLoaded = true;
                var configValues = {};
                $scope.configValues = configValues;
                angular.forEach(response, function (value, oKey) {
                    // lets remove any dodgy characters
                    var key = oKey.replace(/:/g, '_').replace(/\//g, '_');
                    configValues[key] = {
                        Key: key,
                        Value: value
                    };
                });
                $scope.zkPid = Core.pathGet(configValues, ["fabric.zookeeper.pid", "Value"]);
                updateSchemaAndLoadMetaType();
                Core.$apply($scope);
            }
            function updateTableContents() {
                $scope.modelLoaded = false;
                Osgi.getConfigurationProperties(workspace, jolokia, $scope.pid, populateTable);
            }
            // load initial data
            updateTableContents();
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="osgiHelpers.ts"/>
/// <reference path="osgiPlugin.ts"/>
var Osgi;
(function (Osgi) {
    Osgi.ServiceController = Osgi._module.controller("Osgi.ServiceController", ["$scope", "$filter", "workspace",
        "$templateCache", "$compile", function ($scope, $filter, workspace, $templateCache, $compile) {
            $scope.services = null;
            $scope.filteredServices = [];
            $scope.toolbarConfig = {
                filterConfig: {
                    fields: [
                        {
                            id: 'objectClass',
                            title: 'Object Class',
                            placeholder: 'Filter by object class...',
                            filterType: 'text'
                        },
                        {
                            id: 'bundleId',
                            title: 'Bundle ID',
                            placeholder: 'Filter by bundle ID...',
                            filterType: 'text'
                        },
                        {
                            id: 'usingBundle',
                            title: 'Using Bundle',
                            placeholder: 'Filter by using bundle...',
                            filterType: 'text'
                        }
                    ],
                    resultsCount: 0,
                    totalCount: 0,
                    appliedFilters: [],
                    onFilterChange: function (filters) {
                        applyFilters(filters);
                        updateResultCount();
                    }
                }
            };
            function applyFilters(filters) {
                var filteredServices = $scope.services;
                filters.forEach(function (filter) {
                    var regExp = new RegExp(filter.value, 'i');
                    if (filter.id === 'objectClass') {
                        filteredServices = filteredServices.filter(function (service) { return service.objectClass.some(function (clazz) { return regExp.test(clazz); }); });
                    }
                    else if (filter.id === 'bundleId') {
                        filteredServices = filteredServices.filter(function (service) { return service.BundleIdentifier.toString() === filter.value; });
                    }
                    else if (filter.id === 'usingBundle') {
                        filteredServices = filteredServices.filter(function (service) { return service.UsingBundles.some(function (bundle) { return regExp.test(bundle.SymbolicName); }); });
                    }
                });
                $scope.filteredServices = filteredServices;
            }
            function updateResultCount() {
                $scope.toolbarConfig.filterConfig.resultsCount = $scope.filteredServices.length;
            }
            var populateTable = function (response) {
                var services = Osgi.defaultServiceValues(workspace, $scope, response.value);
                augmentServicesInfo(services);
            };
            function augmentServicesInfo(services) {
                var bundleMap = {};
                var createBundleMap = function (response) {
                    angular.forEach(response.value, function (value, key) {
                        var obj = {
                            Identifier: value.Identifier,
                            Name: "",
                            SymbolicName: value.SymbolicName,
                            State: value.State,
                            Version: value.Version,
                            LastModified: value.LastModified,
                            Location: value.Location,
                            Url: Core.url("/osgi/bundle/" + value.Identifier + workspace.hash())
                        };
                        if (value.Headers['Bundle-Name']) {
                            obj.Name = value.Headers['Bundle-Name']['Value'];
                        }
                        bundleMap[obj.Identifier] = obj;
                    });
                    var servicesArray = [];
                    angular.forEach(services, function (s, key) {
                        s.Url = Core.url("/osgi/bundle/" + s.Identifier + workspace.hash());
                        angular.forEach(s["UsingBundles"], function (b, key) {
                            s["UsingBundles"][key] = bundleMap[b];
                        });
                        servicesArray.push(s);
                    });
                    $scope.services = servicesArray;
                    $scope.toolbarConfig.filterConfig.totalCount = servicesArray.length;
                    applyFilters($scope.toolbarConfig.filterConfig.appliedFilters);
                    updateResultCount();
                    Core.$apply($scope);
                };
                workspace.jolokia.request({
                    type: 'exec',
                    mbean: Osgi.getSelectionBundleMBean(workspace),
                    operation: 'listBundles()'
                }, {
                    success: createBundleMap,
                    error: function (response) {
                        Osgi.log.debug('Osgi.ServiceController.augmentServicesInfo() failed: ' + response.error);
                    }
                });
            }
            function loadServices() {
                var mbean = Osgi.getSelectionServiceMBean(workspace);
                if (mbean) {
                    var jolokia = workspace.jolokia;
                    jolokia.request({
                        type: 'exec',
                        mbean: mbean,
                        operation: 'listServices()'
                    }, {
                        success: populateTable,
                        error: function (response) {
                            Osgi.log.debug('Osgi.ServiceController.loadServices() failed: ' + response.error);
                        }
                    });
                }
            }
            loadServices();
        }]);
})(Osgi || (Osgi = {}));
/// <reference path="../camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.BlockedExchangesController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            var log = Logger.get("Camel");
            $scope.data = [];
            $scope.initDone = false;
            $scope.mbeanAttributes = {};
            var columnDefs = [
                {
                    field: 'exchangeId',
                    displayName: 'Exchange Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'routeId',
                    displayName: 'Route Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'nodeId',
                    displayName: 'Node Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'duration',
                    displayName: 'Duration (ms)',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'threadId',
                    displayName: 'Thread id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'threadName',
                    displayName: 'Thread name',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                }
            ];
            $scope.gridOptions = {
                data: 'data',
                displayFooter: true,
                displaySelectionCheckbox: true,
                multiSelect: false,
                canSelectRows: true,
                enableSorting: true,
                columnDefs: columnDefs,
                selectedItems: [],
                filterOptions: {
                    filterText: ''
                },
                primaryKeyFn: function (entity) { return entity.exchangeId; }
            };
            $scope.doUnblock = function () {
                var mbean = Camel.getSelectionCamelBlockedExchanges(workspace);
                var selectedItems = $scope.gridOptions.selectedItems;
                if (mbean && selectedItems && selectedItems.length === 1) {
                    var exchangeId = selectedItems[0].exchangeId;
                    var threadId = selectedItems[0].threadId;
                    var threadName = selectedItems[0].threadName;
                    log.info("Unblocking thread (" + threadId + "/" + threadName + ") for exchangeId: " + exchangeId);
                    jolokia.execute(mbean, "interrupt(java.lang.String)", exchangeId, Core.onSuccess(onUnblocked));
                }
            };
            function onUnblocked() {
                Core.notification("success", "Thread unblocked");
            }
            function onBlocked(response) {
                var obj = response.value;
                if (obj) {
                    // the JMX tabular data has 1 index so we need to dive 1 levels down to grab the data
                    var arr = [];
                    for (var key in obj) {
                        var entry = obj[key];
                        console.log('blocked: ' + JSON.stringify(entry));
                        arr.push({
                            exchangeId: entry.exchangeId,
                            routeId: entry.routeId,
                            nodeId: entry.nodeId,
                            duration: entry.duration,
                            threadId: entry.id,
                            threadName: entry.name
                        });
                    }
                    arr = _.sortBy(arr, "exchangeId");
                    $scope.data = arr;
                    // okay we have the data then set the selected mbean which allows UI to display data
                    $scope.selectedMBean = response.request.mbean;
                }
                else {
                    // clear data
                    $scope.data = [];
                }
                $scope.initDone = "true";
                // ensure web page is updated
                Core.$apply($scope);
            }
            function loadBlockedData() {
                log.info("Loading blocked exchanges data...");
                // pre-select filter if we have selected a route
                var routeId = Camel.getSelectedRouteId(workspace);
                if (routeId != null) {
                    $scope.gridOptions.filterOptions.filterText = routeId;
                }
                var mbean = Camel.getSelectionCamelBlockedExchanges(workspace);
                if (mbean) {
                    // grab blocked in real time
                    var query = { type: "exec", mbean: mbean, operation: 'browse()' };
                    jolokia.request(query, Core.onSuccess(onBlocked));
                    Core.scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(Core.onSuccess(onBlocked), query));
                }
            }
            // load data
            loadBlockedData();
        }]);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.InflightExchangesController", ["$scope", "$location", "workspace", "jolokia", function ($scope, $location, workspace, jolokia) {
            $scope.data = [];
            $scope.initDone = false;
            $scope.mbeanAttributes = {};
            var columnDefs = [
                {
                    field: 'exchangeId',
                    displayName: 'Exchange Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'routeId',
                    displayName: 'Route Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'nodeId',
                    displayName: 'Node Id',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'duration',
                    displayName: 'Duration (ms)',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                },
                {
                    field: 'elapsed',
                    displayName: 'Elapsed (ms)',
                    cellFilter: null,
                    width: "*",
                    resizable: true
                }
            ];
            $scope.gridOptions = {
                data: 'data',
                displayFooter: true,
                displaySelectionCheckbox: false,
                canSelectRows: false,
                enableSorting: true,
                columnDefs: columnDefs,
                selectedItems: [],
                filterOptions: {
                    filterText: ''
                },
                primaryKeyFn: function (entity) { return entity.exchangeId; }
            };
            function onInflight(response) {
                var obj = response.value;
                if (obj) {
                    // the JMX tabular data has 1 index so we need to dive 1 levels down to grab the data
                    var arr = [];
                    for (var key in obj) {
                        var entry = obj[key];
                        console.log('inflight: ' + JSON.stringify(entry));
                        arr.push({
                            exchangeId: entry.exchangeId,
                            routeId: entry.routeId,
                            nodeId: entry.nodeId,
                            duration: entry.duration,
                            elapsed: entry.elapsed
                        });
                    }
                    arr = _.sortBy(arr, "exchangeId");
                    $scope.data = arr;
                    // okay we have the data then set the selected mbean which allows UI to display data
                    $scope.selectedMBean = response.request.mbean;
                }
                else {
                    // clear data
                    $scope.data = [];
                }
                $scope.initDone = "true";
                // ensure web page is updated
                Core.$apply($scope);
            }
            $scope.renderIcon = function (state) {
                return Camel.iconClass(state);
            };
            function loadData() {
                console.log("Loading inflight data...");
                // pre-select filter if we have selected a route
                var routeId = Camel.getSelectedRouteId(workspace);
                if (routeId != null) {
                    $scope.gridOptions.filterOptions.filterText = routeId;
                }
                var mbean = Camel.getSelectionCamelInflightRepository(workspace);
                if (mbean) {
                    // grab inflight in real time
                    var query = { type: "exec", mbean: mbean, operation: 'browse()' };
                    Core.scopeStoreJolokiaHandle($scope, jolokia, jolokia.register(onInflight, query));
                }
            }
            // load data
            loadData();
        }]);
})(Camel || (Camel = {}));
var Camel;
(function (Camel) {
    var Property = /** @class */ (function () {
        function Property(name, value, description) {
            this.name = name;
            this.value = value;
            this.description = description;
        }
        Property.sortByName = function (a, b) {
            if (a.name < b.name)
                return -1;
            if (a.name > b.name)
                return 1;
            return 0;
        };
        return Property;
    }());
    Camel.Property = Property;
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
/// <reference path="property.ts"/>
var Camel;
(function (Camel) {
    var PropertiesService = /** @class */ (function () {
        function PropertiesService() {
        }
        PropertiesService.prototype.getDefinedProperties = function (schemaProperties) {
            return Object.keys(schemaProperties)
                .filter(function (key) { return schemaProperties[key]['value']; })
                .map(function (key) {
                var propertySchema = schemaProperties[key];
                var name = propertySchema['title'] || key;
                return new Camel.Property(name, propertySchema['value'], propertySchema['description']);
            })
                .sort(Camel.Property.sortByName);
        };
        PropertiesService.prototype.getDefaultProperties = function (schemaProperties) {
            return Object.keys(schemaProperties)
                .filter(function (key) { return !schemaProperties[key]['value']; })
                .filter(function (key) { return 'defaultValue' in schemaProperties[key]; })
                .map(function (key) {
                var propertySchema = schemaProperties[key];
                var name = propertySchema['title'] || key;
                return new Camel.Property(name, propertySchema['defaultValue'], propertySchema['description']);
            })
                .sort(Camel.Property.sortByName);
        };
        PropertiesService.prototype.getUndefinedProperties = function (schemaProperties) {
            return Object.keys(schemaProperties)
                .filter(function (key) { return !schemaProperties[key]['value']; })
                .filter(function (key) { return !('defaultValue' in schemaProperties[key]); })
                .map(function (key) {
                var propertySchema = schemaProperties[key];
                var name = propertySchema['title'] || key;
                return new Camel.Property(name, null, propertySchema['description']);
            })
                .sort(Camel.Property.sortByName);
        };
        return PropertiesService;
    }());
    Camel.PropertiesService = PropertiesService;
    Camel._module.service('propertiesService', PropertiesService);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
/// <reference path="properties.service.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesComponentController", ["$scope", "workspace", "localStorage", "jolokia", "documentBase", 'propertiesService', function ($scope, workspace, localStorage, jolokia, documentBase, propertiesService) {
            var log = Logger.get("Camel");
            function updateData() {
                var contextMBean = Camel.getSelectionCamelContextMBean(workspace);
                var componentMBeanName = null;
                if (!componentMBeanName) {
                    componentMBeanName = workspace.getSelectedMBeanName();
                }
                if (componentMBeanName && contextMBean) {
                    // TODO: grab name from tree instead? avoids a JMX call
                    var reply = jolokia.request({ type: "read", mbean: componentMBeanName, attribute: ["ComponentName"] });
                    var name = reply.value["ComponentName"];
                    if (name) {
                        $scope.componentName = name;
                        log.info("Calling explainComponentJson for name: " + name);
                        var query = {
                            type: 'exec',
                            mbean: contextMBean,
                            operation: 'explainComponentJson(java.lang.String,boolean)',
                            arguments: [name, true]
                        };
                        jolokia.request(query, Core.onSuccess(populateData));
                    }
                }
            }
            function populateData(response) {
                log.debug("Populate data " + response);
                if (response.value) {
                    var schema = JSON.parse(response.value);
                    $scope.icon = UrlHelpers.join(documentBase, "/img/icons/camel/endpoint24.png");
                    $scope.title = schema.component.title;
                    $scope.description = schema.component.description;
                    $scope.labels = schema.component.label ? schema.component.label.split(',') : [];
                    $scope.definedProperties = propertiesService.getDefinedProperties(schema['componentProperties']);
                    $scope.defaultProperties = propertiesService.getDefaultProperties(schema['componentProperties']);
                    $scope.undefinedProperties = propertiesService.getUndefinedProperties(schema['componentProperties']);
                    $scope.viewTemplate = "plugins/camel/html/nodePropertiesView.html";
                    Core.$apply($scope);
                }
            }
            setTimeout(function () {
                $('[data-toggle=tooltip]').tooltip();
            }, 1000);
            updateData();
        }]);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
/// <reference path="properties.service.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesDataFormatController", ["$scope", "workspace", "localStorage", "jolokia", "documentBase", 'propertiesService', function ($scope, workspace, localStorage, jolokia, documentBase, propertiesService) {
            var log = Logger.get("Camel");
            function updateData() {
                var dataFormatMBeanName = null;
                if (!dataFormatMBeanName) {
                    dataFormatMBeanName = workspace.getSelectedMBeanName();
                }
                if (dataFormatMBeanName) {
                    log.info("Calling informationJson");
                    var query = {
                        type: 'exec',
                        mbean: dataFormatMBeanName,
                        operation: 'informationJson'
                    };
                    jolokia.request(query, Core.onSuccess(populateData));
                }
            }
            function populateData(response) {
                log.debug("Populate data " + response);
                if (response.value) {
                    var schema = JSON.parse(response.value);
                    $scope.icon = UrlHelpers.join(documentBase, "/img/icons/camel/marshal24.png");
                    $scope.title = schema.dataformat.title + " (" + schema.dataformat.name + ")";
                    $scope.labels = schema.dataformat.label ? schema.dataformat.label.split(',') : [];
                    $scope.description = schema.dataformat.description;
                    $scope.definedProperties = propertiesService.getDefinedProperties(schema['properties']);
                    $scope.defaultProperties = propertiesService.getDefaultProperties(schema['properties']);
                    $scope.undefinedProperties = propertiesService.getUndefinedProperties(schema['properties']);
                    $scope.viewTemplate = "plugins/camel/html/nodePropertiesView.html";
                    Core.$apply($scope);
                }
            }
            setTimeout(function () {
                $('[data-toggle=tooltip]').tooltip();
            }, 1000);
            updateData();
        }]);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
/// <reference path="properties.service.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesEndpointController", ["$scope", "workspace", "localStorage", "jolokia", "documentBase", 'propertiesService', function ($scope, workspace, localStorage, jolokia, documentBase, propertiesService) {
            var log = Logger.get("Camel");
            function updateData() {
                var contextMBean = Camel.getSelectionCamelContextMBean(workspace);
                var endpointMBean = null;
                if ($scope.contextId && $scope.endpointPath) {
                    var node = workspace.findMBeanWithProperties(Camel.jmxDomain, {
                        context: $scope.contextId,
                        type: "endpoints",
                        name: $scope.endpointPath
                    });
                    if (node) {
                        endpointMBean = node.objectName;
                    }
                }
                if (!endpointMBean) {
                    endpointMBean = workspace.getSelectedMBeanName();
                }
                if (endpointMBean && contextMBean) {
                    // TODO: grab url from tree instead? avoids a JMX call
                    var reply = jolokia.request({ type: "read", mbean: endpointMBean, attribute: ["EndpointUri"] });
                    var url = reply.value["EndpointUri"];
                    if (url) {
                        $scope.endpointUrl = url;
                        log.info("Calling explainEndpointJson for url: " + url);
                        var query = {
                            type: 'exec',
                            mbean: contextMBean,
                            operation: 'explainEndpointJson(java.lang.String,boolean)',
                            arguments: [url, true]
                        };
                        jolokia.request(query, Core.onSuccess(populateData));
                    }
                }
            }
            function populateData(response) {
                log.debug("Populate data " + response);
                if (response.value) {
                    var schema = JSON.parse(response.value);
                    $scope.icon = UrlHelpers.join(documentBase, "/img/icons/camel/endpoint24.png");
                    $scope.title = $scope.endpointUrl;
                    $scope.labels = schema.component.label ? schema.component.label.split(',') : [];
                    $scope.description = schema.component.description;
                    $scope.definedProperties = propertiesService.getDefinedProperties(schema['properties']);
                    $scope.defaultProperties = propertiesService.getDefaultProperties(schema['properties']);
                    $scope.undefinedProperties = propertiesService.getUndefinedProperties(schema['properties']);
                    $scope.viewTemplate = "plugins/camel/html/nodePropertiesView.html";
                    Core.$apply($scope);
                }
            }
            setTimeout(function () {
                $('[data-toggle=tooltip]').tooltip();
            }, 1000);
            updateData();
        }]);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
/// <reference path="properties.service.ts"/>
var Camel;
(function (Camel) {
    Camel._module.controller("Camel.PropertiesRouteController", ["$scope", "$rootScope", "workspace", "localStorage", "jolokia", "propertiesService", function ($scope, $rootScope, workspace, localStorage, jolokia, propertiesService) {
            var log = Logger.get("Camel");
            var routeXmlNode = Camel.getSelectedRouteNode(workspace);
            if (routeXmlNode) {
                var data = Camel.getRouteNodeJSON(routeXmlNode);
                var schema = Camel.getCamelSchema(routeXmlNode.nodeName);
                addValueToProperties(data, schema);
                if (log.enabledFor(Logger.DEBUG)) {
                    log.debug("Properties - data: " + JSON.stringify(data, null, "  "));
                    log.debug("Properties - schema: " + JSON.stringify(schema, null, "  "));
                }
                $scope.icon = Camel.getRouteNodeIcon(routeXmlNode);
                $scope.title = schema.title;
                $scope.labels = schema.group ? schema.group.split(',') : [];
                $scope.description = schema.description;
                $scope.definedProperties = propertiesService.getDefinedProperties(schema['properties']);
                $scope.defaultProperties = propertiesService.getDefaultProperties(schema['properties']);
                $scope.undefinedProperties = propertiesService.getUndefinedProperties(schema['properties']);
                $scope.viewTemplate = "plugins/camel/html/nodePropertiesView.html";
            }
            function addValueToProperties(data, schema) {
                for (var key in data) {
                    var property = schema.properties[key];
                    if (property) {
                        property.value = data[key];
                    }
                }
            }
            setTimeout(function () {
                $('[data-toggle=tooltip]').tooltip();
            }, 1000);
        }]);
})(Camel || (Camel = {}));
/// <reference path="../camelPlugin.ts"/>
var Camel;
(function (Camel) {
    Camel._module.component('propertyList', {
        template: "\n      <div ng-show=\"$ctrl.properties.length > 0\">\n        <h3 title=\"\">{{$ctrl.title}}</h3>\n        <dl class=\"dl-horizontal\">\n          <dt ng-repeat-start=\"property in $ctrl.properties\" title=\"{{property.name}}\">\n            {{property.name}}\n          </dt>\n          <dd class=\"camel-properties-value\" title=\"\" ng-repeat-end>\n            <span class=\"fa fa-info-circle camel-properties-info-circle\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"{{property.description}}\"></span>\n            <samp>{{property.value}}</samp>\n          </dd>\n        </dl>\n      </div>",
        bindings: {
            title: '@',
            properties: '<'
        }
    });
})(Camel || (Camel = {}));

angular.module('hawtio-integration-templates', []).run(['$templateCache', function($templateCache) {$templateCache.put('plugins/activemq/html/browseQueue.html','<div ng-controller="ActiveMQ.BrowseQueueController">\n\n  <h1>Browse Queue</h1>\n\n  <div ng-hide="showMessageDetails">\n    <div class="row toolbar-pf table-view-pf-toolbar">\n      <div class="col-sm-12">\n        <form class="toolbar-pf-actions search-pf">\n          <div class="form-group toolbar-pf-filter has-clear">\n            <div class="search-pf-input-group">\n              <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n              <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                    class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n              <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                <span class="pficon pficon-close"></span>\n              </button>\n            </div>\n          </div>\n          <div class="toolbar-pf-action-right">\n            <div class="form-group">\n              <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length" ng-show="dlq" ng-click="retryMessages()"\n                title="Moves the dead letter queue message back to its original destination so it can be retried" data-placement="bottom">\n                Retry\n              </button>\n              <button class="btn btn-default" ng-disabled="gridOptions.selectedItems.length !== 1" ng-show="showButtons" ng-click="resendMessage()"\n                title="Edit the message to resend it" data-placement="bottom">\n                Resend\n              </button>\n\n              <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length" ng-show="showButtons"\n                ng-click="moveDialog = true"\n                title="Move the selected messages to another destination" data-placement="bottom">\n                Move\n              </button>\n              <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length" ng-show="showButtons"\n                ng-click="deleteDialog = true"\n                title="Delete the selected messages">\n                Delete\n              </button>\n              <button class="btn btn-default" ng-click="refresh()"\n                title="Refreshes the list of messages">\n                <i class="fa fa-refresh"></i>\n              </button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n    <table class="table table-striped table-bordered table-hover activemq-browse-table" hawtio-simple-table="gridOptions"></table>\n  </div>\n\n  <div ng-show="showMessageDetails">\n    <div class="row toolbar-pf">\n      <div class="col-sm-12">\n        <form class="toolbar-pf-actions">\n          <div class="form-group">\n            <button class="btn btn-primary" ng-click="showMessageDetails = false">\n              Back\n            </button>\n          </div>\n\n          <div class="toolbar-pf-action-right">\n            <div class="form-group">\n              <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length" ng-show="showButtons"\n                ng-click="moveDialog = true"\n                title="Move the selected messages to another destination" data-placement="bottom">\n                Move\n              </button>\n              <button class="btn btn-danger" ng-disabled="!gridOptions.selectedItems.length" ng-show="showButtons"\n                ng-click="deleteDialog = true"\n                title="Delete the selected messages">\n                Delete\n              </button>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n\n    <div hawtio-pager="messages" on-index-change="selectRowIndex" row-index="rowIndex"></div>\n\n    <div class="expandable closed">\n      <div title="Headers" class="title">\n        <h3><i class="expandable-indicator"></i> Headers & Properties</h3>\n      </div>\n      <div class="expandable-body well">\n        <table class="table table-condensed table-striped table-bordered table-hover">\n          <thead>\n            <tr>\n              <th>Header</th>\n              <th>Value</th>\n            </tr>\n          </thead>\n          <tbody compile="row.headerHtml"></tbody>\n        </table>\n      </div>\n    </div>\n\n    <h3>Displaying body as <span ng-bind="row.textMode"></span></h3>\n    <div hawtio-editor="row.bodyText" read-only="true" mode=\'mode\'></div>\n\n  </div>\n\n  <div hawtio-confirm-dialog="deleteDialog" title="Delete messages?"\n       ok-button-text="Delete"\n       cancel-button-text="Cancel"\n       on-ok="deleteMessages()">\n    <div class="dialog-body">\n      <p class="alert alert-warning">\n        <span class="pficon pficon-warning-triangle-o"></span>\n        This operation cannot be undone so please be careful.\n      </p>\n      <p>You are about to delete\n        <ng-pluralize count="gridOptions.selectedItems.length"\n                      when="{\'1\': \'a message!\', \'other\': \'{} messages!\'}">\n        </ng-pluralize>\n      </p>\n    </div>\n  </div>\n\n  <div hawtio-confirm-dialog="moveDialog" title="Move messages?"\n       ok-button-text="Move"\n       cancel-button-text="Cancel"\n       on-ok="moveMessages()">\n    <div class="dialog-body">\n      <p class="alert alert-warning">\n        <span class="pficon pficon-warning-triangle-o"></span>\n        You cannot undo this operation.<br/>\n        Though after the move you can always move the\n        <ng-pluralize count="gridOptions.selectedItems.length"\n                      when="{\'1\': \'message\', \'other\': \'messages\'}"></ng-pluralize>\n        back again.\n      </p>\n      <p>Move\n        <ng-pluralize count="gridOptions.selectedItems.length"\n                      when="{\'1\': \'message\', \'other\': \'{} messages\'}"></ng-pluralize>\n        to: <select ng-model="queueName" ng-options="qn for qn in queueNames" ng-init="queueName=queueNames[0]"></select>\n      </p>\n    </div>\n  </div>\n\n</div>\n\n');
$templateCache.put('plugins/activemq/html/createDestination.html','<p>\n  <div class="alert alert-info">\n    <span class="pficon pficon-info"></span>The JMS API does not define a standard\n    address syntax. Although a standard address syntax was considered, it was decided\n    that the differences in address semantics between existing message-oriented\n    middleware (MOM) products were too wide to bridge with a single syntax.\n  </div>\n</p>\n\n<form class="form-horizontal">\n\n  <div class="form-group">\n    <label class="col-sm-2 control-label" for="name-markup">{{$ctrl.destinationType}} name</label>\n\n    <div class="col-sm-10">\n      <input id="name-markup" class="form-control" type="text" maxlength="300"\n             name="destinationName" ng-model="$ctrl.destinationName" placeholder="{{$ctrl.destinationType}} name"/>\n    </div>\n  </div>\n  <div class="form-group">\n    <label class="col-sm-2 control-label">Destination type</label>\n\n    <div class="col-sm-10">\n      <label class="checkbox">\n        <input type="radio" ng-model="$ctrl.destinationType" value="Queue"> Queue\n      </label>\n      <label class="checkbox">\n        <input type="radio" ng-model="$ctrl.destinationType" value="Topic"> Topic\n      </label>\n    </div>\n  </div>\n\n  <div class="form-group">\n    <div class="col-sm-offset-2 col-sm-10">\n      <button type="submit" class="btn btn-primary"\n              ng-click="$ctrl.validateAndCreateDestination($ctrl.destinationName, $ctrl.destinationType)"\n              ng-disabled="!$ctrl.destinationName">Create {{$ctrl.destinationType}}\n      </button>\n    </div>\n  </div>\n\n  <div hawtio-confirm-dialog="$ctrl.createDialog"\n        ok-button-text="Create"\n        cancel-button-text="Cancel"\n        on-ok="$ctrl.createDestination($ctrl.destinationName, $ctrl.destinationType)">\n    <div class="dialog-body">\n      <p>{{$ctrl.destinationType}} name <b>{{$ctrl.destinationName}}</b> contains unrecommended characters: <code>:</code></p>\n      <p>This may cause unexpected problems. Are you really sure to create this {{$ctrl.uncapitalisedDestinationType()}}?</p>\n    </div>\n  </div>\n\n</form>\n');
$templateCache.put('plugins/activemq/html/deleteQueue.html','<p>\n  <div class="alert alert-warning">\n    <span class="pficon pficon-warning-triangle-o"></span>\n    These operations cannot be undone. Please be careful!\n  </div>\n</p>\n\n<div class="row">\n  <div class="col-md-6">\n    <div class="control-group">\n      <button type="submit" class="btn btn-warning" ng-click="$ctrl.deleteDialog = true">\n        Delete queue \'{{$ctrl.selectedShortName()}}\'\n      </button>\n      <label>Removes the queue completely.</label>\n    </div>\n  </div>\n  <div class="col-md-6">\n    <div class="control-group">\n      <button type="submit" class="btn btn-warning" ng-click="$ctrl.purgeDialog = true">\n        Purge queue \'{{$ctrl.selectedShortName()}}\'\n      </button>\n      <label>Purges all the current messages on the queue.</label>\n    </div>\n  </div>\n</div>\n\n<div hawtio-confirm-dialog="$ctrl.deleteDialog"\n     title="Confirm delete queue"\n     ok-button-text="Delete"\n     cancel-button-text="Cancel"\n     on-ok="$ctrl.deleteDestination()">\n  <div class="dialog-body">\n    <p>You are about to delete the <b>{{$ctrl.selectedName()}}</b> queue.</p>\n    <p>This operation cannot be undone so please be careful.</p>\n  </div>\n</div>\n\n<div hawtio-confirm-dialog="$ctrl.purgeDialog"\n     title="Confirm purge queue"\n     ok-button-text="Purge"\n     cancel-button-text="Cancel"\n     on-ok="$ctrl.purgeDestination()">\n  <div class="dialog-body">\n    <p>You are about to purge the <b>{{$ctrl.selectedName()}}</b> queue</p>\n    <p>This operation cannot be undone so please be careful.</p>\n  </div>\n</div>\n');
$templateCache.put('plugins/activemq/html/deleteTopic.html','<p>\n  <div class="alert alert-warning">\n    <span class="pficon pficon-warning-triangle-o"></span>\n    This operation cannot be undone. Please be careful!\n  </div>\n</p>\n\n<div class="row">\n  <div class="col-md-12">\n    <div class="control-group">\n      <button type="submit" class="btn btn-warning" ng-click="$ctrl.deleteDialog = true">\n        Delete topic \'{{$ctrl.selectedName()}}\'\n      </button>\n      <label>Removes the topic completely.</label>\n    </div>\n  </div>\n</div>\n\n<div hawtio-confirm-dialog="$ctrl.deleteDialog"\n     title="Confirm delete topic"\n     ok-button-text="Delete"\n     cancel-button-text="Cancel"\n     on-ok="$ctrl.deleteDestination()">\n  <div class="dialog-body">\n    <p>You are about to delete the <b>{{$ctrl.selectedName()}}</b> topic.</p>\n    <p>This operation cannot be undone so please be careful.</p>\n  </div>\n</div>\n');
$templateCache.put('plugins/activemq/html/destinations.html','<div ng-controller="ActiveMQ.QueuesController">\n\n    <div class="row-fluid">\n        <div class="span24">\n            <div class="section-filter">\n                <input class="search-query span12" type="text" ng-model="gridOptions.filterOptions.filterText"\n                       placeholder="{{destinationFilterPlaceholder}}">\n                <i class="icon-remove clickable"\n                   title="Clear filter"\n                   ng-click="gridOptions.filterOptions.filterText = \'\'"></i>\n            </div>\n            <div class="control-group inline-block">\n                <form class="form-inline no-bottom-margin">\n                    <label>&nbsp;&nbsp;&nbsp;Filter: </label>\n                    <select ng-model="destinationFilter.filter" id="destinationFilter">\n                        <option value="" selected="selected">None...</option>\n                        <option ng-repeat="option in destinationFilterOptions" value="{{option.id}}">{{option.name}}\n                        </option>\n                    </select>\n                    <button class="btn" ng-click="refresh()"\n                            title="Filter">\n                        <i class="icon-refresh"></i>\n                    </button>\n                </form>\n            </div>\n        </div>\n    </div>\n\n\n    <div class="row-fluid">\n        <div class="gridStyle" ng-grid="gridOptions" ui-grid-resize-columns></div>\n    </div>\n\n</div>');
$templateCache.put('plugins/activemq/html/durableSubscribers.html','<div ng-controller="ActiveMQ.DurableSubscriberController">\n\n    <div class="row">\n      <div class="col-md-12">\n        <div class="pull-right">\n            <form class="form-inline">\n                <button class="btn btn-default" ng-click="createSubscriberDialog.open()"\n                        hawtio-show object-name="{{workspace.selection.objectName}}" method-name="createDurableSubscriber"\n                        title="Create durable subscriber">\n                    <i class="fa fa-plus"></i> Create\n                </button>\n                <button class="btn btn-default" ng-click="deleteSubscriberDialog.open()"\n                        hawtio-show object-name="{{$scope.gridOptions.selectedItems[0]._id}}" method-name="destroy"\n                        title="Destroy durable subscriber" ng-disabled="gridOptions.selectedItems.length != 1">\n                    <i class="fa fa-exclamation"></i> Destroy\n                </button>\n                <button class="btn btn-default" ng-click="refresh()"\n                        title="Refreshes the list of subscribers">\n                    <i class="fa fa-refresh"></i>\n                </button>\n            </form>\n        </div>\n      </div>\n    </div>\n\n    <div class="row">\n      <div class="gridStyle" ng-grid="gridOptions"></div>\n    </div>\n\n    <div modal="createSubscriberDialog.show">\n      <form name="createSubscriber" class="form-horizontal no-bottom-margin" ng-submit="doCreateSubscriber(clientId, subscriberName, topicName, subSelector)">\n        <div class="modal-header"><h4>Create Durable Subscriber</h4></div>\n        <div class="modal-body">\n          <label>Client Id: </label>\n          <input name="clientId" class="input-xlarge" type="text" ng-model="clientId" required>\n          <label>Subscriber name: </label>\n          <input name="subscriberName" class="input-xlarge" type="text" ng-model="subscriberName" required>\n          <label>Topic name: </label>\n          <input name="topicName" class="input-xlarge" type="text" ng-model="topicName" required uib-typeahead="title for title in topicNames($viewValue) | filter:$viewValue">\n          <label>Selector: </label>\n          <input name="subSelector" class="input-xlarge" type="text" ng-model="subSelector">\n        </div>\n        <div class="modal-footer">\n          <input class="btn btn-success" type="submit" value="Create">\n          <input class="btn btn-primary" type="button" ng-click="createSubscriberDialog.close()" value="Cancel">\n        </div>\n      </form>\n    </div>\n\n    <div hawtio-slideout="showSubscriberDialog.show" title="Details">\n      <div class="dialog-body">\n\n        <div class="row">\n          <div class="pull-right">\n            <form class="form-inline">\n\n              <button class="btn btn-danger" ng-disabled="showSubscriberDialog.subscriber.Status == \'Active\'"\n                      ng-click="deleteSubscriberDialog.open()"\n                      title="Delete subscriber">\n                <i class="fa fa-remove"></i> Delete\n              </button>\n\n              <button class="btn btn-default" ng-click="showSubscriberDialog.close()" title="Close this dialog">\n                <i class="fa fa-remove"></i> Close\n              </button>\n\n            </form>\n          </div>\n        </div>\n\n          <div class="row">\n              <div class="expandable-body well">\n                <table class="table table-condensed table-striped">\n                  <thead>\n                  <tr>\n                    <th>Property</th>\n                    <th>Value</th>\n                  </tr>\n                  </thead>\n                  <tbody>\n                  <tr>\n                    <td class="property-name">Client Id</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["ClientId"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Subscription Name</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["SubscriptionName"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Topic Name</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["DestinationName"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Selector</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["Selector"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Status</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber.Status}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Enqueue Counter</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["EnqueueCounter"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Dequeue Counter</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["DequeueCounter"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Dispatched Counter</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["DispatchedCounter"]}}</td>\n                  </tr>\n                  <tr>\n                    <td class="property-name">Pending Size</td>\n                    <td class="property-value">{{showSubscriberDialog.subscriber["PendingQueueSize"]}}</td>\n                  </tr>\n                  </tbody>\n                </table>\n              </div>\n            </div>\n\n      </div>\n\n    </div>\n\n    <div hawtio-confirm-dialog="deleteSubscriberDialog.show" ok-button-text="Yes" cancel-button-text="No" on-ok="deleteSubscribers()">\n      <div class="dialog-body">\n        <p>Are you sure you want to delete the subscriber</p>\n      </div>\n    </div>\n\n</div>');
$templateCache.put('plugins/activemq/html/jobs.html','<div ng-controller="ActiveMQ.JobSchedulerController">\n\n    <div class="row">\n      <div class="col-md-12">\n        <div class="pull-right">\n            <form class="form-inline">\n                <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length"\n                        hawtio-show object-name="{{workspace.selection.objectName}}" method-name="removeJob"\n                        ng-click="deleteJobsDialog.open()"\n                        title="Delete the selected jobs">\n                  <i class="fa fa-remove"></i> Delete\n                </button>\n                <button class="btn btn-default" ng-click="refresh()"\n                        title="Refreshes the list of subscribers">\n                    <i class="fa fa-refresh"></i>\n                </button>\n            </form>\n        </div>\n      </div>\n    </div>\n\n    <div class="row">\n      <div class="gridStyle" ng-grid="gridOptions"></div>\n    </div>\n\n    <div hawtio-confirm-dialog="deleteJobsDialog.show" ok-button-text="Yes" cancel-button-text="No" on-ok="deleteJobs()">\n      <div class="dialog-body">\n        <p>Are you sure you want to delete the jobs</p>\n      </div>\n    </div>\n\n</div>');
$templateCache.put('plugins/activemq/html/layoutActiveMQTree.html','<div class="tree-nav-layout">\n\n  <div class="sidebar-pf sidebar-pf-left" resizable r-directions="[\'right\']">\n\n    <div class="tree-nav-sidebar-header" ng-controller="ActiveMQ.TreeHeaderController">\n      <form role="form" class="search-pf has-button">\n        <div class="form-group has-clear">\n          <div class="search-pf-input-group">\n            <label for="input-search" class="sr-only">Search Tree:</label>\n            <input id="input-search" type="search" class="form-control" placeholder="Search tree:"\n              ng-model="filter">\n            <button type="button" class="clear" aria-hidden="true"\n              ng-hide="filter.length === 0"\n              ng-click="filter = \'\'">\n              <span class="pficon pficon-close"></span>\n            </button>\n          </div>\n        </div>\n        <div class="form-group tree-nav-buttons">\n          <span class="badge" ng-class="{positive: result.length > 0}"\n            ng-show="filter.length > 0">\n            {{result.length}}\n          </span>\n          <i class="fa fa-plus-square-o" title="Expand All" ng-click="expandAll()"></i>\n          <i class="fa fa-minus-square-o" title="Collapse All" ng-click="contractAll()"></i>\n        </div>\n      </form>\n    </div>\n\n    <div class="tree-nav-sidebar-content" ng-controller="ActiveMQ.TreeController">\n      <div class="spinner spinner-lg" ng-hide="treeFetched()"></div>\n      <div id="activemqtree" class="treeview-pf-hover treeview-pf-select"></div>\n    </div>\n\n  </div>\n\n  <div class="tree-nav-main">\n    <jmx-header></jmx-header>\n    <ul class="nav nav-tabs" hawtio-auto-dropdown ng-controller="ActiveMQ.TabsController">\n      <li ng-repeat="tab in tabs track by tab.id" ng-class="{active: isActive(tab)}" ng-show="tab.show()">\n        <a ng-href="#" ng-click="goto(tab.path)">{{tab.title}}</a>\n      </li>\n      <li class="dropdown overflow">\n        <a href="#" class="dropdown-toggle" data-toggle="dropdown">\n          More <span class="caret"></span>\n        </a>\n        <ul class="dropdown-menu" role="menu"></ul>\n      </li>\n    </ul>\n    <div class="contents" ng-view></div>\n  </div>\n</div>\n');
$templateCache.put('plugins/activemq/html/preferences.html','<div ng-controller="ActiveMQ.PreferencesController">\n  <div hawtio-form-2="config" entity="entity"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/blocked.html','<div class="table-view" ng-controller="Camel.BlockedExchangesController">\n\n  <h3>Blocked</h3>\n  \n  <p ng-if="!initDone">\n    <span class="spinner spinner-xs spinner-inline"></span> Loading...\n  </p>\n  \n  <div ng-if="initDone">\n    <p ng-if="data.length === 0">\n      No blocked exchanges\n    </p>\n    <div ng-if="data.length > 0">\n      <div class="row toolbar-pf table-view-pf-toolbar">\n        <div class="col-sm-12">\n          <form class="toolbar-pf-actions search-pf">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n                <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                      class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n                <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n            <div class="form-group">\n              <button type="button" class="btn btn-default" ng-disabled="gridOptions.selectedItems.length === 0"\n                ng-click="unblockDialog = true" data-placement="bottom">Unblock</button>\n            </div>\n          </form>\n        </div>\n      </div>\n      <table class="table table-striped table-bordered" hawtio-simple-table="gridOptions"></table>\n    </div>\n  </div>\n\n  <div hawtio-confirm-dialog="unblockDialog" ok-button-text="Unblock" cancel-button-text="Cancel" on-ok="doUnblock()"\n       title="Unblock Exchange">\n    <div class="dialog-body">\n      <p>You are about to unblock the selected thread.</p>\n      <p>This operation cannot be undone so please be careful.</p>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/browseEndpoint.html','<div ng-controller="Camel.BrowseEndpointController">\n\n  <div ng-class="{\'wiki-fixed\' : !isJmxTab}">\n\n    <h2>Browse</h2>\n\n    <div class="row toolbar-pf">\n      <div class="col-md-12">\n        <form class="toolbar-pf-actions search-pf">\n          <div class="form-group">\n            <button class="btn btn-default" ng-disabled="!gridOptions.selectedItems.length" ng-click="openForwardDialog()"\n                    hawtio-show object-name="{{workspace.selection.objectName}}" method-name="sendBodyAndHeaders"\n                    title="Forward the selected messages to another endpoint" data-placement="bottom">\n              Forward\n            </button>\n            <button class="btn btn-default" ng-click="refresh()" title="Refreshes the list of messages">\n              Refresh\n            </button>\n          </div>\n          <div class="toolbar-pf-action-right">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="search1" class="sr-only">Filter</label>\n                <input id="search1" type="search" class="form-control" ng-model="gridOptions.filterOptions.filterText"\n                      placeholder="Search">\n                <button type="button" class="clear" aria-hidden="true" ng-click="filterText = \'\'">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n          </div>\n        </form>\n      </div>\n    </div>\n\n    <div class="row">\n      <div class="col-md-12">\n        <table class="table" hawtio-simple-table="gridOptions"></table>\n      </div>\n    </div>\n\n    <script type="text/ng-template" id="camelBrowseEndpointMessageDetails.html">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$close()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <div class="row">\n          <div class="col-md-4">\n            <h4 class="modal-title" id="myModalLabel">Message</h4>\n          </div>\n          <div class="col-md-7">\n            <div class=""\n                hawtio-pager="messages"\n                on-index-change="selectRowIndex"\n                row-index="rowIndex">\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="modal-body camel-forward-message">\n        <div class="row">\n          <div class="col-md-12">\n            <dl>\n              <dt>Forward to endpoint</dt>\n              <dd>\n                <form class="form-inline camel-forward-message" ng-submit="forwardMessage(row, endpointUri)">\n                  <input type="text" class="form-control camel-forward-message" ng-model="endpointUri" placeholder="URI"\n                          uib-typeahead="title for title in endpointUris() | filter:$viewValue" required>\n                  <button type="submit" class="btn btn-default" hawtio-show \n                          object-name="{{workspace.selection.objectName}}" method-name="sendBodyAndHeaders"\n                          data-placement="bottom" title="Forward the selected messages to another endpoint">\n                    Forward\n                  </button>\n                </form>\n              </dd>\n            </dl>\n          </div>\n        </div>\n        <div class="row">\n          <div class="col-md-12">\n            <dl>\n              <dt>ID</dt>\n              <dd>{{row.id}}</dd>\n            </dl>\n          </div>\n        </div>\n        <div class="row">\n          <div class="col-md-12">\n            <dl>\n              <dt>Body</dt>\n              <dd><div hawtio-editor="row.body" read-only="true" mode="mode"></div></dd>\n            </dl>\n          </div>\n        </div>\n        <div class="row">\n          <div class="col-md-12">\n            <dl>\n              <dt>Headers</dt>\n              <dd>\n                <table class="table">\n                  <thead>\n                    <tr>\n                      <th>Name</th>\n                      <th>Type</th>\n                      <th>Value</th>\n                    </tr>\n                  </thead>\n                  <tbody compile="row.headerHtml"></tbody>\n                </table>\n              </dd>\n            </dl>\n          </div>\n        </div>\n      </div>\n    </script>\n\n    <script type="text/ng-template" id="camelBrowseEndpointForwardMessage.html">\n      <form class="form-horizontal" ng-submit="forwardMessages(endpointUri); $close();">\n        <div class="modal-header">\n          <button type="button" class="close" aria-label="Close" ng-click="$close()">\n            <span class="pficon pficon-close" aria-hidden="true"></span>\n          </button>\n          <h4>\n            Forward to endpoint\n          </h4>\n        </div>\n        <div class="modal-body">\n            <div class="form-group">\n              <label class="col-sm-1 control-label" for="endpointUri">URI</label>\n              <div class="col-sm-11">\n                <input type="text" id="endpointUri" class="form-control" ng-model="endpointUri" required\n                        uib-typeahead="title for title in endpointUris() | filter:$viewValue">\n              </div>\n            </div>\n        </div>\n        <div class="modal-footer">\n          <button type="button" class="btn btn-default" ng-click="$close()">Close</button>\n          <button type="submit" class="btn btn-primary">Forward</button>\n        </div>\n      </form>\n    </script>\n\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/browseRoute.html','<ng-include src="\'plugins/camel/html/browseMessageTemplate.html\'"></ng-include>\n\n<div class="row">\n  <table class="table table-striped" hawtio-simple-table="gridOptions"></table>\n  <!--\n      <div class="gridStyle" hawtio-datatable="gridOptions"></div>\n  -->\n</div>\n');
$templateCache.put('plugins/camel/html/createEndpoint.html','<div ng-controller="Camel.EndpointController" ng-switch="hasComponentNames">\n  <div ng-switch-when="true">\n    <tabs>\n      <pane heading="URL">\n        <ng-include src="\'plugins/camel/html/createEndpointURL.html\'"></ng-include>\n      </pane>\n      <pane heading="Components">\n        <ng-include src="\'plugins/camel/html/createEndpointWizard.html\'"></ng-include>\n      </pane>\n    </tabs>\n  </div>\n  <div ng-switch-default="false">\n    <ng-include src="\'plugins/camel/html/createEndpointURL.html\'"></ng-include>\n  </div>\n</div>\n');
$templateCache.put('plugins/camel/html/createEndpointURL.html','<form class="form-horizontal">\n  <div class="control-group">\n    <input class="col-md-12" type="text" size="255" ng-model="endpointName" placeholder="Endpoint URI"/>\n  </div>\n  <div class="control-group">\n    <button type="submit" class="btn btn-info" ng-click="createEndpoint(endpointName)"\n            ng-disabled="!endpointName">\n      Create endpoint from URI\n    </button>\n  </div>\n</form>\n');
$templateCache.put('plugins/camel/html/createEndpointWizard.html','<div ng-controller="Camel.EndpointController">\n  <form class="form-horizontal">\n    <div class="control-group">\n      <label class="control-label" for="componentName">Component</label>\n\n      <div class="controls">\n        <select id="componentName" ng-model="selectedComponentName"\n                ng-options="componentName for componentName in componentNames"></select>\n      </div>\n    </div>\n    <div ng-show="selectedComponentName">\n      <div class="control-group">\n        <label class="control-label" for="endpointPath">Endpoint</label>\n\n        <div class="controls">\n          <input id="endpointPath" class="col-md-10" type="text" ng-model="endpointPath" placeholder="name"\n                 uib-typeahead="title for title in endpointCompletions($viewValue) | filter:$viewValue"\n                 min-length="1">\n        </div>\n      </div>\n\n      <div simple-form name="formEditor" entity=\'endpointParameters\' data=\'endpointSchema\' schema="schema"></div>\n\n      <div class="control-group">\n        <div class="controls">\n          <button type="submit" class="btn btn-info" ng-click="createEndpointFromData()"\n                  ng-disabled="!endpointPath || !selectedComponentName">\n            Create endpoint from data\n          </button>\n        </div>\n      </div>\n    </div>\n  </form>\n</div>\n');
$templateCache.put('plugins/camel/html/debug.html','<div class="camel-debug-main" ng-controller="Camel.DebugRouteController">\n  \n  <div class="row camel-debug-header">\n    <div class="col-sm-6">\n      <h2>Debug</h2>\n    </div>\n    <div class="col-sm-6">\n      <button type="button" class="btn btn-primary pull-right" ng-if="debugging" ng-click="stopDebugging()">\n        Stop debugging\n      </button>\n    </div>\n  </div>\n  \n  <div ng-if="!debugging">\n    <p>Debugging allows you to step through camel routes to diagnose issues.</p>\n    <button type="button" class="btn btn-primary" ng-click="startDebugging()">Start debugging</button>\n  </div>\n  \n  <div class="toolbar-pf camel-debug-toolbar" ng-if="debugging">\n    <form class="toolbar-pf-actions">\n      <div class="form-group">\n        <div ng-switch="hasBreakpoint">\n          <button type="button" ng-switch-when="true" class="btn btn-default" ng-disabled="!selectedDiagramNodeId"\n                  ng-click="removeBreakpoint()" title="Remove the breakpoint on the selected node">\n            Remove breakpoint\n          </button>\n          <button type="button" ng-switch-default="false" class="btn btn-default" ng-disabled="shouldDisableAddBreakpoint()"\n                  ng-click="addBreakpoint()" title="Add a breakpoint on the selected node">\n            Add breakpoint\n          </button>\n        </div>\n      </div>\n      <div class="form-group camel-debug-icon-buttons">\n        <button type="button" class="btn btn-default" ng-click="step()" ng-disabled="!stopped"\n                title="Step into the next node">\n          <i class="fa fa-arrow-down" aria-hidden="true"></i>\n        </button>\n        <button type="button" class="btn btn-default" ng-click="resume()" ng-disabled="!stopped"\n                title="Resume running">\n          <i class="fa fa-play" aria-hidden="true"></i>\n        </button>\n        <button type="button" class="btn btn-default" ng-click="suspend()" ng-disabled="stopped"\n                title="Suspend all threads in this route">\n          <i class="fa fa-pause" aria-hidden="true"></i>\n        </button>\n      </div>\n    </form>\n  </div>\n\n  <div class="camel-debug-diagram-wrapper" ng-include src="graphView" ng-if="debugging"></div>\n\n  <div class="camel-debug-bottom-panel" resizable r-directions="[\'top\']" r-flex="true" ng-if="debugging"\n    ng-show="showDebugPanel">\n    <div class="camel-debug-bottom-panel-left">\n      <ul class="nav nav-tabs" ng-init="activeTab = \'headers\'">\n        <li ng-class="{\'active\': activeTab === \'headers\' && stopped}">\n          <a href="" ng-click="activeTab = \'headers\'" ng-class="{\'disabled\': !stopped}">Headers</a>\n        </li>\n        <li ng-class="{\'active\': activeTab === \'body\' && stopped}">\n          <a href="" ng-click="activeTab = \'body\'" ng-class="{\'disabled\': !stopped}">Body</a>\n        </li>\n      </ul>\n      <div class="camel-debug-headers-contents" ng-show="activeTab === \'headers\'">\n        <div ng-repeat="(key, value) in row.headers"><label>{{key}}:</label> {{value}}</div>\n      </div>\n      <div class="camel-debug-body-contents" ng-show="activeTab === \'body\'">\n        <em class="camel-debug-no-body-text" ng-show="row.body === \'[Body is null]\'">No Body</em>\n        <pre ng-show="row.body !== \'[Body is null]\'">{{row.body}}</pre>\n      </div>\n    </div>\n    <div class="camel-debug-bottom-panel-right">\n      <ul class="nav nav-tabs">\n        <li>\n          <a>Breakpoints</a>\n        </li>\n      </ul>\n      <ul class="camel-debug-breakpoints-list list-unstyled">\n        <li ng-class="{\'suspended\': isSuspendedAt(b)}"\n          ng-repeat="b in breakpoints">\n          <span>{{b}}</span>\n          <button type="button" class="close" aria-label="Close" title="Remove breakpoint"\n            ng-click="removeBreakpointById(b)">\n            <span aria-hidden="true">&times;</span>\n          </button>\n        </li>\n      </ul>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/deleteContextWarningModal.html','<div class="modal-header">\n  <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n    <span class="pficon pficon-close" aria-hidden="true"></span>\n  </button>\n  <h4>Are you sure?</h4>\n</div>\n<div class="modal-body">\n  <p>You are about to delete this Camel Context.</p>\n  <p>This operation cannot be undone so please be careful.</p>\n</div>\n<div class="modal-footer">\n  <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n  <button type="button" class="btn btn-danger" ng-click="$close()">Delete</button>\n</div>\n');
$templateCache.put('plugins/camel/html/deleteRouteWarningModal.html','<div class="modal-header">\n  <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n    <span class="pficon pficon-close" aria-hidden="true"></span>\n  </button>\n  <h4>Are you sure?</h4>\n</div>\n<div class="modal-body">\n  <p>You are about to delete this Camel route.</p>\n  <p>This operation cannot be undone so please be careful.</p>\n</div>\n<div class="modal-footer">\n  <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n  <button type="button" class="btn btn-danger" ng-click="$close()">Delete</button>\n</div>\n');
$templateCache.put('plugins/camel/html/endpointRuntimeRegistry.html','<div class="table-view" ng-controller="Camel.EndpointRuntimeRegistryController">\n\n  <h2>Endpoints (in/out)</h2>\n  \n  <div ng-if="!selectedMBean" class="spinner spinner-lg loading-page"></div>\n  \n  <div ng-if="selectedMBean">\n    <div class="loading-message" ng-if="data.length === 0">\n      There are no endpoints currently in use in this CamelContext.\n    </div>\n    <div ng-if="data.length > 0">\n      <div class="row toolbar-pf table-view-pf-toolbar">\n        <div class="col-sm-12">\n          <form class="toolbar-pf-actions search-pf">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n                <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                      class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n                <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n      <table class="table table-striped table-bordered camel-endpoints-table" hawtio-simple-table="gridOptions"></table>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/exchanges.html','<h2>Exchanges</h2>\n<div ng-include src="\'plugins/camel/html/inflight.html\'"></div>\n<div ng-include src="\'plugins/camel/html/blocked.html\'"></div>');
$templateCache.put('plugins/camel/html/inflight.html','<div class="table-view" ng-controller="Camel.InflightExchangesController">\n\n  <h3>Inflight</h3>\n  \n  <p ng-if="!initDone">\n    <span class="spinner spinner-xs spinner-inline"></span> Loading...\n  </p>\n  \n  <div ng-if="initDone">\n    <p ng-if="data.length === 0">\n      No inflight exchanges\n    </p>\n    <div ng-if="data.length > 0">\n      <div class="row toolbar-pf table-view-pf-toolbar">\n        <div class="col-sm-12">\n          <form class="toolbar-pf-actions search-pf">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n                <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                      class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n                <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n      <table class="table table-striped table-bordered camel-inflight-exchanges-table" hawtio-simple-table="gridOptions"></table>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/layoutCamelTree.html','<div class="tree-nav-layout">\n\n  <div class="sidebar-pf sidebar-pf-left" resizable r-directions="[\'right\']">\n\n    <div class="tree-nav-sidebar-header" ng-controller="Camel.TreeHeaderController">\n      <form role="form" class="search-pf has-button">\n        <div class="form-group has-clear">\n          <div class="search-pf-input-group">\n            <label for="input-search" class="sr-only">Search Tree:</label>\n            <input id="input-search" type="search" class="form-control" placeholder="Search tree:"\n              ng-model="filter">\n            <button type="button" class="clear" aria-hidden="true"\n              ng-hide="filter.length === 0"\n              ng-click="filter = \'\'">\n              <span class="pficon pficon-close"></span>\n            </button>\n          </div>\n        </div>\n        <div class="form-group tree-nav-buttons">\n          <span class="badge" ng-class="{positive: result.length > 0}"\n            ng-show="filter.length > 0">\n            {{result.length}}\n          </span>\n          <i class="fa fa-plus-square-o" title="Expand All" ng-click="expandAll()"></i>\n          <i class="fa fa-minus-square-o" title="Collapse All" ng-click="contractAll()"></i>\n        </div>\n      </form>\n    </div>\n\n    <div class="tree-nav-sidebar-content" ng-controller="Camel.TreeController">\n      <div class="spinner spinner-lg" ng-hide="treeFetched()"></div>\n      <div id="cameltree" class="treeview-pf-hover treeview-pf-select"></div>\n    </div>\n\n  </div>\n\n  <div class="tree-nav-main">\n    <div>\n      <context-actions></context-actions>\n      <route-actions></route-actions>\n      <jmx-header></jmx-header>\n    </div>\n    <ul class="nav nav-tabs" hawtio-auto-dropdown ng-controller="Camel.TabsController">\n      <li ng-repeat="tab in tabs track by tab.id" ng-class="{active: isActive(tab)}" ng-show="tab.show()">\n        <a href="#" ng-click="goto(tab.path)">{{tab.title}}</a>\n      </li>\n      <li class="dropdown overflow">\n        <a href="#" class="dropdown-toggle" data-toggle="dropdown">\n          More <span class="caret"></span>\n        </a>\n        <ul class="dropdown-menu" role="menu"></ul>\n      </li>\n    </ul>\n    <div class="contents" ng-view></div>\n  </div>\n</div>\n');
$templateCache.put('plugins/camel/html/nodePropertiesEdit.html','<div class="row-fluid">\n\n  <!-- the label and input fields needs to be wider -->\n  <style>\n    input, textarea, .uneditable-input {\n      width: 600px;\n    }\n    input, textarea, .editable-input {\n      width: 600px;\n    }\n\n    .form-horizontal .control-label {\n      width: 180px;\n    }\n\n    .form-horizontal .controls {\n      margin-left: 200px;\n    }\n  </style>\n\n  <h3>\n    <img src="{{icon}}" width="48" height="48" ng-show="icon"/> {{model.title}}\n    <span style="margin-left: 10px" ng-repeat="label in labels track by $index" class="pod-label badge" title="{{label}}">{{label}}</span>\n  </h3>\n\n  <div simple-form name="formViewer" mode=\'edit\' entity=\'nodeData\' data=\'model\' schema="schema"\n       showhelp="!hideHelp"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/nodePropertiesView.html','<header class="camel-properties-header">\n  <h2>Properties</h2>\n  <h3>\n    <img ng-src="{{icon}}" width="24" height="24" ng-show="icon"/>\n    <span>{{title}}</span>\n  </h3>\n  <em><span ng-repeat="label in labels track by $index">{{$first ? \'\' : \' / \'}}{{label}}<span></em>\n</header>\n<p>{{description}}</p>\n<property-list title="Defined Properties" properties="definedProperties"></property-list>\n<property-list title="Default Properties" properties="defaultProperties"></property-list>\n<property-list title="Undefined Properties" properties="undefinedProperties"></property-list>\n<div class="camel-properties-empty-space-for-tooltip"></div>');
$templateCache.put('plugins/camel/html/preferences.html','<div ng-controller="Camel.PreferencesController">\n  <div hawtio-form-2="config" entity="entity"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/profileRoute.html','<div class="table-view" ng-controller="Camel.ProfileRouteController">\n  \n  <h2>Profile</h2>\n  \n  <div ng-if="!initDone" class="spinner spinner-lg loading-page"></div>\n  \n  <div ng-if="initDone">\n    <div class="loading-message" ng-if="data.length === 0">\n      No profile data\n    </div>\n    <div ng-if="data.length > 0">\n      <div class="row toolbar-pf table-view-pf-toolbar">\n        <div class="col-sm-12">\n          <form class="toolbar-pf-actions search-pf">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n                <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                      class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n                <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n      <table class="table table-striped table-bordered camel-profile-table" hawtio-simple-table="gridOptions"></table>\n    </div>\n  </div>\n  \n</div>\n');
$templateCache.put('plugins/camel/html/propertiesComponent.html','<div class="camel-properties" ng-controller="Camel.PropertiesComponentController">\n  <div ng-include="viewTemplate"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/propertiesDataFormat.html','<div class="camel-properties" ng-controller="Camel.PropertiesDataFormatController">\n  <div ng-include="viewTemplate"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/propertiesEndpoint.html','<div class="camel-properties" ng-controller="Camel.PropertiesEndpointController">\n  <div ng-include="viewTemplate"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/propertiesRoute.html','<div class="camel-properties" ng-controller="Camel.PropertiesRouteController">\n  <div ng-include="viewTemplate"></div>\n</div>\n');
$templateCache.put('plugins/camel/html/restServices.html','<div ng-controller="Camel.RestServicesController">\n  \n  <h2>REST Services</h2>\n  \n  <div ng-if="!selectedMBean" class="spinner spinner-lg loading-page"></div>\n  \n  <div ng-if="selectedMBean">\n    <div ng-if="data.length === 0" class="loading-message">\n      There are no REST Services registered in this CamelContext.\n    </div>\n    <div ng-if="data.length > 0">\n      <div class="row toolbar-pf table-view-pf-toolbar">\n        <div class="col-sm-12">\n          <form class="toolbar-pf-actions search-pf">\n            <div class="form-group has-clear">\n              <div class="search-pf-input-group">\n                <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n                <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                      class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n                <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n                  <span class="pficon pficon-close"></span>\n                </button>\n              </div>\n            </div>\n          </form>\n        </div>\n      </div>\n      <table class="table table-striped table-bordered camel-rest-services-table" hawtio-simple-table="gridOptions"></table>\n    </div>\n  </div>\n</div>\n');
$templateCache.put('plugins/camel/html/routeDiagram.html','<div class="camel-route-diagram-canvas" ng-controller="Camel.RouteController">\n  <svg class="camel-diagram" width="100%" height="100%" preserveAspectRatio="xMidYMid">\n    <defs>\n      <marker id="arrowhead"\n              viewBox="0 0 10 10"\n              refX="9"\n              refY="5"\n              markerUnits="strokeWidth"\n              markerWidth="5.3"\n              markerHeight="4"\n              orient="auto">\n        <path d="M 0 0 L 10 5 L 0 10 z"></path>\n      </marker>\n\n      <filter id="drop-shadow" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" result="blur-out" stdDeviation="19"/>\n        <feOffset in="blur-out" result="the-shadow" dx="2" dy="2"/>\n        <feComponentTransfer xmlns="http://www.w3.org/2000/svg">\n          <feFuncA type="linear" slope="0.2"/>\n        </feComponentTransfer>\n        <feMerge xmlns="http://www.w3.org/2000/svg">\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n      <linearGradient id="rect-gradient" x1="0%" y1="0%" x2="0%" y2="100%">\n        <stop offset="0%" style="stop-color:rgb(254,254,255);stop-opacity:1"/>\n        <stop offset="100%" style="stop-color:rgb(247,247,255);stop-opacity:1"/>\n      </linearGradient>\n      <linearGradient id="rect-select-gradient" x1="0%" y1="0%" x2="0%" y2="100%">\n        <stop offset="0%" style="stop-color: #ffffa0; stop-opacity: 0.7"/>\n        <stop offset="100%" style="stop-color: #f0f0a0; stop-opacity: 0.7"/>\n      </linearGradient>\n    </defs>\n  </svg>\n</div>\n');
$templateCache.put('plugins/camel/html/routeMetrics.html','<div ng-controller="Camel.RouteMetricsController">\n\n  <h2>Route Metrics</h2>\n \n  <div class="row toolbar-pf">\n    <div class="col-md-12">\n      <form class="toolbar-pf-actions search-pf">\n        <div class="toolbar-pf-action-right">\n          <div class="form-group has-clear">\n            <div class="search-pf-input-group">\n              <label for="search1" class="sr-only">Filter</label>\n              <input id="search1" type="search" class="form-control" ng-model="filterText"\n                    placeholder="Search">\n              <button type="button" class="clear" aria-hidden="true" ng-click="filterText = \'\'">\n                <span class="pficon pficon-close"></span>\n              </button>\n            </div>\n          </div>\n        </div>\n      </form>\n    </div>\n  </div>\n\n  <div class="spinner spinner-lg loading-page" ng-if="!initDone"></div>\n\n  <div ng-show="initDone">\n    <div class="row" ng-if="metricDivs.length === 0">\n      <div class="col-md-12">\n        <div class="loading-message">\n          This Camel context has no route metrics data.\n        </div>\n      </div>\n    </div>\n    <div class="row" ng-if="metricDivs.length > 0">\n      <div class="col-md-12">\n        <div id="{{metric.id}}" ng-repeat="metric in metricDivs track by metric.id" ng-show="metricVisible(metric)"></div>\n      </div>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/sendMessage.html','<div ng-controller="Camel.SendMessageController">\n\n  <h2>Send Message</h2>\n\n  <div class="alert alert-warning" ng-show="noCredentials">\n    <span class="pficon pficon-warning-triangle-o"></span>\n    <strong>No credentials set for endpoint!</strong>\n    Please set your username and password in the\n    <a href="#" class="alert-link" ng-click="openPrefs()">Preferences</a> page.\n  </div>\n\n  <h3>Headers</h3>\n\n  <div class="row camel-message-headers" ng-if="headers.length > 0">\n    <div class="col-sm-5">\n      <form>\n        <div class="form-group">\n          <label>Name</label>\n          <input type="text" class="form-control" ng-model="header.name" ng-repeat="header in headers"\n                 uib-typeahead="completion for completion in defaultHeaderNames() | filter:$viewValue"\n                 pf-focused="$last">\n        </div>\n      </form>\n    </div>\n    <div class="col-sm-5">\n      <form>\n        <div class="form-group">\n          <label>Value</label>\n          <input type="text" class="form-control" ng-model="header.value" ng-repeat="header in headers">\n        </div>\n      </form>\n    </div>\n    <div class="col-sm-2">\n      <form>\n        <div class="form-group">\n          <label>&nbsp;</label>\n          <button type="button" class="btn btn-default" title="Delete" ng-click="removeHeader(header)"\n                  ng-repeat="header in headers">\n            <span class="pficon pficon-delete"></span>\n          </button>\n        </div>\n      </form>\n    </div>\n  </div>\n\n  <div>\n    <a href="" ng-click="addHeader()">Add header</a>\n  </div>\n\n  <h3>Body</h3>\n\n  <form>\n    <div class="form-group">\n      <div hawtio-editor="message" mode="codeMirrorOptions.mode.name"></div>\n    </div>\n    <div class="form-group">\n      <select class="form-control camel-send-message-format" ng-model="codeMirrorOptions.mode.name">\n        <option value="javascript">JSON</option>\n        <option value="xml">XML</option>\n      </select>\n      <button class="btn btn-default" ng-click="formatMessage()"\n              title="Automatically pretty prints the message so its easier to read">Format\n      </button>\n    </div>\n  </form>\n\n  <p>\n    <button type="button" class="btn btn-primary camel-send-message-button" ng-click="sendMessage()">Send message</button>\n  </p>\n\n</div>\n');
$templateCache.put('plugins/camel/html/source.html','<div class="table-view" ng-controller="Camel.SourceController">\n  \n  <h2>Source</h2>\n  \n  <form>\n    <div class="form-group">\n      <div hawtio-editor="source" mode="\'xml\'" read-only="!showUpdateButton"></div>\n    </div>\n  </form>\n  \n  <button class="btn btn-primary" hawtio-show object-name="{{camelContextMBean}}"\n          method-name="addOrUpdateRoutesFromXml" ng-click="saveRouteXml()" ng-if="showUpdateButton">\n    Update\n  </button>\n\n</div>\n');
$templateCache.put('plugins/camel/html/traceRoute.html','<div class="camel-trace-main" ng-controller="Camel.TraceRouteController">\n  \n  <div class="row camel-trace-header">\n    <div class="col-sm-6">\n      <h2>Trace</h2>\n    </div>\n    <div class="col-sm-6">\n      <button type="button" class="btn btn-primary pull-right" ng-if="tracing" ng-click="stopTracing()">\n        Stop tracing\n      </button>\n    </div>\n  </div>\n  \n  <div ng-if="!tracing">\n    <p>Tracing allows you to send messages to a route and then step through and see the messages flow through a route\n      to aid debugging and to help diagnose issues.\n    </p>\n    <p>Once you start tracing, you can send messages to the input endpoints, then come back to this page and see the\n      flow of messages through your route.\n    </p>\n    <p>As you click on the message table, you can see which node in the flow it came through; moving the selection up\n      and down in the message table lets you see the flow of the message through the diagram.\n    </p>\n    <button type="button" class="btn btn-primary" ng-click="startTracing()">\n      Start tracing\n    </button>\n  </div>\n  \n  <div class="camel-trace-diagram-wrapper" ng-include src="graphView" ng-if="tracing"></div>\n\n  <div class="camel-trace-bottom-panel" resizable r-directions="[\'top\']" r-flex="true" ng-if="tracing">\n    <table class="table table-striped table-bordered camel-trace-messages-table-header" ng-show="!message">\n      <thead>\n        <tr>\n          <th>ID</th>\n          <th>To Node</th>\n        </tr>\n      </thead>\n    </table>\n    <div class="camel-trace-messages-table-body-container" ng-show="!message">\n      <table class="table table-striped table-bordered">\n        <tbody>\n          <tr ng-repeat="message in messages">\n            <td>\n              <a href="" title="View message" ng-click="openMessageDialog(message, $index)">\n                {{message.headers.breadcrumbId}}\n              </a>\n            </td>\n            <td>{{message.toNode}}</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n    <div class="camel-trace-message-details" ng-if="message">\n      <button type="button" class="close" aria-hidden="true" ng-click="closeMessageDetails()">\n        <span class="pficon pficon-close"></span>\n      </button>\n      <ul class="pagination">\n        <li ng-class="{disabled: messageIndex === 0}">\n          <a href="#" title="First" ng-disabled="messageIndex === 0" ng-click="changeMessage(0)">\n            <span class="i fa fa-angle-double-left"></span>\n          </a>\n        </li>\n        <li ng-class="{disabled: messageIndex === 0}">\n          <a href="#" title="Previous" ng-disabled="messageIndex === 0" ng-click="changeMessage(messageIndex - 1)">\n            <span class="i fa fa-angle-left"></span>\n          </a>\n        </li>\n        <li ng-class="{disabled: messageIndex === messages.length - 1}">\n          <a href="#" title="Next" ng-disabled="messageIndex === messages.length - 1" ng-click="changeMessage(messageIndex + 1)">\n            <span class="i fa fa-angle-right"></span>\n          </a>\n        </li>\n        <li ng-class="{disabled: messageIndex === messages.length - 1}">\n          <a href="#" title="Last" ng-disabled="messageIndex === messages.length - 1" ng-click="changeMessage(messages.length - 1)">\n            <span class="i fa fa-angle-double-right"></span>\n          </a>\n        </li>\n      </ul>\n      <ul class="nav nav-tabs" ng-init="activeTab = \'headers\'">\n        <li ng-class="{\'active\': activeTab === \'headers\'}">\n          <a href="" ng-click="activeTab = \'headers\'">Headers</a>\n        </li>\n        <li ng-class="{\'active\': activeTab === \'body\'}">\n          <a href="" ng-click="activeTab = \'body\'">Body</a>\n        </li>\n      </ul>\n      <div class="camel-trace-headers-contents" ng-show="activeTab === \'headers\'">\n        <div ng-repeat="(key, value) in message.headers"><label>{{key}}:</label> {{value}}</div>\n      </div>\n      <div class="camel-trace-body-contents" ng-show="activeTab === \'body\'">\n        <em class="camel-trace-no-body-text" ng-show="message.body === \'[Body is null]\'">No Body</em>\n        <pre ng-show="message.body !== \'[Body is null]\'">{{message.body}}</pre>\n      </div>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/camel/html/typeConverter.html','<div class="table-view" ng-controller="Camel.TypeConverterController">\n  \n  <h2>Type Converters</h2>\n  \n  <div class="toolbar-pf">\n      <form class="toolbar-pf-actions">\n        <div class="form-group">\n          <button type="button" class="btn btn-default camel-type-converters-enable-statistics-button"\n            ng-click="enableStatistics()" ng-if="!mbeanAttributes.StatisticsEnabled">\n            <span ng-show="enableTypeConvertersStats" class="spinner spinner-xs spinner-inline"></span>\n            <span ng-show="!enableTypeConvertersStats">Enable statistics</span>\n          </button>\n          <button type="button" class="btn btn-default camel-type-converters-enable-statistics-button"\n            ng-click="disableStatistics()" ng-if="mbeanAttributes.StatisticsEnabled">\n            <span ng-show="disableTypeConvertersStats" class="spinner spinner-xs spinner-inline"></span>\n            <span ng-show="!disableTypeConvertersStats">Disable statistics</span>\n          </button>\n          <button type="button" class="btn btn-default" ng-click="resetStatistics()"\n            ng-disabled="!mbeanAttributes.StatisticsEnabled">Reset statistics</button>\n        </div>\n      </form>\n  </div>\n  \n  <div>\n    <dl class="dl-horizontal camel-type-converters-dl">\n      <dt>Number of Type Converters</dt>\n      <dd>{{mbeanAttributes.NumberOfTypeConverters}}</dd>\n      <dt># Attempts</dt>\n      <dd>{{mbeanAttributes.StatisticsEnabled ? mbeanAttributes.AttemptCounter : \'-\'}}</dd>\n      <dt># Hit</dt>\n      <dd>{{mbeanAttributes.StatisticsEnabled ? mbeanAttributes.HitCounter : \'-\'}}</dd>\n      <dt># Miss</dt>\n      <dd>{{mbeanAttributes.StatisticsEnabled ? mbeanAttributes.MissCounter : \'-\'}}</dd>\n      <dt># Failed</dt>\n      <dd>{{mbeanAttributes.StatisticsEnabled ? mbeanAttributes.FailedCounter : \'-\'}}</dd>\n    </dl>\n  </div>\n\n  <div class="row toolbar-pf table-view-pf-toolbar">\n    <div class="col-sm-12">\n      <form class="toolbar-pf-actions search-pf">\n        <div class="form-group has-clear">\n          <div class="search-pf-input-group">\n            <label for="filterByKeyword" class="sr-only">Filter by keyword</label>\n            <input id="filterByKeyword" type="search" ng-model="gridOptions.filterOptions.filterText"\n                    class="form-control" placeholder="Filter by keyword..." autocomplete="off">\n            <button type="button" class="clear" aria-hidden="true" ng-click="clearFilter()">\n              <span class="pficon pficon-close"></span>\n            </button>\n          </div>\n        </div>\n      </form>\n    </div>\n  </div>\n\n  <table class="table table-striped table-bordered" hawtio-simple-table="gridOptions"></table>\n\n</div>\n');
$templateCache.put('plugins/karaf/html/feature-details.html','<div class="toolbar-pf">\n  <form class="toolbar-pf-actions">\n    <div class="form-group">\n      <button ng-click="install(name,version)"\n              class="btn btn-default"\n              title="install"\n              hawtio-show\n              object-name="{{featuresMBean}}"\n              method-name="installFeature">Install</button>\n      <button ng-click="uninstall(name,version)"\n              class="btn btn-default"\n              title="uninstall"\n              hawtio-show\n              object-name="{{featuresMBean}}"\n              method-name="uninstallFeature">Uninstall</button>\n    </div>\n  </form>\n</div>\n\n<h2>Details</h2>\n<dl class="dl-horizontal">\n  <dt>ID</dt>\n  <dd>{{row.Id}}</dd>\n  <dt>Name</dt>\n  <dd>{{row.Name}}</dd>\n  <dt>State</dt>\n  <dd>{{row.Installed === \'true\' ? \'Installed\' : \'Uninstalled\'}}</dd>\n  <dt>Repository Name</dt>\n  <dd>{{row.RepositoryName}}</dd>\n  <dt>Repository URI</dt>\n  <dd>{{row.RepositoryURI}}</dd>\n  <dt>Version</dt>\n  <dd>{{row.Version}}</dd>\n</dl>\n\n<h2>Dependencies</h2>\n<ul class="list-unstyled">\n  <li ng-repeat="feature in row.Dependencies">\n    <a href=\'osgi/feature/{{feature.Name}}/{{feature.Version}}\'>{{feature.Name}}/{{feature.Version}}</a>\n  </li>\n</ul>\n\n<h2>Bundles</h2>\n<ul class="list-unstyled">\n  <li ng-repeat="bundle in row.BundleDetails">\n    <div ng-switch="bundle.Installed">\n      <a ng-switch-when="true" href=\'osgi/bundle/{{bundle.Identifier}}\'>{{bundle.Location}}</a>\n      <span ng-switch-default>{{bundle.Location}}</span>\n    </div>\n  </li>\n</ul>\n\n<h2>Configurations</h2>\n<table class="table table-striped table-bordered">\n  <thead>\n    <tr>\n      <th>PID</th>\n      <th>Properties</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="(pid, value) in row.Configurations">\n      <td><a href="osgi/pid/{{value.Pid}}">{{value.Pid}}</a></td>\n      <td>\n        <ul class="list-unstyled">\n          <li ng-repeat="(key, value) in value.Elements">{{key}} = {{value.Value}}</li>\n        </ul>\n    </tr>\n  </tbody>\n</table>\n\n<h2>Configuration Files</h2>\n<ul class="list-unstyled">\n  <li ng-repeat="(key, value) in row[\'Configuration Files\']">{{value.Files}}</li>\n</ul>\n');
$templateCache.put('plugins/karaf/html/feature.html','<div class="controller-section" ng-controller="Karaf.FeatureController">\n\n  <ol class="breadcrumb">\n    <li>\n      <a ng-href="osgi/features">Features</a>\n    </li>\n    <li class="page-title">\n      {{row.Id}}\n    </li>\n  </ol>\n\n  <div ng-include src="\'plugins/karaf/html/feature-details.html\'"></div>\n\n</div>\n\n');
$templateCache.put('plugins/karaf/html/features.html','<div class="list-view">\n  <h1>Features</h1>\n  <div ng-if="!$ctrl.loading">\n    <pf-toolbar config="$ctrl.toolbarConfig"></pf-toolbar>\n    <pf-list-view items="$ctrl.listItems"\n                  config="$ctrl.listConfig"\n                  action-buttons="$ctrl.listItemActionButtons"\n                  enable-button-for-item-fn="$ctrl.enableButtonForItem">\n      <div class="list-view-pf-description">\n        <div class="list-view-pf-left">\n          <span class="list-view-pf-icon-sm fa"\n                ng-class="{\'list-view-pf-icon-success fa-check\': item.installed}"\n                title="Feature {{item.id}} {{item.getState()}}">\n          </span>\n        </div>\n        <div class="list-group-item-heading"><a ng-href=osgi/feature/{{item.id}}>{{item.id}}</a></div>\n      </div>\n      </pf-list-view>\n  </div>\n\n  <script type="text/ng-template" id="addRepositoryDialog.html">\n    <form name="addProperty" class="form-horizontal">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Add feature repository</h4>\n      </div>\n      <div class="modal-body">\n        <div class="form-group">\n          <label class="col-sm-3 control-label" for="repositoryUri">Repository URI</label>\n          <div class="col-sm-9">\n            <input type="text" class="form-control" id="repositoryUri" ng-model="$ctrl.repositoryUri" placeholder="mvn:foo/bar/1.0/xml/features" required>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n        <button type="submit" class="btn btn-primary" ng-click="$close()">Add</button>\n      </div>\n    </form>\n  </script>\n\n  <script type="text/ng-template" id="removeRepositoryDialog.html">\n    <form name="addProperty" class="form-horizontal">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Remove feature repository</h4>\n      </div>\n      <div class="modal-body">\n        <div class="form-group">\n          <label class="col-sm-3 control-label" for="repository">Repository</label>\n          <div class="col-sm-9">\n            <select ng-model="$ctrl.selectedRepository" ng-options="repository.name for repository in $ctrl.repositories" required></select>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n        <button type="submit" class="btn btn-primary" ng-click="$close()">Remove</button>\n      </div>\n    </form>\n  </script>\n  <div class="spinner spinner-lg loading-page" ng-if="$ctrl.loading"></div>\n</div>\n');
$templateCache.put('plugins/karaf/html/scr-component-details.html','<div class="row toolbar-pf">\n  <div class="col-sm-12">\n    <form class="toolbar-pf-actions">\n      <div class="form-group">\n        <button class="btn btn-default" \n                ng-click="$ctrl.activateComponent()" \n                ng-disabled="$ctrl.disableActivate()">\n          Activate\n        </button>\n        <button class="btn btn-default" \n                ng-click="$ctrl.deactivateComponent()"\n                ng-disabled="$ctrl.disableDeactivate()">\n          Deactivate\n        </button>\n      </div>\n    </form>\n  </div>\n</div>\n\n<h2>Details</h2>\n\n<div class="row">\n  <div class="col-md-12">\n    <dl class="dl-horizontal">\n      <dt>Id</dt>\n      <dd>{{$ctrl.component.id}}</dd>\n      <dt>Name</dt>\n      <dd>{{$ctrl.component.name}}</dd>\n      <dt>State</dt>\n      <dd>{{$ctrl.component.state}}</dd>\n    </dl>\n  </div>\n</div>\n\n<h2>Properties</h2>\n\n<div class="row">\n  <div class="col-md-12">\n    <dl class="dl-horizontal">\n      <dt ng-repeat-start="(key, value) in $ctrl.component.properties">{{key}}</dt>\n      <dd ng-repeat-end ng-repeat="v in value">{{v.Value}}</dd>\n    </dl>\n  </div>\n</div>\n\n<h2>References</h2>\n\n<div class="row">\n  <div class="col-md-12">\n    <table class="table">\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Availability</th>\n          <th>Cardinality</th>\n          <th>Policy</th>\n          <th>Bound Services</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr ng-repeat="(key, value) in $ctrl.component.references">\n          <td>{{value.Name}}</td>\n          <td>{{value.Availability}}</td>\n          <td>{{value.Cardinality}}</td>\n          <td>{{value.Policy}}</td>\n          <td>\n            <ul class="list-unstyled">\n              <li ng-repeat="id in value[\'Bound Services\']">\n                <i class="fa fa-cog text-info" id="bound.service.{{id}}"> {{id}}</i>\n              </li>\n            </ul>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</div>\n');
$templateCache.put('plugins/karaf/html/scr-component.html','<div class="controller-section" ng-if="!$ctrl.loading">\n\n  <ol class="breadcrumb">\n    <li>\n      <a ng-href="{{$ctrl.srcComponentsUrl}}">Declarative Services</a>\n    </li>\n    <li class="page-title">\n      {{$ctrl.component.name}}\n    </li>\n  </ol>\n\n  <div ng-include src="\'plugins/karaf/html/scr-component-details.html\'"></div>\n\n</div>\n<div class="spinner spinner-lg loading-page" ng-if="$ctrl.loading"></div>  ');
$templateCache.put('plugins/karaf/html/server.html','<h1>Server</h1>\n\n<div class="controller-section" ng-controller="Karaf.ServerController">\n\n  <div class="row">\n    <div class="col-md-12">\n      <dl class="dl-horizontal">\n        <dt>Name</dt>\n        <dd>{{data.name}}</dd>\n        <dt>Version</dt>\n        <dd>{{data.version}}</dd>\n        <dt>State</dt>\n        <dd>{{data.state}}</dd>\n        <dt>Is root</dt>\n        <dd>{{data.root}}</dd>\n        <dt>Start Level</dt>\n        <dd>{{data.startLevel}}</dd>\n        <dt>Framework</dt>\n        <dd>{{data.framework}}</dd>\n        <dt>Framework Version</dt>\n        <dd>{{data.frameworkVersion}}</dd>\n        <dt>Location</dt>\n        <dd>{{data.location}}</dd>\n        <dt>SSH Port</dt>\n        <dd>{{data.sshPort}}</dd>\n        <dt>RMI Registry Port</dt>\n        <dd>{{data.rmiRegistryPort}}</dd>\n        <dt>RMI Server Port</dt>\n        <dd>{{data.rmiServerPort}}</dd>\n        <dt>PID</dt>\n        <dd>{{data.pid}}</dd>\n      </dl>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/bundle-list.html','<h1>Bundles</h1>\n\n<div class="bundles-container cards-pf controller-section" ng-controller="Osgi.BundleListController">\n\n  <div class="row toolbar-pf">\n    <div class="col-md-12">\n      <form class="toolbar-pf-actions">\n        <div class="form-group">\n          <label class="sr-only" for="filter">Install Bundle</label>\n          <div class="input-group" hawtio-show object-name="{{frameworkMBean}}" method-name="installBundle">\n            <input type="text" class="form-control" placeholder="Install Bundle..." ng-model="bundleUrl">\n            <div class="input-group-btn">\n              <button type="button" class="btn btn-default" ng-disabled="installDisabled()" ng-click="install()"\n                      title="Install">\n                <i class="fa fa-download"></i>\n              </button>\n            </div>\n          </div>\n        </div>\n        <div class="form-group">\n          <input type="text" class="form-control" ng-model="display.bundleFilter" placeholder="Filter by keyword..." autocomplete="off">\n        </div>\n        <div class="toolbar-pf-action-right">\n          <div class="form-group toolbar-pf-view-selector">\n            <a ng-href="{{listViewUrl}}" class="btn btn-link" title="Grid view">\n              <i class="fa fa-th"></i>\n            </a>\n            <a ng-href="{{tableViewUrl}}" class="btn btn-link" title="Table view">\n              <i class="fa fa-table"></i>\n            </a>\n          </div>\n        </div>\n      </form>\n    </div>\n  </div>\n  \n  <div id="toolbar-row-2" class="row toolbar-pf">\n    <div class="col-md-12">\n      <form class="toolbar-pf-actions form-inline">\n        <div class="form-group">\n          <label class="sr-only" for="service-filter">Service</label>\n          <select pf-select id="service-filter" title="Filter by service..." ng-model="display.showBundleGroups"\n                  ng-options="service.name for service in availableServices track by service.id" multiple>\n          </select>\n        </div>\n        <div class="form-group">\n          <label for="sortField">Sort by</label>\n          <select id="sortField" class="form-control btn btn-default" ng-model="display.sortField">\n            <option value="Identifier">ID</option>\n            <option value="Name">Name</option>\n            <option value="SymbolicName">Symbolic Name</option>\n          </select>\n        </div>\n        <div class="form-group">\n          <label for="displayField">Display</label>\n          <select id="displayField" class="form-control btn btn-default" ng-model="display.bundleField">\n            <option value="Name">Name</option>\n            <option value="SymbolicName">Symbolic Name</option>\n          </select>\n        </div>\n        <div class="form-group">\n          <label for="startLevelFilter">Start Level</label>\n          <input id="startLevelFilter" type="number" min="0" class="form-control" ng-model="display.startLevelFilter">\n        </div>\n      </form>\n    </div>\n  </div>\n\n  <div class="container-fluid container-cards-pf bundle-cards">\n    <div class="row row-cards-pf">\n      <div ng-repeat="bundle in bundles" ng-show="filterBundle(bundle)">\n        <div class="col-xs-12 col-sm-12 col-md-6 col-lg-4">\n          <div class="card-pf card-pf-view card-pf-view-select" hawtio-template-popover title="Bundle details" ng-click="showDetails(bundle)">\n            <div class="content">\n              <table>\n                <tr>\n                  <td><span class="bundle-state" ng-class="bundle.State.toLowerCase()"></span></td>\n                  <td>{{getLabel(bundle)}}</td>\n                </tr>\n              </table>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <script type="text/ng-template" id="popoverTemplate">\n    <small>\n      <table class="table">\n        <tbody>\n        <tr ng-repeat="(k, v) in bundle track by $index">\n          <td class="property-name">{{k}}</td>\n          <td class="property-value">{{v}}</td>\n        </tr>\n        </tbody>\n      </table>\n    </small>\n  </script>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/bundle.html','<div class="controller-section" ng-controller="Osgi.BundleController">\n\n  <ol class="breadcrumb">\n    <li>\n        <a ng-href="osgi/bundles">Bundles</a>\n    </li>\n    <li class="page-title">\n        {{row.Headers[\'Bundle-Name\'].Value}}\n    </li>\n  </ol>  \n\n  <div class="toolbar-pf">\n    <form class="toolbar-pf-actions">\n      <div class="form-group">\n        <button ng-click="startBundle(bundleId)" \n                class="btn btn-default" \n                hawtio-show\n                object-name="{{frameworkMBean}}"\n                method-name="startBundle">Start</button>\n        <button ng-click="stopBundle(bundleId)" \n                class="btn btn-default" \n                hawtio-show\n                object-name="{{frameworkMBean}}"\n                method-name="stopBundle">Stop</button>\n        <button ng-click="refreshBundle(bundleId)" \n                class="btn btn-default" \n                hawtio-show\n                object-name="{{frameworkMBean}}"\n                method-name="refreshBundle">Refresh</button>\n        <button ng-click="updateBundle(bundleId)" \n                class="btn btn-default" \n                hawtio-show\n                object-name="{{frameworkMBean}}"\n                method-name="updateBundle">Update</button>\n        <button ng-click="uninstallBundle(bundleId)" \n                class="btn btn-default" \n                hawtio-show\n                object-name="{{frameworkMBean}}"\n                method-name="uninstallBundle">Uninstall</button>\n      </div>\n    </form>\n  </div>\n\n  <h2>Details</h2>\n\n  <dl class="dl-horizontal osgi-bundle-details-dl">\n    <dt ng-switch="row.Fragment">\n      <span ng-switch-when="true">Fragment&nbsp;ID</span>\n      <span ng-switch-default>Bundle&nbsp;ID</span>\n    </dt>\n    <dd>\n      {{row.Identifier}}\n    </dd>\n    <dt>\n      Bundle&nbsp;Name\n    </dt>\n    <dd>\n      {{row.Headers[\'Bundle-Name\'].Value}}\n    </dd>\n    <dt>\n      Symbolic&nbsp;Name\n    </dt>\n    <dd>\n      {{row.SymbolicName}}\n    </dd>\n    <dt>\n      Version\n    </dt>\n    <dd>\n      {{row.Version}}\n    </dd>\n    <dt>\n      Start&nbsp;Level\n    </dt>\n    <dd>\n      {{row.StartLevel}}\n    </dd>\n    <dt>\n      Location\n    </dt>\n    <dd>\n      {{row.Location}}\n    </dd>\n    <dt>\n      State\n    </dt>\n    <dd>\n      {{row.State.toLowerCase()}}\n    </dd>\n    <dt>\n      Last&nbsp;Modified\n    </dt>\n    <dd>\n      {{row.LastModified | date:\'medium\'}}\n    </dd>\n    <div>\n    <dt ng-switch="row.Fragment">\n      <span ng-switch-when="true">Hosts</span>\n      <span ng-switch-default>Fragments</span>\n    </dt>\n    <dd ng-switch="row.Fragment">\n      <span ng-switch-when="true" ng-bind-html-unsafe="row.Hosts"/>\n      <span ng-switch-default ng-bind-html-unsafe="row.Fragments"/>\n    </dd>\n  </dl>\n\n  <h2>Inspect Classloading</h2>\n\n  <div class="alert alert-dismissable" ng-class="\'alert-\' + classLoadingAlert.type" ng-if="classLoadingAlert">\n    <span class="pficon" ng-class="classLoadingAlert.icon"></span>\n    <button type="button" class="close" aria-hidden="true" ng-click="dismissClassLoadingAlert()">\n      <span class="pficon pficon-close"></span>\n    </button>\n    <span ng-bind-html="classLoadingAlert.message"></span>\n  </div>\n\n  <form class="form-horizontal">\n    <div class="form-group">\n      <label class="col-sm-2 control-label" for="classToLoad">Class Name</label>\n      <div class="col-sm-10">\n        <input type="text" id="classToLoad" class="form-control" ng-model="classToLoad">\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-offset-2 col-sm-10">\n        <button type="button" class="btn btn-primary" ng-click="executeLoadClass(classToLoad)" ng-disabled="!classToLoad">\n          Load Class\n        </button>\n      </div>\n    </div>\n    <div class="form-group">\n      <label class="col-sm-2 control-label" for="resourceToLoad">Resource Name</label>\n      <div class="col-sm-10">\n        <input type="text" id="resourceToLoad" class="form-control" ng-model="resourceToLoad">\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-offset-2 col-sm-10">\n        <button type="button" class="btn btn-primary" ng-click="executeFindResource(resourceToLoad)" ng-disabled="!resourceToLoad">\n          Get Resource\n        </button>\n      </div>\n    </div>\n  </form>\n\n  <h2>Imported Packages</h2>\n\n  <table class="table table-striped table-bordered">\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Imported Version</th>\n        <th>Version</th>\n        <th>Resolution</th>\n        <th>Dynamic Import</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat="(package, data) in row.ImportData">\n        <td>{{package}}</td>\n        <td>{{data.ReportedVersion}}</td>\n        <td>{{data.headers.Aversion}}</td>\n        <td>{{data.headers.Dresolution}}</td>\n        <td>{{data.headers.reason}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <div ng-if="thereAreUnsatisfiedPackages()">\n    <h3>Imports not satisfied</h3>\n    <table class="table table-striped table-bordered">\n      <thead>\n        <tr>\n          <th>Name</th>\n          <th>Version</th>\n          <th>Resolution</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr ng-repeat="(package, data) in unsatisfiedPackages">\n          <td>{{package}}</td>\n          <td>{{data.Aversion}}</td>\n          <td>{{data.Dresolution}}</td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <h2>Exported Packages</h2>\n\n  <table class="table table-striped table-bordered">\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Exported Version</th>\n        <th>Uses</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-repeat="(package, data) in row.ExportData">\n        <td>{{package}}</td>\n        <td>{{data.ReportedVersion}}</td>\n        <td class="osgi-bundle-exported-package-uses">{{data.headers.Duses}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <h2>Services</h2>\n\n  <h3>Registered Services</h3>\n\n  <ul class="list-group labels">\n    <li class="list-group-item" ng-repeat="id in row.RegisteredServices">\n      <span id="registers.service.{{id}}" class="text-success">{{id}}</span>\n    </li>\n  </ul>\n\n  <h3>Services used by this Bundle</h3>\n\n  <ul class="list-group labels">\n    <li class="list-group-item" ng-repeat="id in row.ServicesInUse">\n      <span id="uses.service.{{id}}" class="text-info">{{id}}</span>\n    </li>\n  </ul>\n\n  <div ng-if="row.RequiringBundles.length > 0">\n    <h2>Other Bundles using this Bundle</h2>\n\n    <ul class="list-unstyled">\n      <li ng-repeat="bundle in row.RequiringBundles"><a ng-href="{{bundle.url}}">{{bundle.label}}</a></li>\n    </ul>\n  </div>\n\n  <h2>Headers</h2>\n\n  <dl class="dl-horizontal osgi-bundle-headers-dl">\n    <dt ng-repeat-start="(key, value) in row.Headers" ng-show="showValue(key)">{{key}}</dt>\n    <dd ng-repeat-end ng-show="showValue(key)">{{value.Value}}</dd>\n  </dl>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/configurations.html','<h1>Configuration</h1>\n\n<div class="controller-section" ng-controller="Osgi.ConfigurationsController">\n\n  <div class="spinner spinner-lg loading-page" ng-if="!configurations"></div>\n  \n  <div ng-if="configurations">\n    <pf-toolbar config="toolbarConfig"></pf-toolbar>\n\n    <pf-list-view items="filteredConfigurations" config="listViewConfig" menu-actions="listViewMenuItems">\n      <div class="list-view-pf-left" ng-class="{\'osgi-configuration-factory-instance\': item.isFactoryInstance}">\n        <span class="list-view-pf-icon-sm" ng-class="item.kind.class" title="{{item.kind.title}}"></span>\n      </div>\n      <div class="list-view-pf-body">\n        <div class="list-view-pf-description">\n          <div class="list-group-item-heading" title="{{item.name}}">\n            <a ng-href="{{item.pidLink}}">{{item.name}}</a>\n          </div>\n          <div class="list-group-item-text">\n            {{item.description}}\n          </div>\n        </div>\n      </div>\n    </pf-list-view>\n  </div>\n  \n  <script type="text/ng-template" id="addPidDialog.html">\n    <form class="form-horizontal" ng-submit="$close(newPid)">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Add configuration</h4>\n      </div>\n      <div class="modal-body">\n        <div class="form-group">\n          <label class="col-sm-3 control-label" for="newPid">Configuration ID</label>\n          <div class="col-sm-9">\n            <input type="text" id="newPid" class="form-control" ng-model="newPid" required/>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n        <button type="submit" class="btn btn-primary" ng-disabled="!(newPid !== \'\' && newPid !== undefined)">Add</button>\n      </div>\n    </form>\n  </script>\n\n  <script type="text/ng-template" id="deletePidDialog.html">\n    <form class="form-horizontal" ng-submit="$close()">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$dismiss()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Delete configuration</h4>\n      </div>\n      <div class="modal-body">\n        <p>Delete \'{{item.name}}\' configuration?</p>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$dismiss()">Cancel</button>\n        <button type="submit" class="btn btn-danger">Delete</button>\n      </div>\n    </form>\n  </script>\n  \n</div>\n');
$templateCache.put('plugins/osgi/html/framework.html','<div class="framework-main" ng-controller="Osgi.FrameworkController">\n\n  <h1>Framework Configuration</h1>\n\n  <form class="form-horizontal framework-form" ng-submit="save()">\n    <div class="form-group">\n      <label class="col-sm-3 control-label" for="startLevel">Current Framework Start Level</label>\n      <div class="col-sm-2">\n        <input id="startLevel" class="form-control" type="number" min="0" max="100" ng-model="config.startLevel">\n      </div>\n    </div>\n    <div class="form-group">\n      <label class="col-sm-3 control-label" for="initialBundleStartLevel">Initial Bundle Start Level</label>\n      <div class="col-sm-2">\n        <input id="initialBundleStartLevel" class="form-control" type="number" min="0" max="100"\n          ng-model="config.initialBundleStartLevel">\n      </div>\n    </div>\n    <div class="form-group">\n      <div class="col-sm-offset-3 col-sm-2">\n        <button type="submit" class="btn btn-primary">Save</button>\n      </div>\n    </div>\n  </form>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/layoutOsgi.html','<div class="osgi-nav-main">\n  <ul class="nav nav-tabs" hawtio-auto-dropdown ng-controller="Karaf.NavBarController">\n    <li ng-class=\'{active : isActive("/osgi/bundle")}\'>\n        <a href="" ng-click="goto(\'/osgi/bundles\')">Bundles</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/features") || isActive("/osgi/feature")}\' ng-show="isFeaturesEnabled">\n      <a href="" ng-click="goto(\'/osgi/features\')">Features</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/package")}\'>\n      <a href="" ng-click="goto(\'/osgi/packages\')">Packages</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/service")}\'>\n      <a href="" ng-click="goto(\'/osgi/services\')">Services</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/scr-components")}\' ng-show="isScrEnabled">\n      <a href="" ng-click="goto(\'/osgi/scr-components\')">Declarative Services</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/server")}\'>\n      <a href="" ng-click="goto(\'/osgi/server\')">Server</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/fwk")}\'>\n      <a href="" ng-click="goto(\'/osgi/fwk\')">Framework</a>\n    </li>\n    <li ng-class=\'{active : isActive("/osgi/configuration") || isPrefixActive("/osgi/pid")}\'>\n      <a href="" ng-click="goto(\'/osgi/configurations\')">Configuration</a>\n    </li>\n    <li class="dropdown overflow">\n      <a href="#" class="dropdown-toggle" data-toggle="dropdown">\n        More <span class="caret"></span>\n      </a>\n      <ul class="dropdown-menu" role="menu"></ul>\n    </li>\n  </ul>\n  <div class="contents" ng-view></div>\n</div>\n');
$templateCache.put('plugins/osgi/html/packages.html','<h1>Packages</h1>\n\n<div class="osgi-packages-main" ng-controller="Osgi.PackagesController">\n\n  <div class="spinner spinner-lg loading-page" ng-if="!packages"></div>\n\n  <div ng-if="packages">\n    <pf-toolbar config="toolbarConfig"></pf-toolbar>\n\n    <div class="list-group list-view-pf list-view-pf-view osgi-packages-list" infinite-scroll="appendItems()"\n      infinite-scroll-distance="2" infinite-scroll-container=\'".osgi-nav-main .contents"\'>\n      <div class="list-group-item" ng-repeat="package in scrollablePackages"\n        ng-class="{\'list-view-pf-expand-active\': package.exportsExpanded || package.importsExpanded}">\n        <div class="list-view-pf-main-info">\n          <div class="list-view-pf-body">\n            <div class="list-view-pf-description">\n              <div class="list-group-item-heading" title="{{package.Name}}">\n                {{package.Name}}\n              </div>\n              <div class="list-group-item-text">\n                {{package.Version}}\n              </div>\n            </div>\n            <div class="list-view-pf-additional-info">\n              <div class="list-view-pf-additional-info-item">\n                <div class="list-view-pf-expand" ng-class="{\'active\': package.exportsExpanded}"\n                  ng-click="package.exportsExpanded = !package.exportsExpanded; package.importsExpanded = false;">\n                  <span class="fa fa-angle-right" ng-class="{\'fa-angle-down\': package.exportsExpanded}"></span>\n                  <span class="pficon pficon-export"></span>\n                  <strong>{{package.ExportingBundles.length}}</strong>\n                  Exporting Bundle{{package.ExportingBundles.length !== 1 ? \'s\' : \'\'}}\n                </div>\n              </div>\n              <div class="list-view-pf-additional-info-item">\n                <div class="list-view-pf-expand" ng-class="{\'active\': package.importsExpanded}"\n                  ng-click="package.importsExpanded = !package.importsExpanded; package.exportsExpanded = false;">\n                  <span class="fa fa-angle-right" ng-class="{\'fa-angle-down\': package.importsExpanded}"></span>\n                  <span class="pficon pficon-import"></span>\n                  <strong>{{package.ImportingBundles.length}}</strong>\n                  Importing Bundle{{package.ImportingBundles.length !== 1 ? \'s\' : \'\'}}\n                </div>\n              </div>\n              <div class="list-view-pf-additional-info-item">\n                <div class="list-view-pf-expand">\n                  <span ng-show="package.RemovalPending">\n                    <span class="pficon pficon-warning-triangle-o"></span>\n                    Removal Pending\n                  </span>\n                </div>\n              </div>\n            </div>              \n          </div>\n        </div>\n        <div class="list-group-item-container" ng-if="package.exportsExpanded">\n          <div class="close" ng-click="package.exportsExpanded = false">\n            <span class="pficon pficon-close"></span>\n          </div>\n          <dl>\n            <dt>Exporting Bundles</dt>\n            <dd>\n              <ul class="package-bundles-list">\n                <li ng-repeat="bundle in package.ExportingBundles">\n                  <a title="Exported by bundle {{bundle.Identifier}}" ng-href="{{bundle.Url}}">{{bundle.SymbolicName}}</a>\n                </li>\n              </ul>\n            </dd>\n          </dl>\n        </div>\n        <div class="list-group-item-container" ng-if="package.importsExpanded">\n          <div class="close" ng-click="package.importsExpanded = false">\n            <span class="pficon pficon-close"></span>\n          </div>\n          <dl>\n            <dt>Importing Bundles</dt>\n            <dd>\n              <ul class="package-bundles-list">\n                <li ng-repeat="bundle in package.ImportingBundles">\n                  <a title="Imported by bundle {{bundle.Identifier}}" ng-href="{{bundle.Url}}">{{bundle.SymbolicName}}</a>\n                </li>\n              </ul>\n            </dd>\n          </dl>\n        </div>\n      </div>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/pid.html','<div class="pid-view" ng-controller="Osgi.PidController">\n\n  <ol class="breadcrumb">\n    <li>\n        <a ng-href="{{configurationUrl}}">Configuration</a>\n    </li>\n    <li class="page-title">\n      {{zkPid || metaType.name || pid}}\n    </li>\n  </ol>  \n  \n  <pf-toolbar config="toolbarConfig"></pf-toolbar>\n  \n  <div ng-hide="editMode">\n    <div class="row config-admin-form view">\n      <div class="col-sm-12">\n        <div simple-form class="pid-form" name="pidEditor" mode=\'view\' entity=\'entity\' data=\'schema\' schema="fullSchema"></div>\n      </div>\n    </div>\n  </div>\n  \n  <div ng-show="editMode">\n    <div class="row config-admin-form edit">\n      <div ng-show="newPid" class="col-sm-12 new-config-name-form">\n        <form class="form-horizontal" action="">\n          <fieldset>\n            <div class="spacer"></div>\n            <div class="form-group">\n              <label class="col-sm-2 control-label" title="The name of the configuration file">\n                Configuration name\n              </label>\n              <div class="col-sm-10">\n                <input type="text" title="The name of the configuration file" ng-required="true"\n                        ng-model="createForm.pidInstanceName" name="path" autofocus>\n              </div>\n            </div>\n          </fieldset>\n        </form>\n      </div>\n      <div class="col-sm-12">\n        <div simple-form name="pidEditor" mode=\'edit\' entity=\'entity\' data=\'schema\' schema="fullSchema" onSubmit="pidSave()"></div>\n      </div>\n    </div>\n    <div class="row">\n      <div class="col-sm-2"></div>\n      <div class="col-sm-10">\n        <button class="btn btn-primary" ng-show="newPid" ng-disabled="!canSave || !createForm.pidInstanceName" ng-click="pidSave()">Create</button>\n        <button class="btn btn-primary" ng-hide="newPid" ng-disabled="!canSave" ng-click="pidSave()">Save</button>\n        <button class="btn btn-default" ng-click="cancelSave()">Cancel</button>\n      </div>\n    </div>\n  </div>\n\n  <script type="text/ng-template" id="deletePropDialog.html">\n    <form name="deleteProperty" class="form-horizontal no-bottom-margin" ng-submit="deletePidPropConfirmed()">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$close()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Delete property \'{{deleteKey}}\'</h4>\n      </div>\n      <div class="modal-body">\n        <p class="lead">Are you sure?</p>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$close()">Cancel</button>\n        <button type="submit" class="btn btn-danger">Delete</button>\n      </div>\n    </form>\n  </script>\n\n  <script type="text/ng-template" id="addPropertyDialog.html">\n    <form name="addProperty" class="form-horizontal"\n          ng-submit="addPropertyConfirmed(addPropKey, addPropValue)">\n      <div class="modal-header">\n        <button type="button" class="close" aria-label="Close" ng-click="$close()">\n          <span class="pficon pficon-close" aria-hidden="true"></span>\n        </button>\n        <h4>Add property</h4>\n      </div>\n      <div class="modal-body">\n        <div class="form-group">\n          <label class="col-sm-2 control-label" for="propKey">Key</label>\n          <div class="col-sm-10">\n            <input type="text" class="form-control" id="propKey" ng-model="addPropKey" required>\n          </div>\n        </div>\n        <div class="form-group">\n          <label class="col-sm-2 control-label" for="propValue">Value</label>\n          <div class="col-sm-10">\n            <input type="text" class="form-control" id="propValue" ng-model="addPropValue"/>\n          </div>\n        </div>\n      </div>\n      <div class="modal-footer">\n        <button type="button" class="btn btn-default" ng-click="$close()">Cancel</button>\n        <button type="submit" class="btn btn-primary">Add</button>\n      </div>\n    </form>\n  </script>\n\n</div>\n');
$templateCache.put('plugins/osgi/html/services.html','<h1>Services</h1>\n\n<div class="controller-section" ng-controller="Osgi.ServiceController">\n\n  <div class="spinner spinner-lg loading-page" ng-if="!services"></div>\n\n  <div ng-if="services">\n    <pf-toolbar config="toolbarConfig"></pf-toolbar>\n\n    <div class="list-group list-view-pf list-view-pf-view">\n      <div class="list-group-item" ng-class="{\'list-view-pf-expand-active\': service.expanded}"\n          ng-repeat="service in filteredServices">\n        <div class="list-group-item-header" ng-click="service.expanded = !service.expanded">\n          <div class="list-view-pf-expand">\n            <span class="fa fa-angle-right" ng-class="{\'fa-angle-down\': service.expanded}"></span>\n          </div>\n          <div class="list-view-pf-main-info">\n            <div class="list-view-pf-body">\n              <div class="list-view-pf-description">\n                <div class="list-group-item-heading">\n                  ID {{service.Identifier}}\n                </div>\n                <div class="list-group-item-text" ng-bind-html="service.BundleLinks">\n                </div>\n              </div>\n              <div class="list-view-pf-additional-info">\n                <div class="list-view-pf-additional-info-item" title="Object Classes">\n                  {{service.objectClass[0]}}{{service.objectClass.length > 1 ? \'...\' : \'\'}}\n                </div>\n              </div>              \n            </div>\n          </div>\n        </div>\n        <div class="list-group-item-container" ng-if="service.expanded">\n          <div class="close" ng-click="service.expanded = false">\n            <span class="pficon pficon-close"></span>\n          </div>\n          <div class="col-md-5">\n            <dl>\n              <dt>Using Bundles</dt>\n              <dd>\n                <ul class="service-bundles-list">\n                  <li ng-repeat="bundle in service.UsingBundles">\n                    <a ng-href="{{bundle.Url}}">{{bundle.SymbolicName}}</a>\n                  </li>\n                </ul>\n              </dd>\n            </dl>\n          </div>\n          <div class="col-md-5">\n            <dl>\n              <dt>Object Classes</dt>\n              <dd>\n                <ul class="service-object-classes-list">\n                  <li ng-repeat="clazz in service.objectClass">\n                    {{clazz}}\n                  </li>\n                </ul>\n              </dd>\n            </dl>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n\n</div>\n');
$templateCache.put('plugins/activemq/doc/help.md','### ActiveMQ\n\nClick [ActiveMQ](#/jmx/attributes?tab=activmemq) in the top navigation bar to see the ActiveMQ specific plugin. (The ActiveMQ tab won\'t appear if there is no broker in this JVM).  The ActiveMQ plugin works very much the same as the JMX plugin however with a focus on interacting with an ActiveMQ broker.\n\nThe tree view on the left-hand side shows the top level JMX tree of each broker instance running in the JVM.  Expanding the tree will show the various MBeans registered by ActiveMQ that you can inspect via the **Attributes** tab.\n\nYou can then click on the **Queue** node to see the queues and **Topic** node to see the topics. From either of these nodes you should see **Create Queue** or **Create Topic** tabs to be able to create new destinations.\n\nOnce you have selected a destination you should be able to **Send** to it, **Browse** a queue or view the  **Attributes** or **Charts**\n\nYou can also see a graphical view of all producers, destinations and consumers for all queues (or if you select a Topic folder then topics) using the **Diagram** tab. Selecting a single queue or topic shows just all the producers and consumers on that destination. This diagram makes it easy to spot if producers are sending messages when there are no consumers, or that consumers are on the wrong destination etc.\n');
$templateCache.put('plugins/camel/doc/help.md','### Camel\n\nClick [Camel](#/jmx/attributes?tab=camel) in the top navigation bar to view all the running Camel Contexts in the current JVM. (The selection will not appear on the navigation bar if there is no Camel running).\n\nThe Camel plugin allows you to view all the running Camel applications in the current JVM.\nYou can among others see the following details:\n\n* Lists of all running Camel applications\n* Detailed information of each Camel Context such as Camel version number, runtime statics\n* Lists of all routes in each Camel applications and their runtime statistics\n* Manage the lifecycle of all Camel applications and their routes, so you can restart / stop / pause / resume, etc.\n* Graphical representation of the running routes along with real time metrics\n* Live tracing and debugging of running routes\n* Profile the running routes with real time runtime statics; detailed specified per processor\n* Browsing and sending messages to Camel endpoint\n');
$templateCache.put('plugins/karaf/doc/help.md','### Karaf\n\nThis plugin supports the [Apache Karaf](http://karaf.apache.org/) container');
$templateCache.put('plugins/osgi/doc/help.md','### OSGi\n\nThis plugin supports the various OSGi standards for working with bundles, Config Admin, services, packages etc.');}]); hawtioPluginLoader.addModule("hawtio-integration-templates");